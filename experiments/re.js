(function(e){e.inject({dirCache:{"fractal-core@4.3.8":["/CHANGES.md","/core/core.d.ts","/core/core.js","/core/core.js.map","/core/handler.d.ts","/core/handler.js","/core/handler.js.map","/core/index.d.ts","/core/index.js","/core/index.js.map","/core/input.d.ts","/core/input.js","/core/input.js.map","/core/interface.d.ts","/core/interface.js","/core/interface.js.map","/core/module.d.ts","/core/module.js","/core/module.js.map","/groups/style.d.ts","/groups/style.js","/groups/style.js.map","/interfaces/route.d.ts","/interfaces/route.js","/interfaces/route.js.map","/interfaces/router.d.ts","/interfaces/router.js","/interfaces/router.js.map","/interfaces/value.d.ts","/interfaces/value.js","/interfaces/value.js.map","/interfaces/view/eventListeners.d.ts","/interfaces/view/eventListeners.js","/interfaces/view/eventListeners.js.map","/interfaces/view/globalListeners.d.ts","/interfaces/view/globalListeners.js","/interfaces/view/globalListeners.js.map","/interfaces/view/h.d.ts","/interfaces/view/h.js","/interfaces/view/h.js.map","/interfaces/view/index.d.ts","/interfaces/view/index.js","/interfaces/view/index.js.map","/interfaces/view/is.d.ts","/interfaces/view/is.js","/interfaces/view/is.js.map","/interfaces/view/resizeSensor.d.ts","/interfaces/view/resizeSensor.js","/interfaces/view/resizeSensor.js.map","/interfaces/view/sizeBinding.d.ts","/interfaces/view/sizeBinding.js","/interfaces/view/sizeBinding.js.map","/interfaces/view/utils.d.ts","/interfaces/view/utils.js","/interfaces/view/utils.js.map","/interfaces/view/utils.spec.d.ts","/interfaces/view/utils.spec.js","/interfaces/view/utils.spec.js.map","/interfaces/view/view.spec.d.ts","/interfaces/view/view.spec.js","/interfaces/view/view.spec.js.map","/interfaces/view/view-effects.d.ts","/interfaces/view/view-effects.js","/interfaces/view/view-effects.js.map","/interfaces/view/view-worker.d.ts","/interfaces/view/view-worker.js","/interfaces/view/view-worker.js.map","/interfaces/view/vnode.d.ts","/interfaces/view/vnode.js","/interfaces/view/vnode.js.map","/LICENSE","/package.json","/README.md","/tasks/size.d.ts","/tasks/size.js","/tasks/size.js.map","/tasks/view.d.ts","/tasks/view.js","/tasks/view.js.map","/toHTML/elements.d.ts","/toHTML/elements.js","/toHTML/elements.js.map","/toHTML/index.d.ts","/toHTML/index.js","/toHTML/index.js.map","/toHTML/init.d.ts","/toHTML/init.js","/toHTML/init.js.map","/toHTML/modules/attributes.d.ts","/toHTML/modules/attributes.js","/toHTML/modules/attributes.js.map","/toHTML/modules/class.d.ts","/toHTML/modules/class.js","/toHTML/modules/class.js.map","/toHTML/modules/index.d.ts","/toHTML/modules/index.js","/toHTML/modules/index.js.map","/toHTML/modules/props.d.ts","/toHTML/modules/props.js","/toHTML/modules/props.js.map","/toHTML/modules/style.d.ts","/toHTML/modules/style.js","/toHTML/modules/style.js.map","/typings/globals/jasmine/index.d.ts","/typings/globals/jasmine/typings.json","/typings/globals/webpack-env/index.d.ts","/typings/globals/webpack-env/typings.json","/typings/index.d.ts","/typings/Mori.d.ts","/utils/aot.d.ts","/utils/aot.js","/utils/aot.js.map","/utils/component.d.ts","/utils/component.js","/utils/component.js.map","/utils/fun.d.ts","/utils/fun.js","/utils/fun.js.map","/utils/fun.spec.d.ts","/utils/fun.spec.js","/utils/fun.spec.js.map","/utils/hotSwap.spec.d.ts","/utils/hotSwap.spec.js","/utils/hotSwap.spec.js.map","/utils/index.d.ts","/utils/index.js","/utils/index.js.map","/utils/log.d.ts","/utils/log.js","/utils/log.js.map","/utils/mori.d.ts","/utils/mori.js","/utils/mori.js.map","/utils/reattach.d.ts","/utils/reattach.js","/utils/reattach.js.map","/utils/reattach.spec.d.ts","/utils/reattach.spec.js","/utils/reattach.spec.js.map","/utils/ssr.d.ts","/utils/ssr.js","/utils/ssr.js.map","/utils/style.d.ts","/utils/style.js","/utils/style.js.map","/utils/worker.d.ts","/utils/worker.js","/utils/worker.js.map","/utils/worker.spec.d.ts","/utils/worker.spec.js","/utils/worker.spec.js.map"],"@types/core-js@0.9.43":["/LICENSE","/README.md","/index.d.ts","/package.json"],"@types/node@8.5.2":["/LICENSE","/README.md","/index.d.ts","/inspector.d.ts","/package.json"],"setimmediate@1.0.5":["/LICENSE.txt","/package.json","/setImmediate.js"],"deepmerge@1.5.2":["/README.markdown","/changelog.md","/dist/cjs.js","/dist/es.js","/dist/umd.js","/index.js","/license.txt","/package.json","/rollup.config.js"],"typestyle@1.5.1":["/.npmignore","/.vscode/settings.json","/CHANGELOG.md","/LICENSE","/README.md","/lib/index.d.ts","/lib/index.js","/lib/internal/formatting.d.ts","/lib/internal/formatting.js","/lib/internal/typestyle.d.ts","/lib/internal/typestyle.js","/lib/internal/utilities.d.ts","/lib/internal/utilities.js","/lib/types.d.ts","/lib/types.js","/lib.es2015/index.js","/lib.es2015/internal/formatting.js","/lib.es2015/internal/typestyle.js","/lib.es2015/internal/utilities.js","/lib.es2015/types.js","/package.json","/src/index.ts","/src/internal/formatting.ts","/src/internal/typestyle.ts","/src/internal/utilities.ts","/src/types.ts","/tsconfig.es2015.json","/tsconfig.json","/umd/index.html","/umd/index.min.html","/umd/typestyle.js","/umd/typestyle.min.js","/webpack.config.js"],"snabbdom@0.7.1":["/LICENSE","/README.md","/dist/h.js","/dist/h.min.js","/dist/h.min.js.map","/dist/snabbdom-attributes.js","/dist/snabbdom-attributes.min.js","/dist/snabbdom-attributes.min.js.map","/dist/snabbdom-class.js","/dist/snabbdom-class.min.js","/dist/snabbdom-class.min.js.map","/dist/snabbdom-dataset.js","/dist/snabbdom-eventlisteners.js","/dist/snabbdom-eventlisteners.min.js","/dist/snabbdom-eventlisteners.min.js.map","/dist/snabbdom-patch.js","/dist/snabbdom-patch.min.js","/dist/snabbdom-patch.min.js.map","/dist/snabbdom-props.js","/dist/snabbdom-props.min.js","/dist/snabbdom-props.min.js.map","/dist/snabbdom-style.js","/dist/snabbdom-style.min.js","/dist/snabbdom-style.min.js.map","/dist/snabbdom.js","/dist/snabbdom.min.js","/dist/snabbdom.min.js.map","/dist/tovnode.js","/dist/tovnode.min.js","/dist/tovnode.min.js.map","/es/h.d.ts","/es/h.js","/es/h.js.map","/es/helpers/attachto.d.ts","/es/helpers/attachto.js","/es/helpers/attachto.js.map","/es/hooks.d.ts","/es/hooks.js","/es/hooks.js.map","/es/htmldomapi.d.ts","/es/htmldomapi.js","/es/htmldomapi.js.map","/es/is.d.ts","/es/is.js","/es/is.js.map","/es/modules/attributes.d.ts","/es/modules/attributes.js","/es/modules/attributes.js.map","/es/modules/class.d.ts","/es/modules/class.js","/es/modules/class.js.map","/es/modules/dataset.d.ts","/es/modules/dataset.js","/es/modules/dataset.js.map","/es/modules/eventlisteners.d.ts","/es/modules/eventlisteners.js","/es/modules/eventlisteners.js.map","/es/modules/hero.d.ts","/es/modules/hero.js","/es/modules/hero.js.map","/es/modules/module.d.ts","/es/modules/module.js","/es/modules/module.js.map","/es/modules/props.d.ts","/es/modules/props.js","/es/modules/props.js.map","/es/modules/style.d.ts","/es/modules/style.js","/es/modules/style.js.map","/es/snabbdom.bundle.d.ts","/es/snabbdom.bundle.js","/es/snabbdom.bundle.js.map","/es/snabbdom.d.ts","/es/snabbdom.js","/es/snabbdom.js.map","/es/thunk.d.ts","/es/thunk.js","/es/thunk.js.map","/es/tovnode.d.ts","/es/tovnode.js","/es/tovnode.js.map","/es/vnode.d.ts","/es/vnode.js","/es/vnode.js.map","/examples/carousel-svg/README.md","/examples/carousel-svg/build.js","/examples/carousel-svg/index.html","/examples/carousel-svg/script.js","/examples/hero/build.js","/examples/hero/index.html","/examples/hero/script.js","/examples/reorder-animation/build.js","/examples/reorder-animation/index.html","/examples/reorder-animation/script.js","/examples/svg/build.js","/examples/svg/index.html","/examples/svg/script.js","/gulpfile.js","/h.d.ts","/h.js","/h.js.map","/helpers/attachto.d.ts","/helpers/attachto.js","/helpers/attachto.js.map","/hooks.d.ts","/hooks.js","/hooks.js.map","/htmldomapi.d.ts","/htmldomapi.js","/htmldomapi.js.map","/is.d.ts","/is.js","/is.js.map","/modules/attributes.d.ts","/modules/attributes.js","/modules/attributes.js.map","/modules/class.d.ts","/modules/class.js","/modules/class.js.map","/modules/dataset.d.ts","/modules/dataset.js","/modules/dataset.js.map","/modules/eventlisteners.d.ts","/modules/eventlisteners.js","/modules/eventlisteners.js.map","/modules/hero.d.ts","/modules/hero.js","/modules/hero.js.map","/modules/module.d.ts","/modules/module.js","/modules/module.js.map","/modules/props.d.ts","/modules/props.js","/modules/props.js.map","/modules/style.d.ts","/modules/style.js","/modules/style.js.map","/package.json","/snabbdom.bundle.d.ts","/snabbdom.bundle.js","/snabbdom.bundle.js.map","/snabbdom.d.ts","/snabbdom.js","/snabbdom.js.map","/src/h.ts","/src/helpers/attachto.ts","/src/hooks.ts","/src/htmldomapi.ts","/src/is.ts","/src/modules/attributes.ts","/src/modules/class.ts","/src/modules/dataset.ts","/src/modules/eventlisteners.ts","/src/modules/hero.ts","/src/modules/module.ts","/src/modules/props.ts","/src/modules/style.ts","/src/snabbdom.bundle.ts","/src/snabbdom.ts","/src/thunk.ts","/src/tovnode.ts","/src/vnode.ts","/testem.json","/thunk.d.ts","/thunk.js","/thunk.js.map","/tovnode.d.ts","/tovnode.js","/tovnode.js.map","/tsconfig.json","/vnode.d.ts","/vnode.js","/vnode.js.map"],"free-style@2.5.1":["/LICENSE","/README.md","/dist/free-style.d.ts","/dist/free-style.js","/dist/free-style.js.map","/dist/free-style.spec.d.ts","/dist/free-style.spec.js","/dist/free-style.spec.js.map","/dist.es2015/free-style.js","/dist.es2015/free-style.js.map","/package.json"]},vendorFiles:{"https://unpkg.com/fractal-core@4.3.8/core/core.d.ts":{"fullPath":"https://unpkg.com/fractal-core@4.3.8/core/core.d.ts","contents":"import { HandlerMsg, HandlerObject } from './handler';\nimport { InterfaceHelpers } from './interface';\nimport { InputHelpers } from './input';\nimport { Module } from './module';\nexport interface Component<S> {\n    state?: S;\n    inputs?: Inputs;\n    actions?: Actions<S>;\n    interfaces: Interfaces;\n    groups?: {\n        [name: string]: Group;\n    };\n}\nexport interface Components {\n    [name: string]: Component<any>;\n}\nexport interface Interfaces {\n    [name: string]: Interface<any, any>;\n}\nexport declare type Group = any;\nexport interface Inputs {\n    (helpers: InputHelpers): InputIndex;\n}\nexport interface InputIndex {\n    [name: string]: Input;\n}\nexport interface Input {\n    (data?: any): void;\n}\nexport interface Action<S> {\n    (data?: any): Update<S>;\n}\nexport interface Actions<S> {\n    [name: string]: Action<S>;\n}\nexport interface EventOptions {\n    default?: boolean;\n    listenPrevented?: boolean;\n    selfPropagated?: boolean;\n}\nexport interface InputData extends Array<any> {\n    0: string;\n    1: string;\n    2?: any;\n    3?: any;\n    4?: EventOptions;\n}\nexport interface EventData extends Array<any> {\n    0: string;\n    1: string;\n    2?: any;\n}\nexport interface Update<S> {\n    (state: S): Promise<S> | S;\n}\nexport interface Interface<Type, S> {\n    (helpers: InterfaceHelpers): CtxInterface<Type, S>;\n}\nexport interface CtxInterface<Type, S> {\n    (state: S): Promise<Type>;\n}\nexport interface CtxInterfaceIndex {\n    [name: string]: CtxInterface<any, any>;\n}\nexport interface Task extends Array<any> {\n    0: string;\n    1?: HandlerMsg;\n}\nexport interface Context {\n    id: string;\n    name: string;\n    state: {\n        [name: string]: any;\n    };\n    inputs: InputIndex;\n    actions: Actions<any>;\n    interfaces: CtxInterfaceIndex;\n    interfaceValues: {\n        [name: string]: any;\n    };\n    groups: {\n        [name: string]: Group;\n    };\n    components: ContextIndex;\n    groupHandlers: {\n        [name: string]: HandlerObject;\n    };\n    taskHandlers: {\n        [name: string]: HandlerObject;\n    };\n    interfaceHandlers: {\n        [name: string]: HandlerObject;\n    };\n    global: {\n        record: boolean;\n        records: ActionRecord[];\n        log: boolean;\n        render: boolean;\n        moduleRender: boolean;\n        hotSwap: boolean;\n        rootCtx: Context;\n        active: boolean;\n    };\n    beforeInput?(ctxIn: Context, inputName: string, data: any): void;\n    afterInput?(ctxIn: Context, inputName: string, data: any): void;\n    warn: {\n        (source: string, description: string): void;\n    };\n    error: {\n        (source: string, description: string): void;\n    };\n}\nexport interface ActionRecord {\n    id: string;\n    actionName: string;\n    value: any;\n}\nexport interface ContextIndex {\n    [id: string]: Context;\n}\nexport declare type Executable<S> = Update<S> | Task;\nexport declare type GenericExecutable<S> = Update<S> | Task | Executable<any>[];\nexport interface RunModule {\n    (root: Component<any>, DEV: boolean, options?: any, viewCb?: any): Promise<Module>;\n}\n"},"https://unpkg.com/fractal-core@4.3.8/core/handler.d.ts":{"fullPath":"https://unpkg.com/fractal-core@4.3.8/core/handler.d.ts","contents":"import { ModuleAPI } from './module';\nexport interface Handler {\n    (...params: any[]): HandlerInterface;\n}\nexport interface HandlerInterface {\n    (mod: ModuleAPI): HandlerObject;\n}\nexport interface HandlerObject {\n    state: any;\n    handle: HandlerFunction;\n    dispose: {\n        (): void;\n    };\n}\nexport interface HandlerFunction {\n    (value: HandlerMsg): Promise<any>;\n}\nexport declare type HandlerMsg = any;\n"},"https://unpkg.com/fractal-core@4.3.8/core/index.d.ts":{"fullPath":"https://unpkg.com/fractal-core@4.3.8/core/index.d.ts","contents":"export * from './core';\nexport * from './module';\nexport * from './input';\nexport * from './interface';\nexport * from './handler';\nexport * from '../utils';\n"},"https://unpkg.com/fractal-core@4.3.8/core/index.js":{"fullPath":"https://unpkg.com/fractal-core@4.3.8/core/index.js","contents":"\"use strict\";\n// core functions\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./module\"));\n__export(require(\"./input\"));\n__export(require(\"./interface\"));\n// other functions\n__export(require(\"../utils\"));\n//# sourceMappingURL=index.js.map"},"https://unpkg.com/fractal-core@4.3.8/core/input.d.ts":{"fullPath":"https://unpkg.com/fractal-core@4.3.8/core/input.d.ts","contents":"import { Context, GenericExecutable } from './core';\nimport { CtxEv, CtxAct } from './interface';\nimport { CtxToIt } from './module';\nexport interface InputHelpers {\n    ctx: Context;\n    ev: CtxEv;\n    act: CtxAct;\n    stateOf: CtxStateOf;\n    toIt: CtxToIt;\n    toChild: CtxToChild;\n    toAct: CtxToAct;\n    runIt: CtxRunIt;\n    comps: CtxComponentHelpers;\n    clearCache: CtxClearCache;\n}\nexport declare const makeInputHelpers: (ctx: Context) => InputHelpers;\nexport interface CtxStateOf {\n    (name?: string): any;\n}\nexport declare const _stateOf: (ctx: Context) => CtxStateOf;\nexport interface CtxToChild {\n    (childCompName: string, inputName: string, msg?: any, isPropagated?: boolean): void;\n}\nexport declare const toChild: (ctx: Context) => (childCompName: any, inputName: any, msg?: any, isAsync?: boolean, isPropagated?: boolean) => Promise<void>;\nexport interface CtxToAct {\n    (actionName: string, data?: any, isPropagated?: boolean): Promise<any>;\n}\nexport declare const toAct: (ctx: Context) => CtxToAct;\nexport interface CtxRunIt {\n    (executables: GenericExecutable<any>, isPropagated?: boolean): Promise<any>;\n}\nexport declare const runIt: (ctx: Context) => CtxRunIt;\nexport interface CtxClearCache {\n    (interfaceName: string, childNames?: string[]): void;\n}\nexport declare const _clearCache: (ctx: Context) => CtxClearCache;\nexport interface Instruction extends Array<any> {\n    0: string;\n    1: string;\n    2: any;\n}\nexport interface ComponentHelpers {\n    getState(key: string, options?: {\n        exceptions?: string[];\n        nameFn?(name: string): string;\n    }): any;\n    getStates(options?: {\n        exceptions?: string[];\n        nameFn?(name: string): string;\n    }): any;\n    executeAll(insts: Instruction[]): void;\n    broadcast(inputName: string, data?: any): void;\n    optionalBroadcast(inputName: string, data?: any): void;\n    seqBroadcast(inputName: string, data?: any): Promise<any>;\n    seqOptionalBroadcast(inputName: string, data?: any): Promise<any>;\n    getNames(): string[];\n    getCompleteNames(): string[];\n}\nexport interface CtxComponentHelpers {\n    (groupName: string): ComponentHelpers;\n}\nexport declare const getName: (name: string) => string;\nexport declare const getCompleteNames: (state: any, groupName: string) => string[];\nexport declare const getNames: (state: any, groupName: string) => string[];\nexport declare const _componentHelpers: (ctx: Context) => CtxComponentHelpers;\n"},"https://unpkg.com/fractal-core@4.3.8/core/input.js":{"fullPath":"https://unpkg.com/fractal-core@4.3.8/core/input.js","contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst interface_1 = require(\"./interface\");\nconst module_1 = require(\"./module\");\nconst index_1 = require(\"./index\");\nexports.makeInputHelpers = (ctx) => ({\n    ctx,\n    ev: interface_1._ev(ctx),\n    act: interface_1._act(ctx),\n    stateOf: exports._stateOf(ctx),\n    toIt: module_1.toIt(ctx),\n    toChild: exports.toChild(ctx),\n    toAct: exports.toAct(ctx),\n    runIt: exports.runIt(ctx),\n    comps: exports._componentHelpers(ctx),\n    clearCache: exports._clearCache(ctx),\n});\nexports._stateOf = (ctx) => name => {\n    let id = name ? ctx.id + '$' + name : ctx.id;\n    let space = ctx.components[id];\n    if (space) {\n        return space.state;\n    }\n    else {\n        ctx.error('stateOf', name\n            ? `there are no child '${name}' in space '${ctx.id}'`\n            : `there are no space '${id}'`);\n    }\n};\n// send a message to an input of a component from its parent\nexports.toChild = (ctx) => async (childCompName, inputName, msg = undefined, isAsync = false, isPropagated = true) => {\n    let childId = ctx.id + '$' + childCompName;\n    let compCtx = ctx.components[childId];\n    if (compCtx) {\n        return await module_1.toIt(compCtx)(inputName, msg, isPropagated);\n    }\n    else {\n        ctx.error('toChild', `there are no child '${childCompName}' in space '${ctx.id}'`);\n    }\n};\n// generic action self caller\nexports.toAct = (ctx) => {\n    let _toIt = module_1.toIt(ctx);\n    return async (actionName, data, isPropagated = true) => await _toIt('_action', [actionName, data], isPropagated);\n};\n// generic action self caller\nexports.runIt = (ctx) => {\n    let _toIt = module_1.toIt(ctx);\n    return async (executables, isPropagated = true) => await _toIt('_execute', executables, isPropagated);\n};\n// Clear interface cache\nexports._clearCache = (ctx) => {\n    return (interfaceName, childNames) => {\n        let descendantIds, childId;\n        if (childNames) {\n            for (let i = 0, childName; childName = childNames[i]; i++) {\n                childId = ctx.id + '$' + childName;\n                ctx.components[childId].interfaceValues[interfaceName] = undefined;\n                descendantIds = index_1.getDescendantIds(ctx, childId);\n                for (let j = 0, descId; descId = descendantIds[j]; j++) {\n                    ctx.components[descId].interfaceValues[interfaceName] = undefined;\n                }\n            }\n        }\n        else {\n            ctx.components[ctx.id].interfaceValues[interfaceName] = undefined;\n            descendantIds = index_1.getDescendantIds(ctx, childId);\n            for (let j = 0, descId; descId = descendantIds[j]; j++) {\n                ctx.components[descId].interfaceValues[interfaceName] = undefined;\n            }\n        }\n    };\n};\nexports.getName = (name) => name.split('_')[1];\nexports.getCompleteNames = (state, groupName) => Object.keys(state._nest)\n    .filter(name => name.split('_')[0] === groupName);\nexports.getNames = (state, groupName) => exports.getCompleteNames(state, groupName)\n    .map(n => n.split('_')[1]);\nexports._componentHelpers = (ctx) => {\n    let _toChild = exports.toChild(ctx);\n    let stateOf = exports._stateOf(ctx);\n    return groupName => {\n        let completeNames = Object.keys(ctx.components[ctx.id].state._nest)\n            .filter(name => name.split('_')[0] === groupName);\n        let componentNames = completeNames.map(n => n.split('_')[1]);\n        return {\n            getState(key, options) {\n                let obj = {};\n                let name;\n                let exceptions = options && options.exceptions;\n                let nameFn = options && options.nameFn;\n                for (let i = 0, len = completeNames.length; i < len; i++) {\n                    if (exceptions && exceptions.indexOf(componentNames[i]) === -1 || !exceptions) {\n                        name = componentNames[i];\n                        name = nameFn ? nameFn(name) : name;\n                        obj[name] = stateOf(completeNames[i])[key];\n                    }\n                }\n                return obj;\n            },\n            getStates(options) {\n                let obj = {};\n                let name;\n                let exceptions = options && options.exceptions;\n                let nameFn = options && options.nameFn;\n                for (let i = 0, len = completeNames.length; i < len; i++) {\n                    if (exceptions && exceptions.indexOf(completeNames[i]) === -1 || !exceptions) {\n                        name = exports.getName(completeNames[i]);\n                        name = nameFn ? nameFn(name) : name;\n                        obj[name] = stateOf(completeNames[i]);\n                    }\n                }\n                return obj;\n            },\n            executeAll(insts) {\n                for (let i = 0, inst; inst = insts[i]; i++) {\n                    _toChild(groupName + '_' + inst[0], inst[1], inst[2]);\n                }\n            },\n            broadcast(inputName, data) {\n                for (let i = 0, name; name = completeNames[i]; i++) {\n                    _toChild(name, inputName, data);\n                }\n            },\n            optionalBroadcast(inputName, data) {\n                for (let i = 0, name; name = completeNames[i]; i++) {\n                    if (ctx.components[ctx.id + '$' + name].inputs[inputName]) {\n                        _toChild(name, inputName, data);\n                    }\n                }\n            },\n            async seqBroadcast(inputName, data) {\n                for (let i = 0, name; name = completeNames[i]; i++) {\n                    await _toChild(name, inputName, data);\n                }\n            },\n            async seqOptionalBroadcast(inputName, data) {\n                for (let i = 0, name; name = completeNames[i]; i++) {\n                    if (ctx.components[ctx.id + '$' + name].inputs[inputName]) {\n                        await _toChild(name, inputName, data);\n                    }\n                }\n            },\n            getNames() {\n                return componentNames;\n            },\n            getCompleteNames() {\n                return completeNames;\n            }\n        };\n    };\n};\n//# sourceMappingURL=input.js.map"},"https://unpkg.com/fractal-core@4.3.8/core/interface.d.ts":{"fullPath":"https://unpkg.com/fractal-core@4.3.8/core/interface.d.ts","contents":"import { Context, InputData, EventOptions, EventData } from './core';\nimport { HandlerMsg } from './handler';\nimport { CtxStateOf } from './input';\nexport interface InterfaceHelpers {\n    ctx: Context;\n    interfaceOf: CtxInterfaceOf;\n    stateOf: CtxStateOf;\n    ev: CtxEv;\n    act: CtxAct;\n    vw: CtxVw;\n    vws: CtxVws;\n    group: CtxGroup;\n}\nexport declare const makeInterfaceHelpers: (ctx: Context) => InterfaceHelpers;\nexport interface CtxInterfaceOf {\n    (name: string, interfaceName: string): Promise<any>;\n}\nexport declare const _interfaceOf: (ctx: Context) => (name: string, interfaceName: any) => Promise<any>;\nexport interface CtxAct {\n    (actionName: string, context?: any, param?: any, options?: EventOptions): InputData;\n}\nexport declare const _act: (ctx: Context) => CtxAct;\nexport interface CtxVw {\n    (componentName: string): Promise<HandlerMsg>;\n}\nexport declare const _vw: (ctx: Context) => CtxVw;\nexport interface CtxVws {\n    (names: string[]): Promise<HandlerMsg[]>;\n}\nexport declare const _vws: (ctx: Context) => CtxVws;\nexport interface CtxGroup {\n    (groupName: string): Promise<HandlerMsg[]>;\n}\nexport declare const _group: (ctx: Context) => CtxGroup;\nexport interface CtxEv {\n    (inputName: string, context?: any, param?: any, options?: EventOptions): InputData;\n}\nexport declare const _ev: (ctx: Context) => CtxEv;\nexport declare function computeEvent(eventData: any, iData: InputData): EventData;\nexport declare const dispatchEv: (ctx: Context) => (event: any, iData: InputData) => Promise<void>;\nexport declare const toComp: (ctx: Context) => (id: string, inputName: string, data?: any, isPropagated?: boolean) => Promise<void>;\n"},"https://unpkg.com/fractal-core@4.3.8/core/interface.js":{"fullPath":"https://unpkg.com/fractal-core@4.3.8/core/interface.js","contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst module_1 = require(\"./module\");\nconst input_1 = require(\"./input\");\nexports.makeInterfaceHelpers = (ctx) => ({\n    ctx,\n    interfaceOf: exports._interfaceOf(ctx),\n    stateOf: input_1._stateOf(ctx),\n    ev: exports._ev(ctx),\n    act: exports._act(ctx),\n    vw: exports._vw(ctx),\n    vws: exports._vws(ctx),\n    group: exports._group(ctx),\n});\n// gets an interface message from a certain component\nexports._interfaceOf = (ctx) => async (name, interfaceName) => {\n    let id = `${ctx.id}$${name}`;\n    let compCtx = ctx.components[id];\n    if (!compCtx) {\n        ctx.error('interfaceOf', `there are no component space '${id}'`);\n        return {};\n    }\n    if (!compCtx.interfaces[interfaceName]) {\n        ctx.error('interfaceOf', `there are no interface '${interfaceName}' in component '${compCtx.name}' from space '${id}'`);\n        return {};\n    }\n    // search in interface cache\n    let cache = compCtx.interfaceValues[interfaceName];\n    if (cache) {\n        return cache;\n    }\n    else {\n        // caches interface\n        compCtx.interfaceValues[interfaceName] = await compCtx.interfaces[interfaceName](compCtx.state);\n        return compCtx.interfaceValues[interfaceName];\n    }\n};\n// generic action dispatcher\nexports._act = (ctx) => {\n    let _evCtx = exports._ev(ctx);\n    return (actionName, context, param, options) => _evCtx('_action', [actionName, context], param, options);\n};\n// extract component view interface, sintax sugar\nexports._vw = (ctx) => {\n    let _interfaceOfCtx = exports._interfaceOf(ctx);\n    return async (componentName) => await _interfaceOfCtx(componentName, 'view');\n};\n// extract view interfaces based on component names\nexports._vws = (ctx) => {\n    let _interfaceOfCtx = exports._interfaceOf(ctx);\n    return async (names) => {\n        let views = [];\n        for (let i = 0, len = names.length; i < len; i++) {\n            views.push(await _interfaceOfCtx(names[i], 'view'));\n        }\n        return views;\n    };\n};\n// extract view interfaces from a component group\nexports._group = (ctx) => {\n    let _interfaceOfCtx = exports._interfaceOf(ctx);\n    let comps = input_1._componentHelpers(ctx);\n    return async (groupName) => {\n        let views = [];\n        let componentNames = comps(groupName).getCompleteNames();\n        for (let i = 0, len = componentNames.length; i < len; i++) {\n            views.push(await _interfaceOfCtx(componentNames[i], 'view'));\n        }\n        return views;\n    };\n};\n// create an InputData array\nexports._ev = (ctx) => (inputName, context, param, options) => {\n    return [ctx.id, inputName, context, param, options];\n};\nfunction computePath(path, event) {\n    let data;\n    let actual = event;\n    for (let i = 0, len = path.length; i < len; i++) {\n        if (path[i] instanceof Array) {\n            data = {};\n            let keys = path[i];\n            for (let i = 0, len = keys.length; i < len; i++) {\n                data[keys[i]] = actual[keys[i]];\n            }\n        }\n        else {\n            actual = actual[path[i]];\n        }\n    }\n    if (!data) {\n        data = actual;\n    }\n    return data;\n}\nfunction computeEvent(eventData, iData) {\n    let data;\n    let haveContext = iData[2] !== undefined;\n    let haveParam = iData[3] !== undefined;\n    if (iData[3] === '*') {\n        // serialize the whole object (note that DOM events are not serializable, use paths instead)\n        data = JSON.parse(JSON.stringify(eventData));\n    }\n    else if (iData[3] !== undefined) {\n        // have fetch parameter\n        if (iData[3] instanceof Array) {\n            // fetch parameter is a path, e.g. ['target', 'value']\n            let param = iData[3];\n            if (param[1] && param[1] instanceof Array) {\n                data = [];\n                for (let i = 0, len = param.length; i < len; i++) {\n                    data[i] = computePath(param[i], eventData);\n                }\n            }\n            else {\n                // only one path\n                data = computePath(param, eventData);\n            }\n        }\n        else {\n            // fetch parameter is only a getter, e.g. 'target'\n            data = eventData[iData[3]];\n        }\n    }\n    if (!haveContext && !haveParam) {\n        return [iData[0], iData[1]]; // dispatch an input with no arguments\n    }\n    return [\n        iData[0],\n        iData[1],\n        haveContext && haveParam\n            ? [iData[2], data]\n            : haveParam\n                ? data\n                : iData[2]\n    ];\n}\nexports.computeEvent = computeEvent;\nexports.dispatchEv = (ctx) => async (event, iData) => {\n    let compCtx = ctx.components[iData[0] + ''];\n    let cInputData = computeEvent(event, iData);\n    return await module_1.toIt(compCtx)(cInputData[1], cInputData[2]);\n};\nexports.toComp = (ctx) => async (id, inputName, data, isPropagated = true) => {\n    let compCtx = ctx.components[id];\n    return await module_1.toIt(compCtx)(inputName, data, isPropagated);\n};\n//# sourceMappingURL=interface.js.map"},"https://unpkg.com/fractal-core@4.3.8/core/module.d.ts":{"fullPath":"https://unpkg.com/fractal-core@4.3.8/core/module.d.ts","contents":"import { Component, Update, Context, Components, Actions, GenericExecutable, Action, InputData } from './core';\nimport { HandlerInterface, HandlerObject } from './handler';\nexport interface ModuleDef {\n    root: Component<any>;\n    record?: boolean;\n    log?: boolean;\n    render?: boolean;\n    active?: boolean;\n    groups?: HandlerInterfaceIndex;\n    tasks?: HandlerInterfaceIndex;\n    interfaces: HandlerInterfaceIndex;\n    interfaceOrder?: Array<string>;\n    beforeInit?(mod: ModuleAPI): Promise<void>;\n    init?(mod: ModuleAPI): Promise<void>;\n    destroy?(mod: ModuleAPI): Promise<void>;\n    beforeInput?(ctxIn: Context, inputName: string, data: any): void;\n    afterInput?(ctxIn: Context, inputName: string, data: any): void;\n    warn?(source: string, description: string): Promise<void>;\n    error?(source: string, description: string): Promise<void>;\n}\nexport declare const _: any;\nexport interface HandlerInterfaceIndex {\n    [name: string]: HandlerInterface;\n}\nexport interface HandlerObjectIndex {\n    [name: string]: HandlerObject;\n}\nexport interface Module {\n    moduleDef: ModuleDef;\n    isDisposed: boolean;\n    moduleAPI: ModuleAPI;\n    rootCtx: Context;\n}\nexport interface ModuleAPI {\n    dispatchEv(event: any, iData: InputData): Promise<void>;\n    toComp(id: string, inputName: string, data?: any, isPropagated?: boolean): Promise<void>;\n    dispose(): void;\n    attach(comp: Component<any>, app?: Module, middleFn?: MiddleFn): Promise<Module>;\n    nest: CtxNest;\n    unnest: CtxUnnest;\n    nestAll: CtxNestAll;\n    unnestAll: CtxUnnestAll;\n    setGroup(id: string, name: string, space: any): void;\n    warn(source: any, description: any): void;\n    error(source: any, description: any): void;\n}\nexport interface MiddleFn {\n    (ctx: Context, app: Module): void;\n}\nexport declare const handlerTypes: string[];\nexport interface CtxNest {\n    (name: string, component: Component<any>, isStatic?: boolean): void;\n}\nexport declare const nest: (ctx: Context) => CtxNest;\nexport interface CtxNestAll {\n    (components: Components, isStatic?: boolean): Promise<void>;\n}\nexport declare const nestAll: (ctx: Context) => CtxNestAll;\nexport interface CtxUnnest {\n    (name?: string): Promise<void>;\n}\nexport declare const unnest: (ctx: Context) => CtxUnnest;\nexport interface CtxUnnestAll {\n    (components: string[]): Promise<void>;\n}\nexport declare const unnestAll: (ctx: Context) => CtxUnnestAll;\nexport declare function propagate(ctx: Context, inputName: string, data: any): Promise<void>;\nexport interface CtxToIt {\n    (inputName: string, data?: any, isPropagated?: boolean): Promise<void>;\n}\nexport declare const toIt: (ctx: Context) => CtxToIt;\nexport declare function execute(ctx: Context, executable: GenericExecutable<any>): Promise<any>;\nexport declare function performUpdate(compCtx: Context, update: Update<any>): Promise<any>;\nexport declare function calcAndNotifyInterfaces(ctx: Context): void;\nexport declare function run(moduleDef: ModuleDef): Promise<Module>;\nexport declare const action: (ctx: Context, actions: Actions<any>) => ([arg1, arg2]: any) => Promise<any>;\nexport declare const executeInput: (ctx: Context) => (executable: GenericExecutable<any>) => Promise<any>;\nexport declare const SetAction: Action<any>;\nexport declare const AddComp: (compFn: any) => Action<any>;\nexport declare const _removeAction: Action<any>;\nexport declare function clone(o: any): any;\n"},"https://unpkg.com/fractal-core@4.3.8/core/module.js":{"fullPath":"https://unpkg.com/fractal-core@4.3.8/core/module.js","contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nrequire('setimmediate'); // Polyfill setImmediate\nconst interface_1 = require(\"./interface\");\nconst input_1 = require(\"./input\");\n// a gap is defined with undefined (optional)\nexports._ = undefined;\nexports.handlerTypes = ['interface', 'task', 'group'];\n// Evaluate DEPRECATION\n// add a component to the component index\nexports.nest = (ctx) => async (name, component) => {\n    await _nest(ctx, name, component);\n};\nasync function _nest(ctx, name, component) {\n    // namespaced name if is a child\n    let id = ctx.id === 'Root' && name === 'Root' ? 'Root' : ctx.id + '$' + name;\n    // state default\n    component.state._nest = component.state._nest || {};\n    component.state._compCounter = 0;\n    let childCtx = {\n        id,\n        name,\n        groups: {},\n        // delegation\n        global: ctx.global,\n        components: ctx.components,\n        groupHandlers: ctx.groupHandlers,\n        interfaceHandlers: ctx.interfaceHandlers,\n        taskHandlers: ctx.taskHandlers,\n        beforeInput: ctx.beforeInput,\n        afterInput: ctx.afterInput,\n        warn: ctx.warn,\n        error: ctx.error,\n        // if state is an object, it is cloned\n        state: clone(component.state),\n        inputs: {},\n        actions: component.actions,\n        interfaces: {},\n        interfaceValues: {},\n    };\n    ctx.components[id] = childCtx;\n    childCtx.interfaces = _makeInterfaces(childCtx, component.interfaces);\n    if (component.inputs) {\n        childCtx.inputs = component.inputs(input_1.makeInputHelpers(childCtx));\n    }\n    else {\n        childCtx.inputs = {};\n    }\n    if (component.actions) {\n        if (!childCtx.inputs._action) {\n            // action helper enabled by default\n            childCtx.inputs._action = exports.action(childCtx, component.actions);\n        }\n        if (!childCtx.inputs._execute) {\n            // action helper enabled by default\n            childCtx.inputs._execute = exports.executeInput(childCtx);\n        }\n        if (!childCtx.actions.Set) {\n            childCtx.actions.Set = exports.SetAction;\n        }\n        if (!childCtx.actions._remove) {\n            childCtx.actions._remove = exports._removeAction;\n        }\n    }\n    // composition\n    if (Object.keys(childCtx.state._nest).length > 0) {\n        let components = childCtx.state._nest;\n        for (name in components) {\n            await _nest(childCtx, name, components[name]);\n        }\n    }\n    childCtx.state._compNames = Object.keys(childCtx.state._nest);\n    if (component.groups) {\n        // Groups are handled automatically only when comoponent are initialized\n        await handleGroups(childCtx, component);\n    }\n    if (childCtx.inputs.init && !childCtx.global.hotSwap) {\n        await childCtx.inputs.init();\n    }\n    return childCtx;\n}\nfunction _makeInterfaces(ctx, interfaces) {\n    let index = {};\n    let name;\n    for (name in interfaces) {\n        index[name] = interfaces[name](interface_1.makeInterfaceHelpers(ctx));\n    }\n    return index;\n}\nasync function handleGroups(ctx, component) {\n    let space;\n    let name;\n    for (name in component.groups) {\n        space = ctx.groupHandlers[name];\n        if (space) {\n            await space.handle([ctx.id, component.groups[name]]);\n        }\n        else {\n            ctx.error('nest', `module has no group handler for '${name}' of component '${ctx.name}' from space '${ctx.id}'`);\n        }\n    }\n}\n// add many components to the component index\nexports.nestAll = (ctx) => async (components, isStatic = false) => {\n    let name;\n    for (name in components) {\n        await _nest(ctx, name, components[name]);\n    }\n};\n// remove a component to the component index, if name is not defined dispose the root\nexports.unnest = (ctx) => async (name) => {\n    let id = name !== undefined ? ctx.id + '$' + name : ctx.id;\n    let componentSpace = ctx.components[id];\n    if (!componentSpace) {\n        return ctx.error('unnest', `there is no component with name '${name}' at component '${ctx.id}'`);\n    }\n    // decomposition\n    let components = componentSpace.components;\n    /* istanbul ignore else */\n    if (components) {\n        await exports.unnestAll(componentSpace)(Object.keys(componentSpace.state._nest));\n    }\n    if (ctx.inputs.destroy && !ctx.global.hotSwap) {\n        await ctx.inputs.destroy();\n    }\n    delete ctx.components[id];\n};\n// add many components to the component index\nexports.unnestAll = (ctx) => async (components) => {\n    let _unnest = exports.unnest(ctx);\n    for (let i = 0, len = components.length; i < len; i++) {\n        await _unnest(components[i]);\n    }\n};\nasync function propagate(ctx, inputName, data) {\n    // notifies parent if name starts with $\n    let id = ctx.id;\n    let idParts = (id + '').split('$');\n    let componentSpace = ctx.components[id];\n    if (idParts.length > 1) {\n        // is not root?\n        let parentId = idParts.slice(0, -1).join('$');\n        let parentSpace = ctx.components[parentId];\n        let parentInputName;\n        parentInputName = `$${componentSpace.name.split('_')[0]}_${inputName}`;\n        if (parentSpace.inputs[parentInputName]) {\n            let name = componentSpace.name.split('_')[1];\n            await exports.toIt(parentSpace)(parentInputName, name ? [name, data] : data);\n        }\n        parentInputName = `$_${inputName}`;\n        if (parentSpace.inputs[parentInputName]) {\n            await exports.toIt(parentSpace)(parentInputName, [componentSpace.name, data]);\n        }\n    }\n}\nexports.propagate = propagate;\n// send a message to an input of a component from itself\nexports.toIt = (ctx) => {\n    let id = ctx.id;\n    let componentSpace = ctx.components[id];\n    return async (inputName, data, isPropagated = true) => {\n        if (!ctx.global.active) {\n            return;\n        }\n        let input = componentSpace.inputs[inputName];\n        if (input === undefined) {\n            ctx.error('execute', `there are no input named '${inputName}' in component '${componentSpace.name}' from space '${id}'`);\n            return;\n        }\n        if (ctx.beforeInput)\n            ctx.beforeInput(ctx, inputName, data);\n        let result = await input(data);\n        if (ctx.afterInput)\n            ctx.afterInput(ctx, inputName, data);\n        if (isPropagated) {\n            await propagate(ctx, inputName, data);\n        }\n        return result;\n    };\n};\n// execute an executable in a context, executable parameter should not be undefined\nasync function execute(ctx, executable) {\n    let id = ctx.id;\n    let compCtx = ctx.components[id];\n    if (typeof executable === 'function') {\n        return await performUpdate(compCtx, executable);\n    }\n    else {\n        /* istanbul ignore else */\n        if (executable instanceof Array) {\n            if (executable[0] && typeof executable[0] === 'string') {\n                // single task\n                if (!ctx.taskHandlers[executable[0]]) {\n                    return ctx.error('execute', `there are no task handler for '${executable[0]}' in component '${compCtx.name}' from space '${id}'`);\n                }\n                return await ctx.taskHandlers[executable[0]].handle(executable[1]);\n            }\n            else {\n                /* istanbul ignore else */\n                if (executable[0] instanceof Array || typeof executable[0] === 'function') {\n                    // list of updates and tasks\n                    let results = [];\n                    for (let i = 0, len = executable.length; i < len; i++) {\n                        if (typeof executable[i] === 'function') {\n                            results.push(await performUpdate(compCtx, executable[i]));\n                        }\n                        else {\n                            /* istanbul ignore else */\n                            if (executable[i] instanceof Array && typeof executable[i][0] === 'string') {\n                                // single task\n                                if (!ctx.taskHandlers[executable[i][0]]) {\n                                    return ctx.error('execute', `there are no task handler for '${executable[i][0]}' in component '${compCtx.name}' from space '${id}'`);\n                                }\n                                results.push(await ctx.taskHandlers[executable[i][0]].handle(executable[i][1]));\n                            }\n                        }\n                        // the else branch never occurs because of Typecript check\n                    }\n                    return results;\n                }\n            }\n        }\n        // the else branch never occurs because of Typecript check\n    }\n}\nexports.execute = execute;\nasync function performUpdate(compCtx, update) {\n    let updateRes = update(compCtx.state);\n    if (updateRes instanceof Promise) {\n        compCtx.state = await updateRes;\n    }\n    else {\n        compCtx.state = updateRes;\n    }\n    if (compCtx.state._compUpdated) {\n        compCtx.global.render = false;\n        let compNames = compCtx.state._compNames;\n        let newCompNames = Object.keys(compCtx.state._nest);\n        let newNames = newCompNames.filter(n => compNames.indexOf(n) < 0);\n        let removeNames = compNames.filter(n => newCompNames.indexOf(n) < 0);\n        for (let i = 0, len = newNames.length; i < len; i++) {\n            await _nest(compCtx, newNames[i], compCtx.state._nest[newNames[i]]);\n        }\n        for (let i = 0, len = removeNames.length; i < len; i++) {\n            await exports.unnest(compCtx)(removeNames[i]);\n        }\n        compCtx.state._compUpdated = false;\n        compCtx.state._compNames = newCompNames;\n        compCtx.global.render = true;\n    }\n    if (compCtx.global.moduleRender && compCtx.global.render) {\n        calcAndNotifyInterfaces(compCtx); // root context\n    }\n    else {\n        compCtx.interfaceValues = {};\n    }\n    return compCtx.state;\n}\nexports.performUpdate = performUpdate;\nfunction calcAndNotifyInterfaces(ctx) {\n    // calc and caches interfaces\n    let space = ctx.components[ctx.id];\n    let idParts = (ctx.id + '').split('$');\n    for (let name in space.interfaces) {\n        setImmediate(async () => {\n            // remove cache of parent component spaces\n            let parts = idParts.slice(0);\n            for (let i = parts.length - 1; i >= 0; i--) {\n                ctx.components[parts.join('$')].interfaceValues[name] = undefined;\n                parts.pop();\n            }\n            // permorms interface recalculation\n            let rootSpace = ctx.components.Root;\n            for (let name in rootSpace.interfaces) {\n                if (ctx.interfaceHandlers[name]) {\n                    ctx.interfaceHandlers[name].handle(await rootSpace.interfaces[name](rootSpace.state));\n                }\n                else {\n                    // This only can happen when this method is called for a context that is not the root\n                    ctx.error('notifyInterfaceHandlers', `module does not have interface handler named '${name}' for component '${space.name}' from space '${ctx.id}'`);\n                }\n            }\n        });\n    }\n}\nexports.calcAndNotifyInterfaces = calcAndNotifyInterfaces;\n// function for running a root component\nasync function run(moduleDef) {\n    // internal module state\n    // root component\n    let component;\n    let moduleAPI;\n    // root context\n    let ctx;\n    // attach root component\n    async function attach(comp, app, middleFn) {\n        // root component, take account of hot swapping\n        component = comp ? comp : moduleDef.root;\n        // if is hot swapping, do not recalculate context\n        // bootstrap context (level 0)\n        if (!middleFn) {\n            ctx = {\n                id: 'Root',\n                name: 'Root',\n                groups: {},\n                global: {\n                    record: moduleDef.hasOwnProperty('record') ? moduleDef.record : false,\n                    records: [],\n                    log: moduleDef.hasOwnProperty('log') ? moduleDef.log : false,\n                    moduleRender: moduleDef.hasOwnProperty('render') ? moduleDef.render : true,\n                    render: true,\n                    active: moduleDef.hasOwnProperty('active') ? moduleDef.active : true,\n                },\n                // component index\n                components: {},\n                groupHandlers: {},\n                taskHandlers: {},\n                interfaces: {},\n                interfaceHandlers: {},\n                inputs: {},\n                // error and warning handling\n                beforeInput: moduleDef.beforeInput ? moduleDef.beforeInput : exports._,\n                afterInput: moduleDef.afterInput || exports._,\n                warn: moduleDef.warn || exports._,\n                error: moduleDef.error || exports._,\n            };\n            // API for modules\n            moduleAPI = {\n                // dispatch function type used for handlers\n                dispatchEv: interface_1.dispatchEv(ctx),\n                toComp: interface_1.toComp(ctx),\n                dispose,\n                // merge a component to the component index\n                nest: exports.nest(ctx),\n                // merge many components to the component index\n                nestAll: exports.nestAll(ctx),\n                // unnest a component to the component index\n                unnest: exports.unnest(ctx),\n                // unnest many components to the component index\n                unnestAll: exports.unnestAll(ctx),\n                // set a space of a certain component\n                setGroup: (id, name, space) => {\n                    ctx.components[id].groups[name] = space;\n                },\n                attach,\n                // delegated methods\n                warn: ctx.warn,\n                error: ctx.error,\n            };\n            // module lifecycle hook: init\n            if (moduleDef.beforeInit && !middleFn) {\n                await moduleDef.beforeInit(moduleAPI);\n            }\n        }\n        // if is not hot swapping\n        if (!middleFn) {\n            // pass ModuleAPI to every Interface, Task and Space HandlerFunction\n            let handlers;\n            for (let c = 0, len = exports.handlerTypes.length; c < len; c++) {\n                handlers = moduleDef[exports.handlerTypes[c] + 's'];\n                if (handlers) {\n                    let name;\n                    for (name in handlers) {\n                        ctx[exports.handlerTypes[c] + 'Handlers'][name] = await handlers[name](moduleAPI);\n                    }\n                }\n            }\n        }\n        if (middleFn) {\n            ctx.global.hotSwap = true;\n        }\n        let lastModuleRender = ctx.global.moduleRender;\n        ctx.global.moduleRender = false;\n        // Root component\n        let root = await _nest(ctx, 'Root', component);\n        ctx.global.moduleRender = lastModuleRender;\n        // Root context (level 1)\n        ctx.global.rootCtx = root;\n        // middle function for hot-swapping\n        if (middleFn) {\n            await middleFn(ctx.global.rootCtx, app);\n        }\n        // pass initial value to each Interface Handler\n        // -- interfaceOrder\n        let interfaceOrder = moduleDef.interfaceOrder;\n        let name;\n        let errorNotHandler = name => ctx.error('InterfaceHandlers', `'$.Root' component has no interface called '${name}', missing interface handler`);\n        let rootCtx = ctx.global.rootCtx;\n        if (interfaceOrder) {\n            for (let i = 0; name = interfaceOrder[i]; i++) {\n                if (ctx.interfaceHandlers[name]) {\n                    ctx.interfaceHandlers[name].handle(await rootCtx.interfaces[name](ctx.components.Root.state));\n                }\n                else {\n                    return errorNotHandler(name);\n                }\n            }\n        }\n        for (name in rootCtx.interfaces) {\n            if (interfaceOrder && interfaceOrder.indexOf(name) !== -1) {\n                continue; // interface evaluated yet\n            }\n            if (ctx.interfaceHandlers[name]) {\n                ctx.interfaceHandlers[name].handle(await rootCtx.interfaces[name](ctx.components.Root.state));\n            }\n            else {\n                return errorNotHandler(name);\n            }\n        }\n        // module lifecycle hook: init\n        if (moduleDef.init && !middleFn) {\n            await moduleDef.init(moduleAPI);\n        }\n        return {\n            moduleDef,\n            // reattach root component, used for hot swapping\n            isDisposed: false,\n            // root context\n            moduleAPI,\n            rootCtx: ctx.global.rootCtx,\n        };\n    }\n    function dispose() {\n        if (moduleDef.destroy) {\n            moduleDef.destroy(moduleAPI);\n        }\n        // dispose all handlers\n        let handlers;\n        for (let c = 0, len = exports.handlerTypes.length; c < len; c++) {\n            handlers = ctx[`${exports.handlerTypes[c]}Handlers`];\n            let name;\n            for (name in handlers) {\n                handlers[name].dispose();\n            }\n        }\n        exports.unnest(ctx)();\n        ctx = undefined;\n        this.isDisposed = true;\n    }\n    return await attach(undefined);\n}\nexports.run = run;\n// generic action input\nexports.action = (ctx, actions) => async ([arg1, arg2]) => {\n    let name;\n    let value;\n    if (arg1 instanceof Array) {\n        name = arg1[0];\n        value = arg1[1];\n        if (arg2 !== undefined) {\n            // add fetch value\n            // TODO: test it!!\n            value = (value !== undefined) ? [value, arg2] : arg2;\n        }\n    }\n    else {\n        name = arg1;\n        value = arg2;\n    }\n    if (ctx.global.record) {\n        ctx.global.records.push({ id: ctx.id, actionName: name, value });\n        window.lastCtxAct = ctx;\n    }\n    let result = await execute(ctx, actions[name](value));\n    return result;\n};\n// generic execute input\nexports.executeInput = (ctx) => async (executable) => {\n    return await execute(ctx, executable);\n};\n// generic execute input\nexports.SetAction = (args) => s => {\n    if (args[0] instanceof Array) {\n        // Multiple assignments\n        for (let i = 0, arg; arg = args[i]; i++) {\n            s[arg[0]] = arg[1];\n        }\n    }\n    else {\n        // Single assignment\n        s[args[0]] = args[1];\n    }\n    return s;\n};\nexports.AddComp = (compFn) => (compArgs) => s => {\n    let [name, component] = compFn(s._compCounter, compArgs);\n    s._nest[name] = component;\n    s._compCounter++;\n    s._compUpdated = true;\n    return s;\n};\nexports._removeAction = (name) => s => {\n    delete s._nest[name];\n    s._compUpdated = true;\n    return s;\n};\nfunction clone(o) {\n    var out, v, key;\n    out = Array.isArray(o) ? [] : {};\n    for (key in o) {\n        v = o[key];\n        out[key] = (typeof v === 'object') ? clone(v) : v;\n    }\n    return out;\n}\nexports.clone = clone;\n//# sourceMappingURL=module.js.map"},"https://unpkg.com/fractal-core@4.3.8/interfaces/view/eventListeners.js":{"fullPath":"https://unpkg.com/fractal-core@4.3.8/interfaces/view/eventListeners.js","contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* istanbul ignore next */\nexports.eventListenersModule = (mod) => {\n    function invokeHandler(handler, event) {\n        if (handler instanceof Array && typeof handler[0] === 'string') {\n            let options = handler[4];\n            if ((options && options.listenPrevented !== true || !options) && event.defaultPrevented) {\n                return;\n            }\n            if (options && options.default === false) {\n                event.preventDefault();\n            }\n            setImmediate(() => {\n                mod.dispatchEv(event, handler);\n            });\n        }\n        else if (handler instanceof Array) {\n            // call multiple handlers\n            for (var i = 0; i < handler.length; i++) {\n                invokeHandler(handler[i], event);\n            }\n        }\n        else if (handler === 'ignore') {\n            // this handler is ignored\n            event.preventDefault();\n        }\n        else if (handler === '' && handler === undefined) {\n            // this handler is passed\n            return;\n        }\n        else {\n            mod.error('ViewInterface-eventListenersModule', 'event handler of type ' + typeof handler + 'are not allowed, data: ' + JSON.stringify(handler));\n        }\n    }\n    function handleEvent(event, vnode) {\n        var name = event.type, on = vnode.data.on;\n        // call event handler(s) if exists\n        if (on && on[name]) {\n            invokeHandler(on[name], event);\n        }\n    }\n    function createListener() {\n        return function handler(event) {\n            handleEvent(event, handler.vnode);\n        };\n    }\n    function updateEventListeners(oldVnode, vnode) {\n        var oldOn = oldVnode.data.on, oldListener = oldVnode.listener, oldElm = oldVnode.elm, on = vnode && vnode.data.on, elm = (vnode && vnode.elm), name;\n        // optimization for reused immutable handlers\n        if (oldOn === on) {\n            return;\n        }\n        // remove existing listeners which no longer used\n        if (oldOn && oldListener) {\n            // if element changed or deleted we remove all existing listeners unconditionally\n            if (!on) {\n                for (name in oldOn) {\n                    // remove listener if element was changed or existing listeners removed\n                    oldElm.removeEventListener(name, oldListener, false);\n                }\n            }\n            else {\n                for (name in oldOn) {\n                    // remove listener if existing listener removed\n                    if (!on[name]) {\n                        oldElm.removeEventListener(name, oldListener, false);\n                    }\n                }\n            }\n        }\n        // add new listeners which has not already attached\n        if (on) {\n            // reuse existing listener or create new\n            var listener = vnode.listener = oldVnode.listener || createListener();\n            // update vnode for listener\n            listener.vnode = vnode;\n            // if element changed or added we add all needed listeners unconditionally\n            if (!oldOn) {\n                for (name in on) {\n                    // add listener if element was changed or new listeners added\n                    elm.addEventListener(name, listener, false);\n                }\n            }\n            else {\n                for (name in on) {\n                    // add listener if new listener added\n                    if (!oldOn[name]) {\n                        elm.addEventListener(name, listener, false);\n                    }\n                }\n            }\n        }\n    }\n    return {\n        create: updateEventListeners,\n        update: updateEventListeners,\n        destroy: updateEventListeners,\n    };\n};\nexports.default = exports.eventListenersModule;\n//# sourceMappingURL=eventListeners.js.map"},"https://unpkg.com/fractal-core@4.3.8/interfaces/view/globalListeners.js":{"fullPath":"https://unpkg.com/fractal-core@4.3.8/interfaces/view/globalListeners.js","contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"./utils\");\n/* istanbul ignore next */\nfunction getContainer(lastContainer) {\n    let elm = lastContainer.elm ? lastContainer.elm : lastContainer;\n    return elm;\n}\n/* istanbul ignore next */\nexports.globalListenersModule = (mod, state) => {\n    function invokeHandler(handler, event, vnode) {\n        if (handler instanceof Array && typeof handler[0] === 'string') {\n            let options = handler[4];\n            if ((options && options.listenPrevented !== true || !options) && event.defaultPrevented\n                || (options && options.selfPropagated !== true || !options)\n                    && (utils_1.isDescendant(vnode.elm, event.srcElement) || vnode.elm === event.srcElement)) {\n                return;\n            }\n            if (options && options.default === false) {\n                event.preventDefault();\n            }\n            // call function handler\n            setImmediate(() => {\n                mod.dispatchEv(event, handler);\n            });\n        }\n        else if (handler instanceof Array) {\n            // call multiple handlers\n            for (var i = 0; i < handler.length; i++) {\n                invokeHandler(handler[i], event, vnode);\n            }\n        }\n        else if (handler === 'ignore') {\n            // this handler is ignored\n            event.preventDefault();\n        }\n        else if (handler === '' && handler === undefined) {\n            // this handler is passed\n            return;\n        }\n        else {\n            mod.error('ViewInterface-globalListenersModule', 'event handler of type ' + typeof handler + 'are not allowed, data: ' + JSON.stringify(handler));\n        }\n    }\n    function handleEvent(event, vnode) {\n        var name = event.type, global = vnode.data.global;\n        // call event handler(s) if exists\n        if (global && global[name]) {\n            invokeHandler(global[name], event, vnode);\n        }\n    }\n    function createListener() {\n        return function handler(event) {\n            handleEvent(event, handler.vnode);\n        };\n    }\n    function updateEventListeners(oldVnode, vnode) {\n        var oldGlobal = oldVnode.data.global, oldListener = oldVnode.globalListener, global = vnode && vnode.data.global, name;\n        // optimization for reused immutable handlers\n        if (oldGlobal === global) {\n            return;\n        }\n        // remove existing listeners which no longer used\n        if (oldGlobal && oldListener) {\n            // if element changed or deleted we remove all existing listeners unconditionally\n            if (!global) {\n                for (name in oldGlobal) {\n                    // remove listener if element was changed or existing listeners removed\n                    let elm = getContainer(state.lastContainer);\n                    elm.removeEventListener(name, oldListener, false);\n                }\n            }\n            else {\n                for (name in oldGlobal) {\n                    // remove listener if existing listener removed\n                    if (!global[name]) {\n                        let elm = getContainer(state.lastContainer);\n                        elm.removeEventListener(name, oldListener, false);\n                    }\n                }\n            }\n        }\n        // add new listeners which has not already attached\n        if (global) {\n            // reuse existing listener or create new\n            var globalListener = vnode.globalListener = oldVnode.globalListener || createListener();\n            // update vnode for listener\n            globalListener.vnode = vnode;\n            // if element changed or added we add all needed listeners unconditionally\n            if (!oldGlobal) {\n                for (name in global) {\n                    // add listener if element was changed or new listeners added\n                    let elm = getContainer(state.lastContainer);\n                    elm.addEventListener(name, globalListener, false);\n                }\n            }\n            else {\n                for (name in global) {\n                    // add listener if new listener added\n                    if (!oldGlobal[name]) {\n                        let elm = getContainer(state.lastContainer);\n                        elm.addEventListener(name, globalListener, false);\n                    }\n                }\n            }\n        }\n    }\n    return {\n        create: updateEventListeners,\n        update: updateEventListeners,\n        destroy: updateEventListeners,\n    };\n};\nexports.default = exports.globalListenersModule;\n//# sourceMappingURL=globalListeners.js.map"},"https://unpkg.com/fractal-core@4.3.8/interfaces/view/h.js":{"fullPath":"https://unpkg.com/fractal-core@4.3.8/interfaces/view/h.js","contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Copied from snabbdom\n// Commit: https://github.com/snabbdom/snabbdom/commit/c5d513dfd90fca1188e63cf8abac5cc3eb06bdcf\nconst vnode_1 = require(\"./vnode\");\nconst is = require(\"./is\");\n/* istanbul ignore next */\nfunction addNS(data, children, sel) {\n    data.ns = 'http://www.w3.org/2000/svg';\n    if (sel !== 'foreignObject' && children !== undefined) {\n        for (let i = 0; i < children.length; ++i) {\n            let childData = children[i].data;\n            if (childData !== undefined) {\n                addNS(childData, children[i].children, children[i].sel);\n            }\n        }\n    }\n}\n/* istanbul ignore next */\nfunction h(sel, b, c) {\n    var data = {}, children, text, i;\n    if (c !== undefined) {\n        data = b;\n        if (is.array(c)) {\n            children = c;\n        }\n        else if (is.primitive(c)) {\n            text = c;\n        }\n        else if (c && c.sel) {\n            children = [c];\n        }\n    }\n    else if (b !== undefined) {\n        if (is.array(b)) {\n            children = b;\n        }\n        else if (is.primitive(b)) {\n            text = b;\n        }\n        else if (b && b.sel) {\n            children = [b];\n        }\n        else {\n            data = b;\n        }\n    }\n    if (is.array(children)) {\n        for (i = 0; i < children.length; ++i) {\n            if (is.primitive(children[i]))\n                children[i] = vnode_1.vnode(undefined, undefined, undefined, children[i]);\n        }\n    }\n    if (sel[0] === 's' && sel[1] === 'v' && sel[2] === 'g' &&\n        (sel.length === 3 || sel[3] === '.' || sel[3] === '#')) {\n        addNS(data, children, sel);\n    }\n    return vnode_1.vnode(sel, data, children, text, undefined);\n}\nexports.h = h;\nexports.default = h;\n//# sourceMappingURL=h.js.map"},"https://unpkg.com/fractal-core@4.3.8/interfaces/view/index.js":{"fullPath":"https://unpkg.com/fractal-core@4.3.8/interfaces/view/index.js","contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst snabbdom_1 = require(\"snabbdom\");\nconst class_1 = require(\"snabbdom/modules/class\");\nconst attributes_1 = require(\"snabbdom/modules/attributes\");\nconst props_1 = require(\"snabbdom/modules/props\");\nconst style_1 = require(\"snabbdom/modules/style\");\nconst eventListeners_1 = require(\"./eventListeners\");\nconst globalListeners_1 = require(\"./globalListeners\");\nconst sizeBinding_1 = require(\"./sizeBinding\");\nconst h_1 = require(\"./h\");\nexports.h = h_1.default;\n/* istanbul ignore next */\nexports.viewHandler = (selectorElm, cb) => (mod) => {\n    let selector = (typeof selectorElm === 'string') ? selectorElm : '';\n    let state = {\n        lastContainer: undefined,\n    };\n    // Common snabbdom patch function (convention over configuration)\n    let patchFn = snabbdom_1.init([\n        class_1.default,\n        attributes_1.default,\n        props_1.default,\n        style_1.default,\n        eventListeners_1.default(mod),\n        globalListeners_1.default(mod, state),\n        sizeBinding_1.default(mod),\n    ]);\n    function handler(vnode) {\n        let vnode_mapped = exports.h('div' + selector, { key: selector }, [vnode]);\n        state.lastContainer = patchFn(state.lastContainer, vnode_mapped);\n    }\n    return {\n        state,\n        handle: async (value) => {\n            if (typeof window === 'undefined') {\n                if (cb) {\n                    cb(value);\n                }\n                return;\n            }\n            if (!state.lastContainer) {\n                let container = selector !== '' ? document.querySelector(selector) : selectorElm;\n                if (!container) {\n                    return mod.error('view', `There are no element matching selector '${selector}'`);\n                }\n                state.lastContainer = container;\n                handler(state.lastContainer);\n                handler(value);\n            }\n            else {\n                handler(value);\n            }\n            if (cb) {\n                cb(value);\n            }\n        },\n        dispose: () => { },\n    };\n};\n//# sourceMappingURL=index.js.map"},"https://unpkg.com/fractal-core@4.3.8/interfaces/view/is.js":{"fullPath":"https://unpkg.com/fractal-core@4.3.8/interfaces/view/is.js","contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Copied from snabbdom\n// Commit: https://github.com/snabbdom/snabbdom/commit/f552b0e8eda30a84e59f212e98651463ec71a53f\nexports.array = Array.isArray;\n/* istanbul ignore next */\nfunction primitive(s) {\n    return typeof s === 'string' || typeof s === 'number';\n}\nexports.primitive = primitive;\n//# sourceMappingURL=is.js.map"},"https://unpkg.com/fractal-core@4.3.8/interfaces/view/resizeSensor.js":{"fullPath":"https://unpkg.com/fractal-core@4.3.8/interfaces/view/resizeSensor.js","contents":"\"use strict\";\n/**\n * Taken and adapted from:\n * https://github.com/marcj/css-element-queries/blob/master/src/ResizeSensor.js\n * Copyright Marc J. Schmidt. See the LICENSE (MIT)\n * directory of this distribution and at\n * https://github.com/marcj/css-element-queries/blob/master/LICENSE.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* istanbul ignore next */\nclass EventQueue {\n    constructor() {\n        this.q = [];\n    }\n    add(ev) {\n        this.q.push(ev);\n    }\n    call() {\n        var i, j;\n        for (i = 0, j = this.q.length; i < j; i++) {\n            this.q[i].call(this);\n        }\n    }\n    remove(ev) {\n        var newQueue = [], i, j;\n        for (i = 0, j = this.q.length; i < j; i++) {\n            if (this.q[i] !== ev)\n                newQueue.push(this.q[i]);\n        }\n        this.q = newQueue;\n    }\n    length() {\n        return this.q.length;\n    }\n}\nexports.EventQueue = EventQueue;\n/**\n * Class for dimension change detection.\n */\n/* istanbul ignore next */\nclass ResizeSensor {\n    constructor(element, callback) {\n        this.element = element;\n        this.callback = callback;\n        this.attachResizeEvent(element, callback);\n    }\n    attachResizeEvent(element, resized) {\n        if (element.resizedAttached) {\n            element.resizedAttached.add(resized);\n            return;\n        }\n        element.resizedAttached = new EventQueue();\n        element.resizedAttached.add(resized);\n        element.resizeSensor = document.createElement('div');\n        element.resizeSensor.className = 'resize-sensor';\n        var style = 'position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;';\n        var styleChild = 'position: absolute; left: 0; top: 0; transition: 0s;';\n        element.resizeSensor.style.cssText = style;\n        element.resizeSensor.innerHTML =\n            '<div class=\"resize-sensor-expand\" style=\"' + style + '\">' +\n                '<div style=\"' + styleChild + '\"></div>' +\n                '</div>' +\n                '<div class=\"resize-sensor-shrink\" style=\"' + style + '\">' +\n                '<div style=\"' + styleChild + ' width: 200%; height: 200%\"></div>' +\n                '</div>';\n        element.appendChild(element.resizeSensor);\n        if (element.resizeSensor.offsetParent !== element) {\n            element.style.position = 'relative';\n        }\n        var expand = element.resizeSensor.childNodes[0];\n        var expandChild = expand.childNodes[0];\n        var shrink = element.resizeSensor.childNodes[1];\n        var dirty, rafId, newWidth, newHeight;\n        var lastWidth = element.offsetWidth;\n        var lastHeight = element.offsetHeight;\n        var reset = function () {\n            expandChild.style.width = '100000px';\n            expandChild.style.height = '100000px';\n            expand.scrollLeft = 100000;\n            expand.scrollTop = 100000;\n            shrink.scrollLeft = 100000;\n            shrink.scrollTop = 100000;\n        };\n        // setTimeout waits until rendering is done\n        setTimeout(() => reset(), 0);\n        var onResized = function () {\n            rafId = 0;\n            if (!dirty)\n                return;\n            lastWidth = newWidth;\n            lastHeight = newHeight;\n            if (element.resizedAttached) {\n                element.resizedAttached.call();\n            }\n        };\n        var onScroll = function () {\n            newWidth = element.offsetWidth;\n            newHeight = element.offsetHeight;\n            dirty = newWidth != lastWidth || newHeight != lastHeight;\n            if (dirty && !rafId) {\n                rafId = requestAnimationFrame(onResized);\n            }\n            reset();\n        };\n        var addEvent = function (el, name, cb) {\n            if (el.attachEvent) {\n                el.attachEvent('on' + name, cb);\n            }\n            else {\n                el.addEventListener(name, cb);\n            }\n        };\n        addEvent(expand, 'scroll', onScroll);\n        addEvent(shrink, 'scroll', onScroll);\n    }\n    detach(ev) {\n        let elem = this.element;\n        if (elem.resizedAttached && typeof ev == 'function') {\n            elem.resizedAttached.remove(ev);\n            if (elem.resizedAttached.length())\n                return;\n        }\n        if (elem.resizeSensor) {\n            if (elem.contains(elem.resizeSensor)) {\n                elem.removeChild(elem.resizeSensor);\n            }\n            delete elem.resizeSensor;\n            delete elem.resizedAttached;\n        }\n    }\n}\nexports.ResizeSensor = ResizeSensor;\n//# sourceMappingURL=resizeSensor.js.map"},"https://unpkg.com/fractal-core@4.3.8/interfaces/view/sizeBinding.js":{"fullPath":"https://unpkg.com/fractal-core@4.3.8/interfaces/view/sizeBinding.js","contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst resizeSensor_1 = require(\"./resizeSensor\");\n// TODO: CRITICAL, improve performance or deprecate this way in favor of task size evaluator\n/* istanbul ignore next */\nexports.sizeBindingModule = (mod) => {\n    function invokeHandler(evHandler, vnode, eventData) {\n        if (evHandler instanceof Array && typeof evHandler[0] === 'string') {\n            setTimeout(() => {\n                mod.dispatchEv(eventData, evHandler);\n            }, 0);\n        }\n        else if (evHandler instanceof Array) {\n            // call multiple handlers\n            for (var i = 0; i < evHandler.length; i++) {\n                invokeHandler(evHandler[i], vnode, eventData);\n            }\n        }\n        else if (evHandler === 'ignore') {\n            // this handler is ignored\n            return;\n        }\n        else if (evHandler === '' && evHandler === undefined) {\n            // this handler is passed\n            return;\n        }\n        else {\n            mod.error('ViewInterface-sizeBindingModule', 'event handler of type ' + typeof evHandler + 'are not allowed, data: ' + JSON.stringify(evHandler));\n        }\n    }\n    function createListener() {\n        return function handler() {\n            var vnode = handler.vnode;\n            var evHandler = vnode.data.size;\n            var eventData = vnode.elm.getBoundingClientRect();\n            invokeHandler(evHandler, vnode, eventData);\n        };\n    }\n    function updateSizeListener(oldVnode, vnode) {\n        var oldSize = oldVnode.data.size, oldResizeListener = oldVnode.resizeListener, oldResizeSensor = oldVnode.resizeSensor, size = vnode && vnode.data.size, elm = (vnode && vnode.elm);\n        // optimization for reused immutable handlers\n        if (oldSize === size) {\n            return;\n        }\n        // remove existing listeners which no longer used\n        if (oldSize && oldResizeListener) {\n            // if element changed or deleted we remove all existing listeners unconditionally\n            if (!size) {\n                // remove listener if element was changed or existing listeners removed\n                oldResizeSensor.detach(oldResizeListener);\n            }\n        }\n        // add new listeners which has not already attached\n        if (size) {\n            // reuse existing listener or create new\n            var resizeListener = vnode.resizeListener = oldVnode.listener || createListener();\n            vnode.resizeSensor = oldVnode.listener || new resizeSensor_1.ResizeSensor(elm, resizeListener);\n            // update vnode for listener\n            resizeListener.vnode = vnode;\n        }\n    }\n    return {\n        create: updateSizeListener,\n        update: updateSizeListener,\n        destroy: updateSizeListener,\n    };\n};\nexports.default = exports.sizeBindingModule;\n//# sourceMappingURL=sizeBinding.js.map"},"https://unpkg.com/fractal-core@4.3.8/interfaces/view/utils.js":{"fullPath":"https://unpkg.com/fractal-core@4.3.8/interfaces/view/utils.js","contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* istanbul ignore next */\nexports.isDescendant = (parent, child) => {\n    var node = child.parentNode;\n    while (node != null) {\n        if (node == parent) {\n            return true;\n        }\n        node = node.parentNode;\n    }\n    return false;\n};\n//# sourceMappingURL=utils.js.map"},"https://unpkg.com/fractal-core@4.3.8/interfaces/view/vnode.js":{"fullPath":"https://unpkg.com/fractal-core@4.3.8/interfaces/view/vnode.js","contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* istanbul ignore next */\nfunction vnode(sel, data, children, text, elm) {\n    let key = data === undefined ? undefined : data.key;\n    return { sel: sel, data: data, children: children,\n        text: text, elm: elm, key: key };\n}\nexports.vnode = vnode;\nexports.default = vnode;\n//# sourceMappingURL=vnode.js.map"},"https://unpkg.com/fractal-core@4.3.8/utils/component.js":{"fullPath":"https://unpkg.com/fractal-core@4.3.8/utils/component.js","contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst core_1 = require(\"../core\");\n// set of helpers for building components\n// send a message to an input of a component from outside a Module\n/* istanbul ignore next */\nasync function sendMsg(mod, id, inputName, msg, isPropagated = true) {\n    let ctx = mod.rootCtx;\n    await core_1.toIt(ctx.components[id])(inputName, msg, isPropagated);\n}\nexports.sendMsg = sendMsg;\nfunction setGroup(name, group) {\n    return function (comp) {\n        comp.groups[name] = group;\n        return comp;\n    };\n}\nexports.setGroup = setGroup;\nfunction spaceOf(ctx) {\n    return ctx.components[ctx.id];\n}\nexports.spaceOf = spaceOf;\n// make a new component from another merging her state\nfunction props(state) {\n    return function (comp) {\n        let newComp = Object.assign({}, comp); // shallow clone\n        newComp.state = core_1.clone(Object.assign(comp.state, state));\n        return newComp;\n    };\n}\nexports.props = props;\nfunction styles(style) {\n    return function (comp) {\n        let newComp = Object.assign({}, comp); // shallow clone\n        newComp.groups.style = core_1.clone(core_1.mergeStyles(comp.groups.style, style));\n        return newComp;\n    };\n}\nexports.styles = styles;\nexports.compGroup = (groupName, arr, fn) => arr.reduce((comps, c) => {\n    comps[groupName + '_' + c[0]] = fn(c[1]);\n    return comps;\n}, {});\nexports.getDescendantIds = (ctx, id) => {\n    let searchStr = id + '$';\n    return Object.keys(ctx.components).filter(compId => compId.includes(searchStr));\n};\nexports.getParentCtx = (ctx) => ctx.components[(ctx.id + '').split('$').slice(0, -1).join('$')];\n//# sourceMappingURL=component.js.map"},"https://unpkg.com/fractal-core@4.3.8/utils/fun.js":{"fullPath":"https://unpkg.com/fractal-core@4.3.8/utils/fun.js","contents":"\"use strict\";\n// -- Functional functions (just fun)\n// Use them for building actions in a declarative and concise way\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assoc = (key) => (value) => obj => {\n    obj[key] = value;\n    return obj;\n};\nexports.evolve = (index) => obj => {\n    for (let key in index) {\n        obj[key] = index[key](obj[key]);\n    }\n    return obj;\n};\nexports.evolveKey = (key) => (fn) => obj => {\n    obj[key] = fn(obj[key]);\n    return obj;\n};\n// pipe allows to pipe functions (left composing)\nfunction pipe(...args) {\n    return function (value) {\n        let result = value;\n        for (let i = 0, len = args.length; i < len; i++) {\n            result = args[i](result);\n        }\n        return result;\n    };\n}\nexports.pipe = pipe;\nfunction mapToObj(arr, fn) {\n    let result = {}, aux;\n    for (let i = 0, len = arr.length; i < len; i++) {\n        aux = fn(i, arr[i]);\n        result[aux[0]] = aux[1];\n    }\n    return result;\n}\nexports.mapToObj = mapToObj;\nfunction merge(objSrc) {\n    return function (obj) {\n        let key;\n        for (key in objSrc) {\n            obj[key] = objSrc[key];\n        }\n        return obj;\n    };\n}\nexports.merge = merge;\nconst _deepmerge = require(\"deepmerge/dist/umd\");\nexports.deepmerge = _deepmerge;\nexports.deepmergeAll = _deepmerge.all;\nexports.mapAsync = async (arr, fn) => {\n    let res = [];\n    for (let i = 0, len = arr.length; i < len; i++) {\n        res[i] = await fn(arr[i], i, arr);\n    }\n    return res;\n};\nexports.filterAsync = async (arr, fn) => {\n    let res = [];\n    for (let i = 0, len = arr.length; i < len; i++) {\n        if (await fn(arr[i], i, arr)) {\n            res.push(arr[i]);\n        }\n    }\n    return res;\n};\nexports.reduceAsync = async (arr, fn, v0) => {\n    for (let i = 0, len = arr.length; i < len; i++) {\n        v0 = await fn(v0, arr[i], i);\n    }\n    return v0;\n};\nexports.all = async (arr) => await Promise.all(arr);\nexports.range = (a, b) => {\n    let res = [];\n    if (a < b) {\n        b++;\n        for (; a < b; a++) {\n            res.push(a);\n        }\n    }\n    else {\n        b--;\n        for (; a > b; a--) {\n            res.push(a);\n        }\n    }\n    return res;\n};\nexports.waitMS = (ms) => new Promise(res => setTimeout(res, ms));\n// Math\nexports.sum = (numbers) => numbers.reduce((acc, n) => acc + n);\n//# sourceMappingURL=fun.js.map"},"https://unpkg.com/fractal-core@4.3.8/utils/index.js":{"fullPath":"https://unpkg.com/fractal-core@4.3.8/utils/index.js","contents":"\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./component\"));\n__export(require(\"./fun\"));\n__export(require(\"./log\"));\n__export(require(\"./reattach\"));\n__export(require(\"./style\"));\n__export(require(\"./worker\"));\n//# sourceMappingURL=index.js.map"},"https://unpkg.com/fractal-core@4.3.8/utils/log.js":{"fullPath":"https://unpkg.com/fractal-core@4.3.8/utils/log.js","contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst core_1 = require(\"../core\");\nexports.warn = async (source, description) => console.warn(`source: ${source}, description: ${description}`);\nexports.error = (source, description) => {\n    throw `source: ${source}, description: ${description}`;\n};\nexports.beforeInput = (ctx, inputName, data) => {\n    if (!ctx.global.log)\n        return;\n    let state = core_1._stateOf(ctx)();\n    if (typeof state === 'object') {\n        state = core_1.clone(state);\n    }\n    console.groupCollapsed(`%c input %c${inputName} %cfrom %c${ctx.id}`, 'color: #626060; font-size: 12px;', 'color: #3b3a3a; font-size: 14px;', 'color: #626060; font-size: 12px;', 'color: #3b3a3a; font-size: 14px;');\n    console.info('%c input data  ', 'color: rgb(9, 157, 225); font-weight: bold;', data);\n    console.info('%c prev state  ', 'color: #AFAFAF; font-weight: bold;', state);\n};\n// color for actions (not yet implemented) #58C6F8\nexports.afterInput = (ctx, inputName, data) => {\n    if (!ctx.global.log)\n        return;\n    let state = core_1._stateOf(ctx)();\n    if (typeof state === 'object') {\n        state = core_1.clone(state);\n    }\n    console.info('%c next state  ', 'color: #3CA43F; font-weight: bold;', state);\n    console.groupEnd();\n};\nexports.logFns = {\n    warn: exports.warn,\n    error: exports.error,\n    beforeInput: exports.beforeInput,\n    afterInput: exports.afterInput,\n};\n//# sourceMappingURL=log.js.map"},"https://unpkg.com/fractal-core@4.3.8/utils/reattach.js":{"fullPath":"https://unpkg.com/fractal-core@4.3.8/utils/reattach.js","contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst input_1 = require(\"../core/input\");\nexports.hotSwap = async (ctx, app) => {\n    let records = app.rootCtx.global.records;\n    ctx.global.records = [];\n    ctx.global.render = false;\n    ctx.global.log = false;\n    let record;\n    let comp;\n    for (let i = 0, len = records.length; i < len; i++) {\n        record = records[i];\n        comp = ctx.components[record.id];\n        if (comp) {\n            await input_1.toAct(comp)(record.actionName, record.value);\n        }\n    }\n    ctx.global.render = true;\n    ctx.global.log = true;\n    app.rootCtx = ctx;\n};\n//# sourceMappingURL=reattach.js.map"},"https://unpkg.com/fractal-core@4.3.8/utils/style.js":{"fullPath":"https://unpkg.com/fractal-core@4.3.8/utils/style.js","contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst typestyle_1 = require(\"typestyle\");\nconst fun_1 = require(\"./fun\");\nconst index_1 = require(\"../interfaces/view/index\");\nexports.getStyles = typestyle_1.getStyles;\n/* istanbul ignore next */\nfunction styleGroup(instance, stylesObj, moduleName) {\n    let classes = {};\n    for (let key in stylesObj) {\n        if (moduleName !== undefined) {\n            classes[key] = instance.style(stylesObj[key], { $debugName: `_${moduleName}_${key}__` });\n        }\n        else {\n            classes[key] = instance.style(stylesObj[key]);\n        }\n    }\n    return classes;\n}\nexports.styleGroup = styleGroup;\n/* istanbul ignore next */\nfunction hasBaseObject(obj) {\n    for (let key in obj) {\n        if (obj[key] !== null && typeof obj[key] === 'object' && key == 'base') {\n            return true;\n        }\n    }\n    return false;\n}\nexports.hasBaseObject = hasBaseObject;\n// function for ngClass with one dynamic property\n/* istanbul ignore next */\nfunction c(className, condition) {\n    return {\n        [className]: condition,\n    };\n}\nexports.c = c;\n/* istanbul ignore next */\nfunction mergeStyles(group1, group2) {\n    let mergedGroup = { base: {} };\n    for (let i = 0, keys = Object.keys(group1), len = keys.length; i < len; i++) {\n        mergedGroup[keys[i]] = group1[keys[i]];\n    }\n    for (let i = 0, keys = Object.keys(group2), len = keys.length; i < len; i++) {\n        if (mergedGroup[keys[i]] && typeof mergedGroup[keys[i]] === 'object') {\n            mergedGroup[keys[i]] = fun_1.deepmerge(mergedGroup[keys[i]], group2[keys[i]]);\n        }\n        else {\n            mergedGroup[keys[i]] = group2[keys[i]];\n        }\n    }\n    return mergedGroup;\n}\nexports.mergeStyles = mergeStyles;\n/* istanbul ignore next */\nexports.placeholderColor = (color) => ({\n    $nest: {\n        '&::-webkit-input-placeholder': {\n            $unique: true,\n            color: color,\n        },\n        '&::-moz-placeholder': {\n            $unique: true,\n            color: color,\n            opacity: 1,\n        },\n        '&:-ms-input-placeholder': {\n            $unique: true,\n            color: color,\n        },\n    },\n});\nexports.absoluteCenter = {\n    display: 'flex',\n    alignItems: 'center',\n    justifyContent: 'center',\n};\nexports.clickable = {\n    cursor: 'pointer',\n    userSelect: 'none',\n    '-moz-user-select': 'none',\n};\nexports.obfuscator = {\n    position: 'absolute',\n    top: '0px',\n    left: '0px',\n    width: '100%',\n    height: '100%',\n    backgroundColor: 'rgba(0,0,0,0.5)',\n    display: 'none',\n};\n// Evaluate deprecation\nexports.imageRenderingContrast = {\n    'imageRendering': [\n        'optimizeSpeed',\n        '-moz-crisp-edges',\n        '-o-crisp-edges',\n        '-webkit-optimize-contrast',\n        'optimize-contrast',\n    ],\n    '-ms-interpolation-mode': 'nearest-neighbor',\n};\nexports.iconView = (iconName, options = {}) => index_1.h('svg', fun_1.deepmerge({ class: { ['svg_' + iconName]: true } }, options), [\n    index_1.h('use', { attrs: { 'xlink:href': 'assets/icons-bundle.min.svg#' + iconName } }),\n]);\n//# sourceMappingURL=style.js.map"},"https://unpkg.com/fractal-core@4.3.8/utils/worker.js":{"fullPath":"https://unpkg.com/fractal-core@4.3.8/utils/worker.js","contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction makeSyncQueue() {\n    let queue = [];\n    return {\n        queue,\n        addWaiter(waiter) {\n            queue.push(waiter);\n        },\n        next(data) {\n            if (queue[0] && queue[0](data)) {\n                queue.shift();\n            }\n        },\n    };\n}\nexports.makeSyncQueue = makeSyncQueue;\nexports.workerHandler = (type, name, syncQueue, workerAPI) => (mod) => {\n    let _self = workerAPI ? workerAPI : self;\n    return {\n        state: undefined,\n        handle: async (value) => {\n            _self.postMessage([type, name, 'handle', value]);\n            if (type === 'group') {\n                return new Promise((resolve) => {\n                    syncQueue.addWaiter(data => {\n                        if (data[0] === 'setGroup') {\n                            resolve();\n                            return true;\n                        }\n                    });\n                });\n            }\n        },\n        dispose: () => {\n            _self.postMessage([type, name, 'dispose']);\n        },\n    };\n};\nexports.workerLog = (type, workerAPI) => {\n    let _self = workerAPI ? workerAPI : self;\n    return (source, description) => {\n        _self.postMessage(['log', type, source, description]);\n    };\n};\n// receives messages from runWorker\nexports.workerListener = (syncQueue, workerAPI) => (mod) => {\n    let _self = workerAPI ? workerAPI : self;\n    // allows to dispatch inputs from the main thread\n    _self.onmessage = ev => {\n        let data = ev.data;\n        switch (data[0]) {\n            case 'dispatchEv':\n                mod.dispatchEv(data[1], data[2]);\n                break;\n            case 'toComp':\n                mod.toComp(data[1], data[2], data[3], data[4]);\n                break;\n            case 'setGroup':\n                mod.setGroup(data[1], data[2], data[3]);\n                break;\n            case 'dispose':\n                mod.dispose();\n                _self.postMessage(['dispose']);\n                break;\n            case 'nest':\n                // not implemented yet, should deserialize a component with a safe eval\n                mod.error('workerListener', `unimplemented method`);\n                break;\n            case 'nestAll':\n                // not implemented yet, should deserialize a list of components with a safe eval\n                mod.error('workerListener', `unimplemented method`);\n                break;\n            case 'unnest':\n                // not implemented yet, should deserialize a component with a safe eval\n                mod.error('workerListener', `unimplemented method`);\n                break;\n            case 'unnestAll':\n                // not implemented yet, should deserialize a list of components with a safe eval\n                mod.error('workerListener', `unimplemented method`);\n                break;\n            default:\n                mod.error('workerListener', `unknown message type recived from worker: ${data.join(', ')}`);\n        }\n        syncQueue.next(data);\n    };\n};\nfunction runWorker(def) {\n    let worker = def.worker;\n    let groupObjects = {};\n    let taskObjects = {};\n    let interfaceObjects = {};\n    let attach = async (comp) => {\n        def.error('reattach', 'unimplemented method');\n    };\n    // API for modules\n    let moduleAPI = {\n        // dispatch function type used for handlers\n        dispatchEv: async (event, iData) => worker.postMessage(['dispatchEv', event, iData]),\n        toComp: async (id, inputName, data, isPropagated = true) => worker.postMessage(['toComp', id, inputName, data, isPropagated]),\n        dispose,\n        attach,\n        // nest a component to the component index\n        nest: async (name, component, isStatic = false) => worker.postMessage(['nest', name, component]),\n        // nest many components to the component index\n        nestAll: async (components, isStatic = false) => worker.postMessage(['nestAll', components]),\n        // unnest a component to the component index\n        unnest: async (name) => worker.postMessage(['unnest', name]),\n        // unnest many components to the component index\n        unnestAll: async (components) => worker.postMessage(['unnestAll', components]),\n        // delegated methods\n        setGroup: (id, name, group) => worker.postMessage(['setGroup', id, name, group]),\n        warn: def.warn,\n        error: def.error,\n    };\n    if (def.groups) {\n        for (let i = 0, names = Object.keys(def.groups), len = names.length; i < len; i++) {\n            groupObjects[names[i]] = def.groups[names[i]](moduleAPI);\n        }\n    }\n    if (def.tasks) {\n        for (let i = 0, names = Object.keys(def.tasks), len = names.length; i < len; i++) {\n            taskObjects[names[i]] = def.tasks[names[i]](moduleAPI);\n        }\n    }\n    if (def.interfaces) {\n        for (let i = 0, names = Object.keys(def.interfaces), len = names.length; i < len; i++) {\n            interfaceObjects[names[i]] = def.interfaces[names[i]](moduleAPI);\n        }\n    }\n    // TODO: reverse message sintax\n    worker.onmessage = async (ev) => {\n        let data = ev.data;\n        switch (data[0]) {\n            case 'interface':\n                if (data[2] === 'handle') {\n                    await interfaceObjects[data[1]].handle(data[3]);\n                    break;\n                }\n                if (data[2] === 'dispose') {\n                    interfaceObjects[data[1]].dispose();\n                    break;\n                }\n            case 'task':\n                if (data[2] === 'handle') {\n                    await taskObjects[data[1]].handle(data[3]);\n                    break;\n                }\n                if (data[2] === 'dispose') {\n                    await taskObjects[data[1]].dispose();\n                    break;\n                }\n            case 'group':\n                if (data[2] === 'handle') {\n                    await groupObjects[data[1]].handle(data[3]);\n                    break;\n                }\n                if (data[2] === 'dispose') {\n                    groupObjects[data[1]].dispose();\n                    break;\n                }\n            case 'log':\n                if (moduleAPI[data[1]]) {\n                    moduleAPI[data[1]](data[2], data[3]);\n                    break;\n                }\n            case 'dispose':\n                if (def.destroy) {\n                    def.destroy(moduleAPI);\n                }\n                break;\n            default:\n                moduleAPI.error('runWorker', `unknown message type recived from worker: ${data.join(', ')}`);\n        }\n    };\n    function dispose() {\n        worker.postMessage(['dispose']);\n    }\n    return {\n        worker,\n        moduleAPI,\n        groupObjects,\n        taskObjects,\n        interfaceObjects,\n    };\n}\nexports.runWorker = runWorker;\n//# sourceMappingURL=worker.js.map"},"https://unpkg.com/setimmediate@1.0.5/setImmediate.js":{"fullPath":"https://unpkg.com/setimmediate@1.0.5/setImmediate.js","contents":"(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n"},"https://unpkg.com/deepmerge@1.5.2/dist/umd.js":{"fullPath":"https://unpkg.com/deepmerge@1.5.2/dist/umd.js","contents":"(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.deepmerge = factory());\n}(this, (function () { 'use strict';\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n    return Array.isArray(val) ? [] : {}\n}\n\nfunction cloneIfNecessary(value, optionsArgument) {\n    var clone = optionsArgument && optionsArgument.clone === true;\n    return (clone && isMergeableObject(value)) ? deepmerge(emptyTarget(value), value, optionsArgument) : value\n}\n\nfunction defaultArrayMerge(target, source, optionsArgument) {\n    var destination = target.slice();\n    source.forEach(function(e, i) {\n        if (typeof destination[i] === 'undefined') {\n            destination[i] = cloneIfNecessary(e, optionsArgument);\n        } else if (isMergeableObject(e)) {\n            destination[i] = deepmerge(target[i], e, optionsArgument);\n        } else if (target.indexOf(e) === -1) {\n            destination.push(cloneIfNecessary(e, optionsArgument));\n        }\n    });\n    return destination\n}\n\nfunction mergeObject(target, source, optionsArgument) {\n    var destination = {};\n    if (isMergeableObject(target)) {\n        Object.keys(target).forEach(function(key) {\n            destination[key] = cloneIfNecessary(target[key], optionsArgument);\n        });\n    }\n    Object.keys(source).forEach(function(key) {\n        if (!isMergeableObject(source[key]) || !target[key]) {\n            destination[key] = cloneIfNecessary(source[key], optionsArgument);\n        } else {\n            destination[key] = deepmerge(target[key], source[key], optionsArgument);\n        }\n    });\n    return destination\n}\n\nfunction deepmerge(target, source, optionsArgument) {\n    var sourceIsArray = Array.isArray(source);\n    var targetIsArray = Array.isArray(target);\n    var options = optionsArgument || { arrayMerge: defaultArrayMerge };\n    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n    if (!sourceAndTargetTypesMatch) {\n        return cloneIfNecessary(source, optionsArgument)\n    } else if (sourceIsArray) {\n        var arrayMerge = options.arrayMerge || defaultArrayMerge;\n        return arrayMerge(target, source, optionsArgument)\n    } else {\n        return mergeObject(target, source, optionsArgument)\n    }\n}\n\ndeepmerge.all = function deepmergeAll(array, optionsArgument) {\n    if (!Array.isArray(array) || array.length < 2) {\n        throw new Error('first argument should be an array with at least two elements')\n    }\n\n    // we are sure there are at least 2 values, so it is safe to have no initial value\n    return array.reduce(function(prev, next) {\n        return deepmerge(prev, next, optionsArgument)\n    })\n};\n\nvar deepmerge_1 = deepmerge;\n\nreturn deepmerge_1;\n\n})));\n"},"https://unpkg.com/@types/core-js@0.9.43/index.d.ts":{"fullPath":"https://unpkg.com/@types/core-js@0.9.43/index.d.ts","contents":"// Type definitions for core-js 0.9\n// Project: https://github.com/zloirock/core-js/\n// Definitions by: Ron Buckton <https://github.com/rbuckton>, Michel Felipe <https://github.com/mfdeveloper>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.1\n\n/* *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n// #############################################################################################\n// ECMAScript 6: Symbols\n// Modules: es6.symbol\n// #############################################################################################\n\ninterface SymbolConstructor {\n    /**\n     * Non-standard. Use simple mode for core-js symbols. See https://github.com/zloirock/core-js/#caveats-when-using-symbol-polyfill\n     */\n    useSimple(): void;\n\n    /**\n     * Non-standard. Use setter mode for core-js symbols. See https://github.com/zloirock/core-js/#caveats-when-using-symbol-polyfill\n     */\n    userSetter(): void;\n}\n\ninterface $for<T> extends IterableIterator<T> {\n    of(callbackfn: (value: T, key: any) => void, thisArg?: any): void;\n    array(): T[];\n    array<U>(callbackfn: (value: T, key: any) => U, thisArg?: any): U[];\n    filter(callbackfn: (value: T, key: any) => boolean, thisArg?: any): $for<T>;\n    map<U>(callbackfn: (value: T, key: any) => U, thisArg?: any): $for<U>;\n}\n\ndeclare function $for<T>(iterable: Iterable<T>): $for<T>;\n\n// #############################################################################################\n// ECMAScript 7\n// Modules: es7.array.includes, es7.string.at, es7.string.pad-start, es7.string.pad-end,\n//          es7.object.to-array, es7.object.get-own-property-descriptors, es7.regexp.escape,\n//          es7.map.to-json, es7.set.to-json, es7.reflect.define-metadata, es7.reflect.delete-metadata\n//          es7.reflect.get-metadata, es7.reflect.get-metadata-keys, es7.reflect.get-own-metadata,\n//          es7.reflect.get-own-metadata-keys, es7.reflect.has-metadata, es7.reflect.has-own-metadata\n//          es7.reflect.metadata\n// #############################################################################################\n\ninterface String {\n    at(index: number): string;\n}\n\ninterface Object {\n    getOwnPropertyDescriptors(object: any): PropertyDescriptorMap;\n}\n\ninterface RegExpConstructor {\n    escape(str: string): string;\n}\n\ninterface Map<K, V> {\n    toJSON(): any;\n}\n\ninterface Set<T> {\n    toJSON(): any;\n}\n\n// #############################################################################################\n// Mozilla JavaScript: Array generics\n// Modules: js.array.statics\n// #############################################################################################\n\ninterface ArrayConstructor {\n    /**\n     * Appends new elements to an array, and returns the new length of the array.\n     * @param items New elements of the Array.\n     */\n    push<T>(array: ArrayLike<T>, ...items: T[]): number;\n    /**\n     * Removes the last element from an array and returns it.\n     */\n    pop<T>(array: ArrayLike<T>): T;\n    /**\n     * Combines two or more arrays.\n     * @param items Additional items to add to the end of array1.\n     */\n    concat<T>(array: ArrayLike<T>, ...items: Array<T[]| T>): T[];\n    /**\n     * Adds all the elements of an array separated by the specified separator string.\n     * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.\n     */\n    join<T>(array: ArrayLike<T>, separator?: string): string;\n    /**\n     * Reverses the elements in an Array.\n     */\n    reverse<T>(array: ArrayLike<T>): T[];\n    /**\n     * Removes the first element from an array and returns it.\n     */\n    shift<T>(array: ArrayLike<T>): T;\n    /**\n     * Returns a section of an array.\n     * @param start The beginning of the specified portion of the array.\n     * @param end The end of the specified portion of the array.\n     */\n    slice<T>(array: ArrayLike<T>, start?: number, end?: number): T[];\n\n    /**\n     * Sorts an array.\n     * @param compareFn The name of the function used to determine the order of the elements. If omitted, the elements are sorted in ascending, ASCII character order.\n     */\n    sort<T>(array: ArrayLike<T>, compareFn?: (a: T, b: T) => number): T[];\n\n    /**\n     * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.\n     * @param start The zero-based location in the array from which to start removing elements.\n     * @param deleteCount The number of elements to remove.\n     * @param items Elements to insert into the array in place of the deleted elements.\n     */\n    splice<T>(array: ArrayLike<T>, start: number, deleteCount?: number, ...items: T[]): T[];\n\n    /**\n     * Inserts new elements at the start of an array.\n     * @param items  Elements to insert at the start of the Array.\n     */\n    unshift<T>(array: ArrayLike<T>, ...items: T[]): number;\n\n    /**\n     * Returns the index of the first occurrence of a value in an array.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.\n     */\n    indexOf<T>(array: ArrayLike<T>, searchElement: T, fromIndex?: number): number;\n\n    /**\n     * Returns the index of the last occurrence of a specified value in an array.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.\n     */\n    lastIndexOf<T>(array: ArrayLike<T>, earchElement: T, fromIndex?: number): number;\n\n    /**\n     * Determines whether all the members of an array satisfy the specified test.\n     * @param callbackfn  A function that accepts up to three arguments.\n     *        The every method calls the callbackfn function for each element in array1 until the callbackfn returns false, or until the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n     */\n    every<T>(array: ArrayLike<T>, callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean;\n\n    /**\n     * Determines whether the specified callback function returns true for any element of an array.\n     * @param callbackfn A function that accepts up to three arguments.\n     *        The some method calls the callbackfn function for each element in array1 until the callbackfn returns true, or until the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n     */\n    some<T>(array: ArrayLike<T>, callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean;\n\n    /**\n     * Performs the specified action for each element in an array.\n     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.\n     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n     */\n    forEach<T>(array: ArrayLike<T>, callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any): void;\n\n    /**\n     * Calls a defined callback function on each element of an array, and returns an array that contains the results.\n     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n     */\n    map<T, U>(array: ArrayLike<T>, callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[];\n\n    /**\n     * Returns the elements of an array that meet the condition specified in a callback function.\n     * @param callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n     */\n    filter<T>(array: ArrayLike<T>, callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): T[];\n\n    /**\n     * Calls the specified callback function for all the elements in an array.\n     * The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation.\n     *        The first call to the callbackfn function provides this value as an argument instead of an array value.\n     */\n    reduce<T, U>(array: ArrayLike<T>, callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;\n\n    /**\n     * Calls the specified callback function for all the elements in an array.\n     * The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation.\n     *        The first call to the callbackfn function provides this value as an argument instead of an array value.\n     */\n    reduce<T>(array: ArrayLike<T>, callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue?: T): T;\n\n    /**\n     * Calls the specified callback function for all the elements in an array, in descending order.\n     * The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation.\n     *        The first call to the callbackfn function provides this value as an argument instead of an array value.\n     */\n    reduceRight<T, U>(array: ArrayLike<T>, callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;\n\n    /**\n     * Calls the specified callback function for all the elements in an array, in descending order.\n     * The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation.\n     *        The first call to the callbackfn function provides this value as an argument instead of an array value.\n     */\n    reduceRight<T>(array: ArrayLike<T>, callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue?: T): T;\n\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries<T>(array: ArrayLike<T>): IterableIterator<[number, T]>;\n\n    /**\n     * Returns an list of keys in the array\n     */\n    keys<T>(array: ArrayLike<T>): IterableIterator<number>;\n\n    /**\n     * Returns an list of values in the array\n     */\n    values<T>(array: ArrayLike<T>): IterableIterator<T>;\n\n    /**\n     * Returns the value of the first element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found, find\n     * immediately returns that element value. Otherwise, find returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    find<T>(array: ArrayLike<T>, predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): T;\n\n    /**\n     * Returns the index of the first element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found, find\n     * immediately returns that element value. Otherwise, find returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findIndex<T>(array: ArrayLike<T>, predicate: (value: T) => boolean, thisArg?: any): number;\n\n    /**\n     * Returns the this object after filling the section identified by start and end with value\n     * @param value value to fill array section with\n     * @param start index to start filling the array at. If start is negative, it is treated as\n     * length+start where length is the length of the array.\n     * @param end index to stop filling the array at. If end is negative, it is treated as\n     * length+end.\n     */\n    fill<T>(array: ArrayLike<T>, value: T, start?: number, end?: number): T[];\n\n    /**\n     * Returns the this object after copying a section of the array identified by start and end\n     * to the same array starting at position target\n     * @param target If target is negative, it is treated as length+target where length is the\n     * length of the array.\n     * @param start If start is negative, it is treated as length+start. If end is negative, it\n     * is treated as length+end.\n     * @param end If not specified, length of the this object is used as its default value.\n     */\n    copyWithin<T>(array: ArrayLike<T>, target: number, start: number, end?: number): T[];\n\n    includes<T>(array: ArrayLike<T>, value: T, fromIndex?: number): boolean;\n    turn<T, U>(array: ArrayLike<T>, callbackfn: (memo: U, value: T, index: number, array: T[]) => void, memo?: U): U;\n    turn<T>(array: ArrayLike<T>, callbackfn: (memo: T[], value: T, index: number, array: T[]) => void, memo?: T[]): T[];\n}\n\n// #############################################################################################\n// Object - https://github.com/zloirock/core-js/#object\n// Modules: core.object\n// #############################################################################################\n\ninterface ObjectConstructor {\n    /**\n     * Non-standard.\n     */\n    isObject(value: any): boolean;\n\n    /**\n     * Non-standard.\n     */\n    classof(value: any): string;\n\n    /**\n     * Non-standard.\n     */\n    define<T>(target: T, mixin: any): T;\n\n    /**\n     * Non-standard.\n     */\n    make<T>(proto: T, mixin?: any): T;\n}\n\n// #############################################################################################\n// Console - https://github.com/zloirock/core-js/#console\n// Modules: core.log\n// #############################################################################################\n\ninterface Log extends Console {\n    (message?: any, ...optionalParams: any[]): void;\n    enable(): void;\n    disable(): void;\n}\n\n/**\n * Non-standard.\n */\ndeclare var log: Log;\n\n// #############################################################################################\n// Dict - https://github.com/zloirock/core-js/#dict\n// Modules: core.dict\n// #############################################################################################\n\ninterface Dict<T> {\n    [key: string]: T;\n    [key: number]: T;\n    // [key: symbol]: T;\n}\n\ninterface DictConstructor {\n    prototype: Dict<any>;\n\n    new <T>(value?: Dict<T>): Dict<T>;\n    new (value?: any): Dict<any>;\n    <T>(value?: Dict<T>): Dict<T>;\n    (value?: any): Dict<any>;\n\n    isDict(value: any): boolean;\n    values<T>(object: Dict<T>): IterableIterator<T>;\n    keys<T>(object: Dict<T>): IterableIterator<PropertyKey>;\n    entries<T>(object: Dict<T>): IterableIterator<[PropertyKey, T]>;\n    has<T>(object: Dict<T>, key: PropertyKey): boolean;\n    get<T>(object: Dict<T>, key: PropertyKey): T;\n    set<T>(object: Dict<T>, key: PropertyKey, value: T): Dict<T>;\n    forEach<T>(object: Dict<T>, callbackfn: (value: T, key: PropertyKey, dict: Dict<T>) => void, thisArg?: any): void;\n    map<T, U>(object: Dict<T>, callbackfn: (value: T, key: PropertyKey, dict: Dict<T>) => U, thisArg?: any): Dict<U>;\n    mapPairs<T, U>(object: Dict<T>, callbackfn: (value: T, key: PropertyKey, dict: Dict<T>) => [PropertyKey, U], thisArg?: any): Dict<U>;\n    filter<T>(object: Dict<T>, callbackfn: (value: T, key: PropertyKey, dict: Dict<T>) => boolean, thisArg?: any): Dict<T>;\n    some<T>(object: Dict<T>, callbackfn: (value: T, key: PropertyKey, dict: Dict<T>) => boolean, thisArg?: any): boolean;\n    every<T>(object: Dict<T>, callbackfn: (value: T, key: PropertyKey, dict: Dict<T>) => boolean, thisArg?: any): boolean;\n    find<T>(object: Dict<T>, callbackfn: (value: T, key: PropertyKey, dict: Dict<T>) => boolean, thisArg?: any): T;\n    findKey<T>(object: Dict<T>, callbackfn: (value: T, key: PropertyKey, dict: Dict<T>) => boolean, thisArg?: any): PropertyKey;\n    keyOf<T>(object: Dict<T>, value: T): PropertyKey;\n    includes<T>(object: Dict<T>, value: T): boolean;\n    reduce<T, U>(object: Dict<T>, callbackfn: (previousValue: U, value: T, key: PropertyKey, dict: Dict<T>) => U, initialValue: U): U;\n    reduce<T>(object: Dict<T>, callbackfn: (previousValue: T, value: T, key: PropertyKey, dict: Dict<T>) => T, initialValue?: T): T;\n    turn<T, U>(object: Dict<T>, callbackfn: (memo: Dict<U>, value: T, key: PropertyKey, dict: Dict<T>) => void, memo: Dict<U>): Dict<U>;\n    turn<T>(object: Dict<T>, callbackfn: (memo: Dict<T>, value: T, key: PropertyKey, dict: Dict<T>) => void, memo?: Dict<T>): Dict<T>;\n}\n\n/**\n * Non-standard.\n */\ndeclare var Dict: DictConstructor;\n\n// #############################################################################################\n// Partial application - https://github.com/zloirock/core-js/#partial-application\n// Modules: core.function.part\n// #############################################################################################\n\ninterface Function {\n    /**\n     * Non-standard.\n     */\n    part(...args: any[]): any;\n}\n\n// #############################################################################################\n// Date formatting - https://github.com/zloirock/core-js/#date-formatting\n// Modules: core.date\n// #############################################################################################\n\ninterface Date {\n    /**\n     * Non-standard.\n     */\n    format(template: string, locale?: string): string;\n\n    /**\n     * Non-standard.\n     */\n    formatUTC(template: string, locale?: string): string;\n}\n\n// #############################################################################################\n// Array - https://github.com/zloirock/core-js/#array\n// Modules: core.array.turn\n// #############################################################################################\n\ninterface Array<T> {\n    /**\n     * Non-standard.\n     */\n    turn<U>(callbackfn: (memo: U, value: T, index: number, array: T[]) => void, memo?: U): U;\n\n    /**\n     * Non-standard.\n     */\n    turn(callbackfn: (memo: T[], value: T, index: number, array: T[]) => void, memo?: T[]): T[];\n}\n\n// #############################################################################################\n// Number - https://github.com/zloirock/core-js/#number\n// Modules: core.number.iterator\n// #############################################################################################\n\ninterface Number {\n    /**\n     * Non-standard.\n     */\n    [Symbol.iterator](): IterableIterator<number>;\n}\n\n// #############################################################################################\n// Escaping characters - https://github.com/zloirock/core-js/#escaping-characters\n// Modules: core.string.escape-html\n// #############################################################################################\n\ninterface String {\n    /**\n     * Non-standard.\n     */\n    escapeHTML(): string;\n\n    /**\n     * Non-standard.\n     */\n    unescapeHTML(): string;\n}\n\n// #############################################################################################\n// delay - https://github.com/zloirock/core-js/#delay\n// Modules: core.delay\n// #############################################################################################\n\ndeclare function delay(msec: number): Promise<void>;\n\ndeclare namespace core {\n    const version: string;\n\n    namespace Reflect {\n        function apply(target: Function, thisArgument: any, argumentsList: ArrayLike<any>): any;\n        function construct(target: Function, argumentsList: ArrayLike<any>): any;\n        function defineProperty(target: any, propertyKey: PropertyKey, attributes: PropertyDescriptor): boolean;\n        function deleteProperty(target: any, propertyKey: PropertyKey): boolean;\n        function enumerate(target: any): IterableIterator<any>;\n        function get(target: any, propertyKey: PropertyKey, receiver?: any): any;\n        function getOwnPropertyDescriptor(target: any, propertyKey: PropertyKey): PropertyDescriptor;\n        function getPrototypeOf(target: any): any;\n        function has(target: any, propertyKey: string | symbol): boolean;\n        function isExtensible(target: any): boolean;\n        function ownKeys(target: any): PropertyKey[];\n        function preventExtensions(target: any): boolean;\n        function set(target: any, propertyKey: PropertyKey, value: any, receiver?: any): boolean;\n        function setPrototypeOf(target: any, proto: any): boolean;\n        /**\n         * Define a unique metadata entry on the target.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param metadataValue A value that contains attached metadata.\n         * @param target The target object on which to define metadata.\n         * @example\n         *\n         * ### Example\n         *\n         * ```typescript\n         *  class Example {\n         *  }\n         *\n         *  // constructor\n         *  Reflect.defineMetadata(\"custom:annotation\", options, Example);\n         *\n         *  // decorator factory as metadata-producing annotation.\n         *  function MyAnnotation(options): ClassDecorator {\n         *      return target => Reflect.defineMetadata(\"custom:annotation\", options, target);\n         *  }\n         * ```\n         */\n        function defineMetadata(metadataKey: any, metadataValue: any, target: Object, targetKey?: string | symbol): void;\n        /**\n         * Deletes the metadata entry from the target object with the provided key.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @returns `true` if the metadata entry was found and deleted; otherwise, false.\n         * @example\n         *\n         * ### Example\n         *\n         * ```typescript\n         *  class Example {\n         *  }\n         *\n         *  // constructor\n         *  result = Reflect.deleteMetadata(\"custom:annotation\", Example);\n         * ```\n         */\n        function deleteMetadata(metadataKey: any, target: Object, targetKey?: string | symbol): boolean;\n        /**\n         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n         * @example\n         *\n         * ### Example\n         *\n         * ```typescript\n         *  class Example {\n         *  }\n         *\n         *  // constructor\n         *  result = Reflect.getMetadata(\"custom:annotation\", Example);\n         * ```\n         */\n        function getMetadata(metadataKey: any, target: Object, targetKey?: string | symbol): any;\n        /**\n         * Gets the metadata keys defined on the target object or its prototype chain.\n         * @param target The target object on which the metadata is defined.\n         * @returns An array of unique metadata keys.\n         * @example\n         *\n         * ### Example\n         *\n         * ```typescript\n         *  class Example {\n         *  }\n         *\n         *  // constructor\n         *  result = Reflect.getMetadataKeys(Example);\n         * ```\n         */\n        function getMetadataKeys(target: Object, targetKey?: string | symbol): any[];\n        /**\n         * Gets the metadata value for the provided metadata key on the target object.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n         * @example\n         *\n         * ### Example\n         *\n         * ```typescript\n         *  class Example {\n         *  }\n         *\n         *  // constructor\n         *  result = Reflect.getOwnMetadata(\"custom:annotation\", Example);\n         * ```\n         */\n        function getOwnMetadata(metadataKey: any, target: Object, targetKey?: string | symbol): any;\n\n        /**\n         * Gets the unique metadata keys defined on the target object.\n         * @param target The target object on which the metadata is defined.\n         * @returns An array of unique metadata keys.\n         * @example\n         *\n         * ### Example\n         *\n         * ```typescript\n         *  class Example {\n         *  }\n         *\n         *  // constructor\n         *  result = Reflect.getOwnMetadataKeys(Example);\n         * ```\n         */\n        function getOwnMetadataKeys(target: Object, targetKey?: string | symbol): any[];\n        /**\n         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.\n         * @example\n         *\n         * ### Example\n         *\n         * ```typescript\n         *  class Example {\n         *  }\n         *\n         *  // constructor\n         *  result = Reflect.hasMetadata(\"custom:annotation\", Example);\n         * ```\n         */\n        function hasMetadata(metadataKey: any, target: Object, targetKey?: string | symbol): boolean;\n        /**\n         * Gets a value indicating whether the target object has the provided metadata key defined.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.\n         * @example\n         *\n         * ### Example\n         *\n         * ```typescript\n         *\n         *  class Example {\n         *  }\n         *\n         *  // constructor\n         *  result = Reflect.hasOwnMetadata(\"custom:annotation\", Example);\n         * ```\n         */\n        function hasOwnMetadata(metadataKey: any, target: Object, targetKey?: string | symbol): boolean;\n        /**\n         * A default metadata decorator factory that can be used on a class, class member, or parameter.\n         * @param metadataKey The key for the metadata entry.\n         * @param metadataValue The value for the metadata entry.\n         * @returns A decorator function.\n         * @remarks\n         * If `metadataKey` is already defined for the target and target key, the\n         * metadataValue for that key will be overwritten.\n         * @example\n         *\n         * ### Example\n         *\n         * ```typescript\n         *  // constructor\n         *  @Reflect.metadata(key, value)\n         *  class Example {\n         *  }\n         *\n         *  // property (on constructor, TypeScript only)\n         *  class Example {\n         *      @Reflect.metadata(key, value)\n         *      static staticProperty;\n         *  }\n         *\n         *  // property (on prototype, TypeScript only)\n         *  class Example {\n         *      @Reflect.metadata(key, value)\n         *      property;\n         *  }\n         *\n         *  // method (on constructor)\n         *  class Example {\n         *      @Reflect.metadata(key, value)\n         *      static staticMethod() { }\n         *  }\n         *\n         *  // method (on prototype)\n         *  class Example {\n         *      @Reflect.metadata(key, value)\n         *      method() { }\n         *  }\n         * ```\n         */\n        function metadata(metadataKey: any, metadataValue: any): {\n            (target: Function): void;\n            (target: Object, targetKey: string | symbol): void;\n        };\n    }\n\n    const Object: {\n        getPrototypeOf(o: any): any;\n        getOwnPropertyNames(o: any): string[];\n        create(o: any, properties?: PropertyDescriptorMap): any;\n        defineProperties(o: any, properties: PropertyDescriptorMap): any;\n        seal<T>(o: T): T;\n        freeze<T>(o: T): T;\n        preventExtensions<T>(o: T): T;\n        isSealed(o: any): boolean;\n        isFrozen(o: any): boolean;\n        isExtensible(o: any): boolean;\n        keys(o: any): string[];\n        assign(target: any, ...sources: any[]): any;\n        is(value1: any, value2: any): boolean;\n        setPrototypeOf(o: any, proto: any): any;\n        getOwnPropertySymbols(o: any): symbol[];\n        getOwnPropertyDescriptor(o: any, propertyKey: PropertyKey): PropertyDescriptor;\n        defineProperty(o: any, propertyKey: PropertyKey, attributes: PropertyDescriptor): any;\n        values(object: any): any[];\n        entries(object: any): any[];\n        getOwnPropertyDescriptors(object: any): PropertyDescriptorMap;\n        isObject(value: any): boolean;\n        classof(value: any): string;\n        define<T>(target: T, mixin: any): T;\n        make<T>(proto: T, mixin?: any): T;\n    };\n\n    const Function: {\n        bind(target: Function, thisArg: any, ...argArray: any[]): any;\n        part(target: Function, ...args: any[]): any;\n    };\n\n    const Array: {\n        from<T, U>(arrayLike: ArrayLike<T> | Iterable<T>, mapfn: (v: T, k: number) => U, thisArg?: any): U[];\n        from<T>(arrayLike: ArrayLike<T> | Iterable<T>): T[];\n        of<T>(...items: T[]): T[];\n        push<T>(array: ArrayLike<T>, ...items: T[]): number;\n        pop<T>(array: ArrayLike<T>): T;\n        concat<T>(array: ArrayLike<T>, ...items: Array<T[] | T>): T[];\n        join<T>(array: ArrayLike<T>, separator?: string): string;\n        reverse<T>(array: ArrayLike<T>): T[];\n        shift<T>(array: ArrayLike<T>): T;\n        slice<T>(array: ArrayLike<T>, start?: number, end?: number): T[];\n        sort<T>(array: ArrayLike<T>, compareFn?: (a: T, b: T) => number): T[];\n        splice<T>(array: ArrayLike<T>, start: number, deleteCount?: number, ...items: T[]): T[];\n        unshift<T>(array: ArrayLike<T>, ...items: T[]): number;\n        indexOf<T>(array: ArrayLike<T>, searchElement: T, fromIndex?: number): number;\n        lastIndexOf<T>(array: ArrayLike<T>, earchElement: T, fromIndex?: number): number;\n        every<T>(array: ArrayLike<T>, callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean;\n        some<T>(array: ArrayLike<T>, callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean;\n        forEach<T>(array: ArrayLike<T>, callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any): void;\n        map<T, U>(array: ArrayLike<T>, callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[];\n        filter<T>(array: ArrayLike<T>, callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): T[];\n        reduce<T>(array: ArrayLike<T>, callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue?: T): T;\n        reduce<T, U>(array: ArrayLike<T>, callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;\n        reduceRight<T>(array: ArrayLike<T>, callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue?: T): T;\n        reduceRight<T, U>(array: ArrayLike<T>, callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;\n        entries<T>(array: ArrayLike<T>): IterableIterator<[number, T]>;\n        keys<T>(array: ArrayLike<T>): IterableIterator<number>;\n        values<T>(array: ArrayLike<T>): IterableIterator<T>;\n        find<T>(array: ArrayLike<T>, predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): T;\n        findIndex<T>(array: ArrayLike<T>, predicate: (value: T) => boolean, thisArg?: any): number;\n        fill<T>(array: ArrayLike<T>, value: T, start?: number, end?: number): T[];\n        copyWithin<T>(array: ArrayLike<T>, target: number, start: number, end?: number): T[];\n        includes<T>(array: ArrayLike<T>, value: T, fromIndex?: number): boolean;\n        turn<T>(array: ArrayLike<T>, callbackfn: (memo: T[], value: T, index: number, array: T[]) => void, memo?: T[]): T[];\n        turn<T, U>(array: ArrayLike<T>, callbackfn: (memo: U, value: T, index: number, array: T[]) => void, memo?: U): U;\n    };\n\n    const String: {\n        codePointAt(text: string, pos: number): number;\n        includes(text: string, searchString: string, position?: number): boolean;\n        endsWith(text: string, searchString: string, endPosition?: number): boolean;\n        repeat(text: string, count: number): string;\n        fromCodePoint(...codePoints: number[]): string;\n        raw(template: TemplateStringsArray, ...substitutions: any[]): string;\n        startsWith(text: string, searchString: string, position?: number): boolean;\n        at(text: string, index: number): string;\n        lpad(text: string, length: number, fillStr?: string): string;\n        rpad(text: string, length: number, fillStr?: string): string;\n        escapeHTML(text: string): string;\n        unescapeHTML(text: string): string;\n    };\n\n    const Date: {\n        now(): number;\n        toISOString(date: Date): string;\n        format(date: Date, template: string, locale?: string): string;\n        formatUTC(date: Date, template: string, locale?: string): string;\n    };\n\n    const Number: {\n        EPSILON: number;\n        isFinite(number: number): boolean;\n        isInteger(number: number): boolean;\n        isNaN(number: number): boolean;\n        isSafeInteger(number: number): boolean;\n        MAX_SAFE_INTEGER: number;\n        MIN_SAFE_INTEGER: number;\n        parseFloat(string: string): number;\n        parseInt(string: string, radix?: number): number;\n        clz32(x: number): number;\n        imul(x: number, y: number): number;\n        sign(x: number): number;\n        log10(x: number): number;\n        log2(x: number): number;\n        log1p(x: number): number;\n        expm1(x: number): number;\n        cosh(x: number): number;\n        sinh(x: number): number;\n        tanh(x: number): number;\n        acosh(x: number): number;\n        asinh(x: number): number;\n        atanh(x: number): number;\n        hypot(...values: number[]): number;\n        trunc(x: number): number;\n        fround(x: number): number;\n        cbrt(x: number): number;\n        random(lim?: number): number;\n    };\n\n    const Math: {\n        clz32(x: number): number;\n        imul(x: number, y: number): number;\n        sign(x: number): number;\n        log10(x: number): number;\n        log2(x: number): number;\n        log1p(x: number): number;\n        expm1(x: number): number;\n        cosh(x: number): number;\n        sinh(x: number): number;\n        tanh(x: number): number;\n        acosh(x: number): number;\n        asinh(x: number): number;\n        atanh(x: number): number;\n        hypot(...values: number[]): number;\n        trunc(x: number): number;\n        fround(x: number): number;\n        cbrt(x: number): number;\n    };\n\n    const RegExp: {\n        escape(str: string): string;\n    };\n\n    const Map: MapConstructor;\n    const Set: SetConstructor;\n    const WeakMap: WeakMapConstructor;\n    const WeakSet: WeakSetConstructor;\n    const Promise: PromiseConstructor;\n    const Symbol: SymbolConstructor;\n    const Dict: DictConstructor;\n    const global: any;\n    const log: Log;\n    const _: boolean;\n\n    function setTimeout(handler: any, timeout?: any, ...args: any[]): number;\n\n    function setInterval(handler: any, timeout?: any, ...args: any[]): number;\n\n    function setImmediate(expression: any, ...args: any[]): number;\n\n    function clearImmediate(handle: number): void;\n\n    function $for<T>(iterable: Iterable<T>): $for<T>;\n\n    function isIterable(value: any): boolean;\n\n    function getIterator<T>(iterable: Iterable<T>): Iterator<T>;\n\n    interface Locale {\n        weekdays: string;\n        months: string;\n    }\n\n    function addLocale(lang: string, locale: Locale): typeof core;\n\n    function locale(lang?: string): string;\n\n    function delay(msec: number): Promise<void>;\n}\n\ndeclare module \"core-js\" {\n    export = core;\n}\ndeclare module \"core-js/shim\" {\n    export = core;\n}\ndeclare module \"core-js/core\" {\n    export = core;\n}\ndeclare module \"core-js/core/$for\" {\n    import $for = core.$for;\n    export = $for;\n}\ndeclare module \"core-js/core/_\" {\n    const _: typeof core._;\n    export = _;\n}\ndeclare module \"core-js/core/array\" {\n    const Array: typeof core.Array;\n    export = Array;\n}\ndeclare module \"core-js/core/date\" {\n    const Date: typeof core.Date;\n    export = Date;\n}\ndeclare module \"core-js/core/delay\" {\n    const delay: typeof core.delay;\n    export = delay;\n}\ndeclare module \"core-js/core/dict\" {\n    const Dict: typeof core.Dict;\n    export = Dict;\n}\ndeclare module \"core-js/core/function\" {\n    const Function: typeof core.Function;\n    export = Function;\n}\ndeclare module \"core-js/core/global\" {\n    const global: typeof core.global;\n    export = global;\n}\ndeclare module \"core-js/core/log\" {\n    const log: typeof core.log;\n    export = log;\n}\ndeclare module \"core-js/core/number\" {\n    const Number: typeof core.Number;\n    export = Number;\n}\ndeclare module \"core-js/core/object\" {\n    const Object: typeof core.Object;\n    export = Object;\n}\ndeclare module \"core-js/core/string\" {\n    const String: typeof core.String;\n    export = String;\n}\ndeclare module \"core-js/fn/$for\" {\n    import $for = core.$for;\n    export = $for;\n}\ndeclare module \"core-js/fn/_\" {\n    const _: typeof core._;\n    export = _;\n}\ndeclare module \"core-js/fn/clear-immediate\" {\n    const clearImmediate: typeof core.clearImmediate;\n    export = clearImmediate;\n}\ndeclare module \"core-js/fn/delay\" {\n    const delay: typeof core.delay;\n    export = delay;\n}\ndeclare module \"core-js/fn/dict\" {\n    const Dict: typeof core.Dict;\n    export = Dict;\n}\ndeclare module \"core-js/fn/get-iterator\" {\n    const getIterator: typeof core.getIterator;\n    export = getIterator;\n}\ndeclare module \"core-js/fn/global\" {\n    const global: typeof core.global;\n    export = global;\n}\ndeclare module \"core-js/fn/is-iterable\" {\n    const isIterable: typeof core.isIterable;\n    export = isIterable;\n}\ndeclare module \"core-js/fn/log\" {\n    const log: typeof core.log;\n    export = log;\n}\ndeclare module \"core-js/fn/map\" {\n    const Map: typeof core.Map;\n    export = Map;\n}\ndeclare module \"core-js/fn/promise\" {\n    const Promise: typeof core.Promise;\n    export = Promise;\n}\ndeclare module \"core-js/fn/set\" {\n    const Set: typeof core.Set;\n    export = Set;\n}\ndeclare module \"core-js/fn/set-immediate\" {\n    const setImmediate: typeof core.setImmediate;\n    export = setImmediate;\n}\ndeclare module \"core-js/fn/set-interval\" {\n    const setInterval: typeof core.setInterval;\n    export = setInterval;\n}\ndeclare module \"core-js/fn/set-timeout\" {\n    const setTimeout: typeof core.setTimeout;\n    export = setTimeout;\n}\ndeclare module \"core-js/fn/weak-map\" {\n    const WeakMap: typeof core.WeakMap;\n    export = WeakMap;\n}\ndeclare module \"core-js/fn/weak-set\" {\n    const WeakSet: typeof core.WeakSet;\n    export = WeakSet;\n}\ndeclare module \"core-js/fn/array\" {\n    const Array: typeof core.Array;\n    export = Array;\n}\ndeclare module \"core-js/fn/array/concat\" {\n    const concat: typeof core.Array.concat;\n    export = concat;\n}\ndeclare module \"core-js/fn/array/copy-within\" {\n    const copyWithin: typeof core.Array.copyWithin;\n    export = copyWithin;\n}\ndeclare module \"core-js/fn/array/entries\" {\n    const entries: typeof core.Array.entries;\n    export = entries;\n}\ndeclare module \"core-js/fn/array/every\" {\n    const every: typeof core.Array.every;\n    export = every;\n}\ndeclare module \"core-js/fn/array/fill\" {\n    const fill: typeof core.Array.fill;\n    export = fill;\n}\ndeclare module \"core-js/fn/array/filter\" {\n    const filter: typeof core.Array.filter;\n    export = filter;\n}\ndeclare module \"core-js/fn/array/find\" {\n    const find: typeof core.Array.find;\n    export = find;\n}\ndeclare module \"core-js/fn/array/find-index\" {\n    const findIndex: typeof core.Array.findIndex;\n    export = findIndex;\n}\ndeclare module \"core-js/fn/array/for-each\" {\n    const forEach: typeof core.Array.forEach;\n    export = forEach;\n}\ndeclare module \"core-js/fn/array/from\" {\n    const from: typeof core.Array.from;\n    export = from;\n}\ndeclare module \"core-js/fn/array/includes\" {\n    const includes: typeof core.Array.includes;\n    export = includes;\n}\ndeclare module \"core-js/fn/array/index-of\" {\n    const indexOf: typeof core.Array.indexOf;\n    export = indexOf;\n}\ndeclare module \"core-js/fn/array/join\" {\n    const join: typeof core.Array.join;\n    export = join;\n}\ndeclare module \"core-js/fn/array/keys\" {\n    const keys: typeof core.Array.keys;\n    export = keys;\n}\ndeclare module \"core-js/fn/array/last-index-of\" {\n    const lastIndexOf: typeof core.Array.lastIndexOf;\n    export = lastIndexOf;\n}\ndeclare module \"core-js/fn/array/map\" {\n    const map: typeof core.Array.map;\n    export = map;\n}\ndeclare module \"core-js/fn/array/of\" {\n    const of: typeof core.Array.of;\n    export = of;\n}\ndeclare module \"core-js/fn/array/pop\" {\n    const pop: typeof core.Array.pop;\n    export = pop;\n}\ndeclare module \"core-js/fn/array/push\" {\n    const push: typeof core.Array.push;\n    export = push;\n}\ndeclare module \"core-js/fn/array/reduce\" {\n    const reduce: typeof core.Array.reduce;\n    export = reduce;\n}\ndeclare module \"core-js/fn/array/reduce-right\" {\n    const reduceRight: typeof core.Array.reduceRight;\n    export = reduceRight;\n}\ndeclare module \"core-js/fn/array/reverse\" {\n    const reverse: typeof core.Array.reverse;\n    export = reverse;\n}\ndeclare module \"core-js/fn/array/shift\" {\n    const shift: typeof core.Array.shift;\n    export = shift;\n}\ndeclare module \"core-js/fn/array/slice\" {\n    const slice: typeof core.Array.slice;\n    export = slice;\n}\ndeclare module \"core-js/fn/array/some\" {\n    const some: typeof core.Array.some;\n    export = some;\n}\ndeclare module \"core-js/fn/array/sort\" {\n    const sort: typeof core.Array.sort;\n    export = sort;\n}\ndeclare module \"core-js/fn/array/splice\" {\n    const splice: typeof core.Array.splice;\n    export = splice;\n}\ndeclare module \"core-js/fn/array/turn\" {\n    const turn: typeof core.Array.turn;\n    export = turn;\n}\ndeclare module \"core-js/fn/array/unshift\" {\n    const unshift: typeof core.Array.unshift;\n    export = unshift;\n}\ndeclare module \"core-js/fn/array/values\" {\n    const values: typeof core.Array.values;\n    export = values;\n}\ndeclare module \"core-js/fn/date\" {\n    const Date: typeof core.Date;\n    export = Date;\n}\ndeclare module \"core-js/fn/date/add-locale\" {\n    const addLocale: typeof core.addLocale;\n    export = addLocale;\n}\ndeclare module \"core-js/fn/date/format\" {\n    const format: typeof core.Date.format;\n    export = format;\n}\ndeclare module \"core-js/fn/date/formatUTC\" {\n    const formatUTC: typeof core.Date.formatUTC;\n    export = formatUTC;\n}\ndeclare module \"core-js/fn/function\" {\n    const Function: typeof core.Function;\n    export = Function;\n}\ndeclare module \"core-js/fn/function/has-instance\" {\n    function hasInstance(value: any): boolean;\n    export = hasInstance;\n}\ndeclare module \"core-js/fn/function/name\" {\n}\ndeclare module \"core-js/fn/function/part\" {\n    const part: typeof core.Function.part;\n    export = part;\n}\ndeclare module \"core-js/fn/math\" {\n    const Math: typeof core.Math;\n    export = Math;\n}\ndeclare module \"core-js/fn/math/acosh\" {\n    const acosh: typeof core.Math.acosh;\n    export = acosh;\n}\ndeclare module \"core-js/fn/math/asinh\" {\n    const asinh: typeof core.Math.asinh;\n    export = asinh;\n}\ndeclare module \"core-js/fn/math/atanh\" {\n    const atanh: typeof core.Math.atanh;\n    export = atanh;\n}\ndeclare module \"core-js/fn/math/cbrt\" {\n    const cbrt: typeof core.Math.cbrt;\n    export = cbrt;\n}\ndeclare module \"core-js/fn/math/clz32\" {\n    const clz32: typeof core.Math.clz32;\n    export = clz32;\n}\ndeclare module \"core-js/fn/math/cosh\" {\n    const cosh: typeof core.Math.cosh;\n    export = cosh;\n}\ndeclare module \"core-js/fn/math/expm1\" {\n    const expm1: typeof core.Math.expm1;\n    export = expm1;\n}\ndeclare module \"core-js/fn/math/fround\" {\n    const fround: typeof core.Math.fround;\n    export = fround;\n}\ndeclare module \"core-js/fn/math/hypot\" {\n    const hypot: typeof core.Math.hypot;\n    export = hypot;\n}\ndeclare module \"core-js/fn/math/imul\" {\n    const imul: typeof core.Math.imul;\n    export = imul;\n}\ndeclare module \"core-js/fn/math/log10\" {\n    const log10: typeof core.Math.log10;\n    export = log10;\n}\ndeclare module \"core-js/fn/math/log1p\" {\n    const log1p: typeof core.Math.log1p;\n    export = log1p;\n}\ndeclare module \"core-js/fn/math/log2\" {\n    const log2: typeof core.Math.log2;\n    export = log2;\n}\ndeclare module \"core-js/fn/math/sign\" {\n    const sign: typeof core.Math.sign;\n    export = sign;\n}\ndeclare module \"core-js/fn/math/sinh\" {\n    const sinh: typeof core.Math.sinh;\n    export = sinh;\n}\ndeclare module \"core-js/fn/math/tanh\" {\n    const tanh: typeof core.Math.tanh;\n    export = tanh;\n}\ndeclare module \"core-js/fn/math/trunc\" {\n    const trunc: typeof core.Math.trunc;\n    export = trunc;\n}\ndeclare module \"core-js/fn/number\" {\n    const Number: typeof core.Number;\n    export = Number;\n}\ndeclare module \"core-js/fn/number/epsilon\" {\n    const EPSILON: typeof core.Number.EPSILON;\n    export = EPSILON;\n}\ndeclare module \"core-js/fn/number/is-finite\" {\n    const isFinite: typeof core.Number.isFinite;\n    export = isFinite;\n}\ndeclare module \"core-js/fn/number/is-integer\" {\n    const isInteger: typeof core.Number.isInteger;\n    export = isInteger;\n}\ndeclare module \"core-js/fn/number/is-nan\" {\n    const isNaN: typeof core.Number.isNaN;\n    export = isNaN;\n}\ndeclare module \"core-js/fn/number/is-safe-integer\" {\n    const isSafeInteger: typeof core.Number.isSafeInteger;\n    export = isSafeInteger;\n}\ndeclare module \"core-js/fn/number/max-safe-integer\" {\n    const MAX_SAFE_INTEGER: typeof core.Number.MAX_SAFE_INTEGER;\n    export = MAX_SAFE_INTEGER;\n}\ndeclare module \"core-js/fn/number/min-safe-integer\" {\n    const MIN_SAFE_INTEGER: typeof core.Number.MIN_SAFE_INTEGER;\n    export = MIN_SAFE_INTEGER;\n}\ndeclare module \"core-js/fn/number/parse-float\" {\n    const parseFloat: typeof core.Number.parseFloat;\n    export = parseFloat;\n}\ndeclare module \"core-js/fn/number/parse-int\" {\n    const parseInt: typeof core.Number.parseInt;\n    export = parseInt;\n}\ndeclare module \"core-js/fn/number/random\" {\n    const random: typeof core.Number.random;\n    export = random;\n}\ndeclare module \"core-js/fn/object\" {\n    const Object: typeof core.Object;\n    export = Object;\n}\ndeclare module \"core-js/fn/object/assign\" {\n    const assign: typeof core.Object.assign;\n    export = assign;\n}\ndeclare module \"core-js/fn/object/classof\" {\n    const classof: typeof core.Object.classof;\n    export = classof;\n}\ndeclare module \"core-js/fn/object/create\" {\n    const create: typeof core.Object.create;\n    export = create;\n}\ndeclare module \"core-js/fn/object/define\" {\n    const define: typeof core.Object.define;\n    export = define;\n}\ndeclare module \"core-js/fn/object/define-properties\" {\n    const defineProperties: typeof core.Object.defineProperties;\n    export = defineProperties;\n}\ndeclare module \"core-js/fn/object/define-property\" {\n    const defineProperty: typeof core.Object.defineProperty;\n    export = defineProperty;\n}\ndeclare module \"core-js/fn/object/entries\" {\n    const entries: typeof core.Object.entries;\n    export = entries;\n}\ndeclare module \"core-js/fn/object/freeze\" {\n    const freeze: typeof core.Object.freeze;\n    export = freeze;\n}\ndeclare module \"core-js/fn/object/get-own-property-descriptor\" {\n    const getOwnPropertyDescriptor: typeof core.Object.getOwnPropertyDescriptor;\n    export = getOwnPropertyDescriptor;\n}\ndeclare module \"core-js/fn/object/get-own-property-descriptors\" {\n    const getOwnPropertyDescriptors: typeof core.Object.getOwnPropertyDescriptors;\n    export = getOwnPropertyDescriptors;\n}\ndeclare module \"core-js/fn/object/get-own-property-names\" {\n    const getOwnPropertyNames: typeof core.Object.getOwnPropertyNames;\n    export = getOwnPropertyNames;\n}\ndeclare module \"core-js/fn/object/get-own-property-symbols\" {\n    const getOwnPropertySymbols: typeof core.Object.getOwnPropertySymbols;\n    export = getOwnPropertySymbols;\n}\ndeclare module \"core-js/fn/object/get-prototype-of\" {\n    const getPrototypeOf: typeof core.Object.getPrototypeOf;\n    export = getPrototypeOf;\n}\ndeclare module \"core-js/fn/object/is\" {\n    const is: typeof core.Object.is;\n    export = is;\n}\ndeclare module \"core-js/fn/object/is-extensible\" {\n    const isExtensible: typeof core.Object.isExtensible;\n    export = isExtensible;\n}\ndeclare module \"core-js/fn/object/is-frozen\" {\n    const isFrozen: typeof core.Object.isFrozen;\n    export = isFrozen;\n}\ndeclare module \"core-js/fn/object/is-object\" {\n    const isObject: typeof core.Object.isObject;\n    export = isObject;\n}\ndeclare module \"core-js/fn/object/is-sealed\" {\n    const isSealed: typeof core.Object.isSealed;\n    export = isSealed;\n}\ndeclare module \"core-js/fn/object/keys\" {\n    const keys: typeof core.Object.keys;\n    export = keys;\n}\ndeclare module \"core-js/fn/object/make\" {\n    const make: typeof core.Object.make;\n    export = make;\n}\ndeclare module \"core-js/fn/object/prevent-extensions\" {\n    const preventExtensions: typeof core.Object.preventExtensions;\n    export = preventExtensions;\n}\ndeclare module \"core-js/fn/object/seal\" {\n    const seal: typeof core.Object.seal;\n    export = seal;\n}\ndeclare module \"core-js/fn/object/set-prototype-of\" {\n    const setPrototypeOf: typeof core.Object.setPrototypeOf;\n    export = setPrototypeOf;\n}\ndeclare module \"core-js/fn/object/values\" {\n    const values: typeof core.Object.values;\n    export = values;\n}\ndeclare module \"core-js/fn/reflect\" {\n    const Reflect: typeof core.Reflect;\n    export = Reflect;\n}\ndeclare module \"core-js/fn/reflect/apply\" {\n    const apply: typeof core.Reflect.apply;\n    export = apply;\n}\ndeclare module \"core-js/fn/reflect/construct\" {\n    const construct: typeof core.Reflect.construct;\n    export = construct;\n}\ndeclare module \"core-js/fn/reflect/define-property\" {\n    const defineProperty: typeof core.Reflect.defineProperty;\n    export = defineProperty;\n}\ndeclare module \"core-js/fn/reflect/delete-property\" {\n    const deleteProperty: typeof core.Reflect.deleteProperty;\n    export = deleteProperty;\n}\ndeclare module \"core-js/fn/reflect/enumerate\" {\n    const enumerate: typeof core.Reflect.enumerate;\n    export = enumerate;\n}\ndeclare module \"core-js/fn/reflect/get\" {\n    const get: typeof core.Reflect.get;\n    export = get;\n}\ndeclare module \"core-js/fn/reflect/get-own-property-descriptor\" {\n    const getOwnPropertyDescriptor: typeof core.Reflect.getOwnPropertyDescriptor;\n    export = getOwnPropertyDescriptor;\n}\ndeclare module \"core-js/fn/reflect/get-prototype-of\" {\n    const getPrototypeOf: typeof core.Reflect.getPrototypeOf;\n    export = getPrototypeOf;\n}\ndeclare module \"core-js/fn/reflect/has\" {\n    const has: typeof core.Reflect.has;\n    export = has;\n}\ndeclare module \"core-js/fn/reflect/is-extensible\" {\n    const isExtensible: typeof core.Reflect.isExtensible;\n    export = isExtensible;\n}\ndeclare module \"core-js/fn/reflect/own-keys\" {\n    const ownKeys: typeof core.Reflect.ownKeys;\n    export = ownKeys;\n}\ndeclare module \"core-js/fn/reflect/prevent-extensions\" {\n    const preventExtensions: typeof core.Reflect.preventExtensions;\n    export = preventExtensions;\n}\ndeclare module \"core-js/fn/reflect/set\" {\n    const set: typeof core.Reflect.set;\n    export = set;\n}\ndeclare module \"core-js/fn/reflect/set-prototype-of\" {\n    const setPrototypeOf: typeof core.Reflect.setPrototypeOf;\n    export = setPrototypeOf;\n}\ndeclare module \"core-js/fn/regexp\" {\n    const RegExp: typeof core.RegExp;\n    export = RegExp;\n}\ndeclare module \"core-js/fn/regexp/escape\" {\n    const escape: typeof core.RegExp.escape;\n    export = escape;\n}\ndeclare module \"core-js/fn/string\" {\n    const String: typeof core.String;\n    export = String;\n}\ndeclare module \"core-js/fn/string/at\" {\n    const at: typeof core.String.at;\n    export = at;\n}\ndeclare module \"core-js/fn/string/code-point-at\" {\n    const codePointAt: typeof core.String.codePointAt;\n    export = codePointAt;\n}\ndeclare module \"core-js/fn/string/ends-with\" {\n    const endsWith: typeof core.String.endsWith;\n    export = endsWith;\n}\ndeclare module \"core-js/fn/string/escape-html\" {\n    const escapeHTML: typeof core.String.escapeHTML;\n    export = escapeHTML;\n}\ndeclare module \"core-js/fn/string/from-code-point\" {\n    const fromCodePoint: typeof core.String.fromCodePoint;\n    export = fromCodePoint;\n}\ndeclare module \"core-js/fn/string/includes\" {\n    const includes: typeof core.String.includes;\n    export = includes;\n}\ndeclare module \"core-js/fn/string/lpad\" {\n    const lpad: typeof core.String.lpad;\n    export = lpad;\n}\ndeclare module \"core-js/fn/string/raw\" {\n    const raw: typeof core.String.raw;\n    export = raw;\n}\ndeclare module \"core-js/fn/string/repeat\" {\n    const repeat: typeof core.String.repeat;\n    export = repeat;\n}\ndeclare module \"core-js/fn/string/rpad\" {\n    const rpad: typeof core.String.rpad;\n    export = rpad;\n}\ndeclare module \"core-js/fn/string/starts-with\" {\n    const startsWith: typeof core.String.startsWith;\n    export = startsWith;\n}\ndeclare module \"core-js/fn/string/unescape-html\" {\n    const unescapeHTML: typeof core.String.unescapeHTML;\n    export = unescapeHTML;\n}\ndeclare module \"core-js/fn/symbol\" {\n    const Symbol: typeof core.Symbol;\n    export = Symbol;\n}\ndeclare module \"core-js/fn/symbol/for\" {\n    const _for: typeof core.Symbol.for;\n    export = _for;\n}\ndeclare module \"core-js/fn/symbol/has-instance\" {\n    const hasInstance: typeof core.Symbol.hasInstance;\n    export = hasInstance;\n}\ndeclare module \"core-js/fn/symbol/is-concat-spreadable\" {\n    const isConcatSpreadable: typeof core.Symbol.isConcatSpreadable;\n    export = isConcatSpreadable;\n}\ndeclare module \"core-js/fn/symbol/iterator\" {\n    const iterator: typeof core.Symbol.iterator;\n    export = iterator;\n}\ndeclare module \"core-js/fn/symbol/key-for\" {\n    const keyFor: typeof core.Symbol.keyFor;\n    export = keyFor;\n}\ndeclare module \"core-js/fn/symbol/match\" {\n    const match: typeof core.Symbol.match;\n    export = match;\n}\ndeclare module \"core-js/fn/symbol/replace\" {\n    const replace: typeof core.Symbol.replace;\n    export = replace;\n}\ndeclare module \"core-js/fn/symbol/search\" {\n    const search: typeof core.Symbol.search;\n    export = search;\n}\ndeclare module \"core-js/fn/symbol/species\" {\n    const species: typeof core.Symbol.species;\n    export = species;\n}\ndeclare module \"core-js/fn/symbol/split\" {\n    const split: typeof core.Symbol.split;\n    export = split;\n}\ndeclare module \"core-js/fn/symbol/to-primitive\" {\n    const toPrimitive: typeof core.Symbol.toPrimitive;\n    export = toPrimitive;\n}\ndeclare module \"core-js/fn/symbol/to-string-tag\" {\n    const toStringTag: typeof core.Symbol.toStringTag;\n    export = toStringTag;\n}\ndeclare module \"core-js/fn/symbol/unscopables\" {\n    const unscopables: typeof core.Symbol.unscopables;\n    export = unscopables;\n}\ndeclare module \"core-js/es5\" {\n    export = core;\n}\ndeclare module \"core-js/es6\" {\n    export = core;\n}\ndeclare module \"core-js/es6/array\" {\n    const Array: typeof core.Array;\n    export = Array;\n}\ndeclare module \"core-js/es6/function\" {\n    const Function: typeof core.Function;\n    export = Function;\n}\ndeclare module \"core-js/es6/map\" {\n    const Map: typeof core.Map;\n    export = Map;\n}\ndeclare module \"core-js/es6/math\" {\n    const Math: typeof core.Math;\n    export = Math;\n}\ndeclare module \"core-js/es6/number\" {\n    const Number: typeof core.Number;\n    export = Number;\n}\ndeclare module \"core-js/es6/object\" {\n    const Object: typeof core.Object;\n    export = Object;\n}\ndeclare module \"core-js/es6/promise\" {\n    const Promise: typeof core.Promise;\n    export = Promise;\n}\ndeclare module \"core-js/es6/reflect\" {\n    const Reflect: typeof core.Reflect;\n    export = Reflect;\n}\ndeclare module \"core-js/es6/regexp\" {\n    const RegExp: typeof core.RegExp;\n    export = RegExp;\n}\ndeclare module \"core-js/es6/set\" {\n    const Set: typeof core.Set;\n    export = Set;\n}\ndeclare module \"core-js/es6/string\" {\n    const String: typeof core.String;\n    export = String;\n}\ndeclare module \"core-js/es6/symbol\" {\n    const Symbol: typeof core.Symbol;\n    export = Symbol;\n}\ndeclare module \"core-js/es6/weak-map\" {\n    const WeakMap: typeof core.WeakMap;\n    export = WeakMap;\n}\ndeclare module \"core-js/es6/weak-set\" {\n    const WeakSet: typeof core.WeakSet;\n    export = WeakSet;\n}\ndeclare module \"core-js/es7\" {\n    export = core;\n}\ndeclare module \"core-js/es7/array\" {\n    const Array: typeof core.Array;\n    export = Array;\n}\ndeclare module \"core-js/es7/map\" {\n    const Map: typeof core.Map;\n    export = Map;\n}\ndeclare module \"core-js/es7/object\" {\n    const Object: typeof core.Object;\n    export = Object;\n}\ndeclare module \"core-js/es7/regexp\" {\n    const RegExp: typeof core.RegExp;\n    export = RegExp;\n}\ndeclare module \"core-js/es7/set\" {\n    const Set: typeof core.Set;\n    export = Set;\n}\ndeclare module \"core-js/es7/string\" {\n    const String: typeof core.String;\n    export = String;\n}\ndeclare module \"core-js/js\" {\n    export = core;\n}\ndeclare module \"core-js/js/array\" {\n    const Array: typeof core.Array;\n    export = Array;\n}\ndeclare module \"core-js/web\" {\n    export = core;\n}\ndeclare module \"core-js/web/dom\" {\n    export = core;\n}\ndeclare module \"core-js/web/immediate\" {\n    export = core;\n}\ndeclare module \"core-js/web/timers\" {\n    export = core;\n}\ndeclare module \"core-js/library\" {\n    export = core;\n}\ndeclare module \"core-js/library/shim\" {\n    export = core;\n}\ndeclare module \"core-js/library/core\" {\n    export = core;\n}\ndeclare module \"core-js/library/core/$for\" {\n    import $for = core.$for;\n    export = $for;\n}\ndeclare module \"core-js/library/core/_\" {\n    const _: typeof core._;\n    export = _;\n}\ndeclare module \"core-js/library/core/array\" {\n    const Array: typeof core.Array;\n    export = Array;\n}\ndeclare module \"core-js/library/core/date\" {\n    const Date: typeof core.Date;\n    export = Date;\n}\ndeclare module \"core-js/library/core/delay\" {\n    const delay: typeof core.delay;\n    export = delay;\n}\ndeclare module \"core-js/library/core/dict\" {\n    const Dict: typeof core.Dict;\n    export = Dict;\n}\ndeclare module \"core-js/library/core/function\" {\n    const Function: typeof core.Function;\n    export = Function;\n}\ndeclare module \"core-js/library/core/global\" {\n    const global: typeof core.global;\n    export = global;\n}\ndeclare module \"core-js/library/core/log\" {\n    const log: typeof core.log;\n    export = log;\n}\ndeclare module \"core-js/library/core/number\" {\n    const Number: typeof core.Number;\n    export = Number;\n}\ndeclare module \"core-js/library/core/object\" {\n    const Object: typeof core.Object;\n    export = Object;\n}\ndeclare module \"core-js/library/core/string\" {\n    const String: typeof core.String;\n    export = String;\n}\ndeclare module \"core-js/library/fn/$for\" {\n    import $for = core.$for;\n    export = $for;\n}\ndeclare module \"core-js/library/fn/_\" {\n    const _: typeof core._;\n    export = _;\n}\ndeclare module \"core-js/library/fn/clear-immediate\" {\n    const clearImmediate: typeof core.clearImmediate;\n    export = clearImmediate;\n}\ndeclare module \"core-js/library/fn/delay\" {\n    const delay: typeof core.delay;\n    export = delay;\n}\ndeclare module \"core-js/library/fn/dict\" {\n    const Dict: typeof core.Dict;\n    export = Dict;\n}\ndeclare module \"core-js/library/fn/get-iterator\" {\n    const getIterator: typeof core.getIterator;\n    export = getIterator;\n}\ndeclare module \"core-js/library/fn/global\" {\n    const global: typeof core.global;\n    export = global;\n}\ndeclare module \"core-js/library/fn/is-iterable\" {\n    const isIterable: typeof core.isIterable;\n    export = isIterable;\n}\ndeclare module \"core-js/library/fn/log\" {\n    const log: typeof core.log;\n    export = log;\n}\ndeclare module \"core-js/library/fn/map\" {\n    const Map: typeof core.Map;\n    export = Map;\n}\ndeclare module \"core-js/library/fn/promise\" {\n    const Promise: typeof core.Promise;\n    export = Promise;\n}\ndeclare module \"core-js/library/fn/set\" {\n    const Set: typeof core.Set;\n    export = Set;\n}\ndeclare module \"core-js/library/fn/set-immediate\" {\n    const setImmediate: typeof core.setImmediate;\n    export = setImmediate;\n}\ndeclare module \"core-js/library/fn/set-interval\" {\n    const setInterval: typeof core.setInterval;\n    export = setInterval;\n}\ndeclare module \"core-js/library/fn/set-timeout\" {\n    const setTimeout: typeof core.setTimeout;\n    export = setTimeout;\n}\ndeclare module \"core-js/library/fn/weak-map\" {\n    const WeakMap: typeof core.WeakMap;\n    export = WeakMap;\n}\ndeclare module \"core-js/library/fn/weak-set\" {\n    const WeakSet: typeof core.WeakSet;\n    export = WeakSet;\n}\ndeclare module \"core-js/library/fn/array\" {\n    const Array: typeof core.Array;\n    export = Array;\n}\ndeclare module \"core-js/library/fn/array/concat\" {\n    const concat: typeof core.Array.concat;\n    export = concat;\n}\ndeclare module \"core-js/library/fn/array/copy-within\" {\n    const copyWithin: typeof core.Array.copyWithin;\n    export = copyWithin;\n}\ndeclare module \"core-js/library/fn/array/entries\" {\n    const entries: typeof core.Array.entries;\n    export = entries;\n}\ndeclare module \"core-js/library/fn/array/every\" {\n    const every: typeof core.Array.every;\n    export = every;\n}\ndeclare module \"core-js/library/fn/array/fill\" {\n    const fill: typeof core.Array.fill;\n    export = fill;\n}\ndeclare module \"core-js/library/fn/array/filter\" {\n    const filter: typeof core.Array.filter;\n    export = filter;\n}\ndeclare module \"core-js/library/fn/array/find\" {\n    const find: typeof core.Array.find;\n    export = find;\n}\ndeclare module \"core-js/library/fn/array/find-index\" {\n    const findIndex: typeof core.Array.findIndex;\n    export = findIndex;\n}\ndeclare module \"core-js/library/fn/array/for-each\" {\n    const forEach: typeof core.Array.forEach;\n    export = forEach;\n}\ndeclare module \"core-js/library/fn/array/from\" {\n    const from: typeof core.Array.from;\n    export = from;\n}\ndeclare module \"core-js/library/fn/array/includes\" {\n    const includes: typeof core.Array.includes;\n    export = includes;\n}\ndeclare module \"core-js/library/fn/array/index-of\" {\n    const indexOf: typeof core.Array.indexOf;\n    export = indexOf;\n}\ndeclare module \"core-js/library/fn/array/join\" {\n    const join: typeof core.Array.join;\n    export = join;\n}\ndeclare module \"core-js/library/fn/array/keys\" {\n    const keys: typeof core.Array.keys;\n    export = keys;\n}\ndeclare module \"core-js/library/fn/array/last-index-of\" {\n    const lastIndexOf: typeof core.Array.lastIndexOf;\n    export = lastIndexOf;\n}\ndeclare module \"core-js/library/fn/array/map\" {\n    const map: typeof core.Array.map;\n    export = map;\n}\ndeclare module \"core-js/library/fn/array/of\" {\n    const of: typeof core.Array.of;\n    export = of;\n}\ndeclare module \"core-js/library/fn/array/pop\" {\n    const pop: typeof core.Array.pop;\n    export = pop;\n}\ndeclare module \"core-js/library/fn/array/push\" {\n    const push: typeof core.Array.push;\n    export = push;\n}\ndeclare module \"core-js/library/fn/array/reduce\" {\n    const reduce: typeof core.Array.reduce;\n    export = reduce;\n}\ndeclare module \"core-js/library/fn/array/reduce-right\" {\n    const reduceRight: typeof core.Array.reduceRight;\n    export = reduceRight;\n}\ndeclare module \"core-js/library/fn/array/reverse\" {\n    const reverse: typeof core.Array.reverse;\n    export = reverse;\n}\ndeclare module \"core-js/library/fn/array/shift\" {\n    const shift: typeof core.Array.shift;\n    export = shift;\n}\ndeclare module \"core-js/library/fn/array/slice\" {\n    const slice: typeof core.Array.slice;\n    export = slice;\n}\ndeclare module \"core-js/library/fn/array/some\" {\n    const some: typeof core.Array.some;\n    export = some;\n}\ndeclare module \"core-js/library/fn/array/sort\" {\n    const sort: typeof core.Array.sort;\n    export = sort;\n}\ndeclare module \"core-js/library/fn/array/splice\" {\n    const splice: typeof core.Array.splice;\n    export = splice;\n}\ndeclare module \"core-js/library/fn/array/turn\" {\n    const turn: typeof core.Array.turn;\n    export = turn;\n}\ndeclare module \"core-js/library/fn/array/unshift\" {\n    const unshift: typeof core.Array.unshift;\n    export = unshift;\n}\ndeclare module \"core-js/library/fn/array/values\" {\n    const values: typeof core.Array.values;\n    export = values;\n}\ndeclare module \"core-js/library/fn/date\" {\n    const Date: typeof core.Date;\n    export = Date;\n}\ndeclare module \"core-js/library/fn/date/add-locale\" {\n    const addLocale: typeof core.addLocale;\n    export = addLocale;\n}\ndeclare module \"core-js/library/fn/date/format\" {\n    const format: typeof core.Date.format;\n    export = format;\n}\ndeclare module \"core-js/library/fn/date/formatUTC\" {\n    const formatUTC: typeof core.Date.formatUTC;\n    export = formatUTC;\n}\ndeclare module \"core-js/library/fn/function\" {\n    const Function: typeof core.Function;\n    export = Function;\n}\ndeclare module \"core-js/library/fn/function/has-instance\" {\n    function hasInstance(value: any): boolean;\n    export = hasInstance;\n}\ndeclare module \"core-js/library/fn/function/name\" {\n}\ndeclare module \"core-js/library/fn/function/part\" {\n    const part: typeof core.Function.part;\n    export = part;\n}\ndeclare module \"core-js/library/fn/math\" {\n    const Math: typeof core.Math;\n    export = Math;\n}\ndeclare module \"core-js/library/fn/math/acosh\" {\n    const acosh: typeof core.Math.acosh;\n    export = acosh;\n}\ndeclare module \"core-js/library/fn/math/asinh\" {\n    const asinh: typeof core.Math.asinh;\n    export = asinh;\n}\ndeclare module \"core-js/library/fn/math/atanh\" {\n    const atanh: typeof core.Math.atanh;\n    export = atanh;\n}\ndeclare module \"core-js/library/fn/math/cbrt\" {\n    const cbrt: typeof core.Math.cbrt;\n    export = cbrt;\n}\ndeclare module \"core-js/library/fn/math/clz32\" {\n    const clz32: typeof core.Math.clz32;\n    export = clz32;\n}\ndeclare module \"core-js/library/fn/math/cosh\" {\n    const cosh: typeof core.Math.cosh;\n    export = cosh;\n}\ndeclare module \"core-js/library/fn/math/expm1\" {\n    const expm1: typeof core.Math.expm1;\n    export = expm1;\n}\ndeclare module \"core-js/library/fn/math/fround\" {\n    const fround: typeof core.Math.fround;\n    export = fround;\n}\ndeclare module \"core-js/library/fn/math/hypot\" {\n    const hypot: typeof core.Math.hypot;\n    export = hypot;\n}\ndeclare module \"core-js/library/fn/math/imul\" {\n    const imul: typeof core.Math.imul;\n    export = imul;\n}\ndeclare module \"core-js/library/fn/math/log10\" {\n    const log10: typeof core.Math.log10;\n    export = log10;\n}\ndeclare module \"core-js/library/fn/math/log1p\" {\n    const log1p: typeof core.Math.log1p;\n    export = log1p;\n}\ndeclare module \"core-js/library/fn/math/log2\" {\n    const log2: typeof core.Math.log2;\n    export = log2;\n}\ndeclare module \"core-js/library/fn/math/sign\" {\n    const sign: typeof core.Math.sign;\n    export = sign;\n}\ndeclare module \"core-js/library/fn/math/sinh\" {\n    const sinh: typeof core.Math.sinh;\n    export = sinh;\n}\ndeclare module \"core-js/library/fn/math/tanh\" {\n    const tanh: typeof core.Math.tanh;\n    export = tanh;\n}\ndeclare module \"core-js/library/fn/math/trunc\" {\n    const trunc: typeof core.Math.trunc;\n    export = trunc;\n}\ndeclare module \"core-js/library/fn/number\" {\n    const Number: typeof core.Number;\n    export = Number;\n}\ndeclare module \"core-js/library/fn/number/epsilon\" {\n    const EPSILON: typeof core.Number.EPSILON;\n    export = EPSILON;\n}\ndeclare module \"core-js/library/fn/number/is-finite\" {\n    const isFinite: typeof core.Number.isFinite;\n    export = isFinite;\n}\ndeclare module \"core-js/library/fn/number/is-integer\" {\n    const isInteger: typeof core.Number.isInteger;\n    export = isInteger;\n}\ndeclare module \"core-js/library/fn/number/is-nan\" {\n    const isNaN: typeof core.Number.isNaN;\n    export = isNaN;\n}\ndeclare module \"core-js/library/fn/number/is-safe-integer\" {\n    const isSafeInteger: typeof core.Number.isSafeInteger;\n    export = isSafeInteger;\n}\ndeclare module \"core-js/library/fn/number/max-safe-integer\" {\n    const MAX_SAFE_INTEGER: typeof core.Number.MAX_SAFE_INTEGER;\n    export = MAX_SAFE_INTEGER;\n}\ndeclare module \"core-js/library/fn/number/min-safe-integer\" {\n    const MIN_SAFE_INTEGER: typeof core.Number.MIN_SAFE_INTEGER;\n    export = MIN_SAFE_INTEGER;\n}\ndeclare module \"core-js/library/fn/number/parse-float\" {\n    const parseFloat: typeof core.Number.parseFloat;\n    export = parseFloat;\n}\ndeclare module \"core-js/library/fn/number/parse-int\" {\n    const parseInt: typeof core.Number.parseInt;\n    export = parseInt;\n}\ndeclare module \"core-js/library/fn/number/random\" {\n    const random: typeof core.Number.random;\n    export = random;\n}\ndeclare module \"core-js/library/fn/object\" {\n    const Object: typeof core.Object;\n    export = Object;\n}\ndeclare module \"core-js/library/fn/object/assign\" {\n    const assign: typeof core.Object.assign;\n    export = assign;\n}\ndeclare module \"core-js/library/fn/object/classof\" {\n    const classof: typeof core.Object.classof;\n    export = classof;\n}\ndeclare module \"core-js/library/fn/object/create\" {\n    const create: typeof core.Object.create;\n    export = create;\n}\ndeclare module \"core-js/library/fn/object/define\" {\n    const define: typeof core.Object.define;\n    export = define;\n}\ndeclare module \"core-js/library/fn/object/define-properties\" {\n    const defineProperties: typeof core.Object.defineProperties;\n    export = defineProperties;\n}\ndeclare module \"core-js/library/fn/object/define-property\" {\n    const defineProperty: typeof core.Object.defineProperty;\n    export = defineProperty;\n}\ndeclare module \"core-js/library/fn/object/entries\" {\n    const entries: typeof core.Object.entries;\n    export = entries;\n}\ndeclare module \"core-js/library/fn/object/freeze\" {\n    const freeze: typeof core.Object.freeze;\n    export = freeze;\n}\ndeclare module \"core-js/library/fn/object/get-own-property-descriptor\" {\n    const getOwnPropertyDescriptor: typeof core.Object.getOwnPropertyDescriptor;\n    export = getOwnPropertyDescriptor;\n}\ndeclare module \"core-js/library/fn/object/get-own-property-descriptors\" {\n    const getOwnPropertyDescriptors: typeof core.Object.getOwnPropertyDescriptors;\n    export = getOwnPropertyDescriptors;\n}\ndeclare module \"core-js/library/fn/object/get-own-property-names\" {\n    const getOwnPropertyNames: typeof core.Object.getOwnPropertyNames;\n    export = getOwnPropertyNames;\n}\ndeclare module \"core-js/library/fn/object/get-own-property-symbols\" {\n    const getOwnPropertySymbols: typeof core.Object.getOwnPropertySymbols;\n    export = getOwnPropertySymbols;\n}\ndeclare module \"core-js/library/fn/object/get-prototype-of\" {\n    const getPrototypeOf: typeof core.Object.getPrototypeOf;\n    export = getPrototypeOf;\n}\ndeclare module \"core-js/library/fn/object/is\" {\n    const is: typeof core.Object.is;\n    export = is;\n}\ndeclare module \"core-js/library/fn/object/is-extensible\" {\n    const isExtensible: typeof core.Object.isExtensible;\n    export = isExtensible;\n}\ndeclare module \"core-js/library/fn/object/is-frozen\" {\n    const isFrozen: typeof core.Object.isFrozen;\n    export = isFrozen;\n}\ndeclare module \"core-js/library/fn/object/is-object\" {\n    const isObject: typeof core.Object.isObject;\n    export = isObject;\n}\ndeclare module \"core-js/library/fn/object/is-sealed\" {\n    const isSealed: typeof core.Object.isSealed;\n    export = isSealed;\n}\ndeclare module \"core-js/library/fn/object/keys\" {\n    const keys: typeof core.Object.keys;\n    export = keys;\n}\ndeclare module \"core-js/library/fn/object/make\" {\n    const make: typeof core.Object.make;\n    export = make;\n}\ndeclare module \"core-js/library/fn/object/prevent-extensions\" {\n    const preventExtensions: typeof core.Object.preventExtensions;\n    export = preventExtensions;\n}\ndeclare module \"core-js/library/fn/object/seal\" {\n    const seal: typeof core.Object.seal;\n    export = seal;\n}\ndeclare module \"core-js/library/fn/object/set-prototype-of\" {\n    const setPrototypeOf: typeof core.Object.setPrototypeOf;\n    export = setPrototypeOf;\n}\ndeclare module \"core-js/library/fn/object/values\" {\n    const values: typeof core.Object.values;\n    export = values;\n}\ndeclare module \"core-js/library/fn/reflect\" {\n    const Reflect: typeof core.Reflect;\n    export = Reflect;\n}\ndeclare module \"core-js/library/fn/reflect/apply\" {\n    const apply: typeof core.Reflect.apply;\n    export = apply;\n}\ndeclare module \"core-js/library/fn/reflect/construct\" {\n    const construct: typeof core.Reflect.construct;\n    export = construct;\n}\ndeclare module \"core-js/library/fn/reflect/define-property\" {\n    const defineProperty: typeof core.Reflect.defineProperty;\n    export = defineProperty;\n}\ndeclare module \"core-js/library/fn/reflect/delete-property\" {\n    const deleteProperty: typeof core.Reflect.deleteProperty;\n    export = deleteProperty;\n}\ndeclare module \"core-js/library/fn/reflect/enumerate\" {\n    const enumerate: typeof core.Reflect.enumerate;\n    export = enumerate;\n}\ndeclare module \"core-js/library/fn/reflect/get\" {\n    const get: typeof core.Reflect.get;\n    export = get;\n}\ndeclare module \"core-js/library/fn/reflect/get-own-property-descriptor\" {\n    const getOwnPropertyDescriptor: typeof core.Reflect.getOwnPropertyDescriptor;\n    export = getOwnPropertyDescriptor;\n}\ndeclare module \"core-js/library/fn/reflect/get-prototype-of\" {\n    const getPrototypeOf: typeof core.Reflect.getPrototypeOf;\n    export = getPrototypeOf;\n}\ndeclare module \"core-js/library/fn/reflect/has\" {\n    const has: typeof core.Reflect.has;\n    export = has;\n}\ndeclare module \"core-js/library/fn/reflect/is-extensible\" {\n    const isExtensible: typeof core.Reflect.isExtensible;\n    export = isExtensible;\n}\ndeclare module \"core-js/library/fn/reflect/own-keys\" {\n    const ownKeys: typeof core.Reflect.ownKeys;\n    export = ownKeys;\n}\ndeclare module \"core-js/library/fn/reflect/prevent-extensions\" {\n    const preventExtensions: typeof core.Reflect.preventExtensions;\n    export = preventExtensions;\n}\ndeclare module \"core-js/library/fn/reflect/set\" {\n    const set: typeof core.Reflect.set;\n    export = set;\n}\ndeclare module \"core-js/library/fn/reflect/set-prototype-of\" {\n    const setPrototypeOf: typeof core.Reflect.setPrototypeOf;\n    export = setPrototypeOf;\n}\ndeclare module \"core-js/library/fn/reflect/es7/define-metadata\" {\n    const defineMetadata: typeof core.Reflect.defineMetadata;\n    export = defineMetadata;\n}\ndeclare module \"core-js/library/fn/reflect/es7/delete-metadata\" {\n    const deleteMetadata: typeof core.Reflect.deleteMetadata;\n    export = deleteMetadata;\n}\ndeclare module \"core-js/library/fn/reflect/es7/get-metadata\" {\n    const getMetadata: typeof core.Reflect.getMetadata;\n    export = getMetadata;\n}\ndeclare module \"core-js/library/fn/reflect/es7/get-metadata-keys\" {\n    const getMetadataKeys: typeof core.Reflect.getMetadataKeys;\n    export = getMetadataKeys;\n}\ndeclare module \"core-js/library/fn/reflect/es7/get-own-metadata\" {\n    const getOwnMetadata: typeof core.Reflect.getOwnMetadata;\n    export = getOwnMetadata;\n}\ndeclare module \"core-js/library/fn/reflect/es7/get-own-metadata-keys'\" {\n    const getOwnMetadataKeys: typeof core.Reflect.getOwnMetadataKeys;\n    export = getOwnMetadataKeys;\n}\ndeclare module \"core-js/library/fn/reflect/es7/has-metadata'\" {\n    const hasMetadata: typeof core.Reflect.hasMetadata;\n    export = hasMetadata;\n}\ndeclare module \"core-js/library/fn/reflect/es7/has-own-metadata'\" {\n    const hasOwnMetadata: typeof core.Reflect.hasOwnMetadata;\n    export = hasOwnMetadata;\n}\ndeclare module \"core-js/library/fn/reflect/es7/metadata'\" {\n    const metadata: typeof core.Reflect.metadata;\n    export = metadata;\n}\ndeclare module \"core-js/library/fn/regexp\" {\n    const RegExp: typeof core.RegExp;\n    export = RegExp;\n}\ndeclare module \"core-js/library/fn/regexp/escape\" {\n    const escape: typeof core.RegExp.escape;\n    export = escape;\n}\ndeclare module \"core-js/library/fn/string\" {\n    const String: typeof core.String;\n    export = String;\n}\ndeclare module \"core-js/library/fn/string/at\" {\n    const at: typeof core.String.at;\n    export = at;\n}\ndeclare module \"core-js/library/fn/string/code-point-at\" {\n    const codePointAt: typeof core.String.codePointAt;\n    export = codePointAt;\n}\ndeclare module \"core-js/library/fn/string/ends-with\" {\n    const endsWith: typeof core.String.endsWith;\n    export = endsWith;\n}\ndeclare module \"core-js/library/fn/string/escape-html\" {\n    const escapeHTML: typeof core.String.escapeHTML;\n    export = escapeHTML;\n}\ndeclare module \"core-js/library/fn/string/from-code-point\" {\n    const fromCodePoint: typeof core.String.fromCodePoint;\n    export = fromCodePoint;\n}\ndeclare module \"core-js/library/fn/string/includes\" {\n    const includes: typeof core.String.includes;\n    export = includes;\n}\ndeclare module \"core-js/library/fn/string/lpad\" {\n    const lpad: typeof core.String.lpad;\n    export = lpad;\n}\ndeclare module \"core-js/library/fn/string/raw\" {\n    const raw: typeof core.String.raw;\n    export = raw;\n}\ndeclare module \"core-js/library/fn/string/repeat\" {\n    const repeat: typeof core.String.repeat;\n    export = repeat;\n}\ndeclare module \"core-js/library/fn/string/rpad\" {\n    const rpad: typeof core.String.rpad;\n    export = rpad;\n}\ndeclare module \"core-js/library/fn/string/starts-with\" {\n    const startsWith: typeof core.String.startsWith;\n    export = startsWith;\n}\ndeclare module \"core-js/library/fn/string/unescape-html\" {\n    const unescapeHTML: typeof core.String.unescapeHTML;\n    export = unescapeHTML;\n}\ndeclare module \"core-js/library/fn/symbol\" {\n    const Symbol: typeof core.Symbol;\n    export = Symbol;\n}\ndeclare module \"core-js/library/fn/symbol/for\" {\n    const _for: typeof core.Symbol.for;\n    export = _for;\n}\ndeclare module \"core-js/library/fn/symbol/has-instance\" {\n    const hasInstance: typeof core.Symbol.hasInstance;\n    export = hasInstance;\n}\ndeclare module \"core-js/library/fn/symbol/is-concat-spreadable\" {\n    const isConcatSpreadable: typeof core.Symbol.isConcatSpreadable;\n    export = isConcatSpreadable;\n}\ndeclare module \"core-js/library/fn/symbol/iterator\" {\n    const iterator: typeof core.Symbol.iterator;\n    export = iterator;\n}\ndeclare module \"core-js/library/fn/symbol/key-for\" {\n    const keyFor: typeof core.Symbol.keyFor;\n    export = keyFor;\n}\ndeclare module \"core-js/library/fn/symbol/match\" {\n    const match: typeof core.Symbol.match;\n    export = match;\n}\ndeclare module \"core-js/library/fn/symbol/replace\" {\n    const replace: typeof core.Symbol.replace;\n    export = replace;\n}\ndeclare module \"core-js/library/fn/symbol/search\" {\n    const search: typeof core.Symbol.search;\n    export = search;\n}\ndeclare module \"core-js/library/fn/symbol/species\" {\n    const species: typeof core.Symbol.species;\n    export = species;\n}\ndeclare module \"core-js/library/fn/symbol/split\" {\n    const split: typeof core.Symbol.split;\n    export = split;\n}\ndeclare module \"core-js/library/fn/symbol/to-primitive\" {\n    const toPrimitive: typeof core.Symbol.toPrimitive;\n    export = toPrimitive;\n}\ndeclare module \"core-js/library/fn/symbol/to-string-tag\" {\n    const toStringTag: typeof core.Symbol.toStringTag;\n    export = toStringTag;\n}\ndeclare module \"core-js/library/fn/symbol/unscopables\" {\n    const unscopables: typeof core.Symbol.unscopables;\n    export = unscopables;\n}\ndeclare module \"core-js/library/es5\" {\n    export = core;\n}\ndeclare module \"core-js/library/es6\" {\n    export = core;\n}\ndeclare module \"core-js/library/es6/array\" {\n    const Array: typeof core.Array;\n    export = Array;\n}\ndeclare module \"core-js/library/es6/function\" {\n    const Function: typeof core.Function;\n    export = Function;\n}\ndeclare module \"core-js/library/es6/map\" {\n    const Map: typeof core.Map;\n    export = Map;\n}\ndeclare module \"core-js/library/es6/math\" {\n    const Math: typeof core.Math;\n    export = Math;\n}\ndeclare module \"core-js/library/es6/number\" {\n    const Number: typeof core.Number;\n    export = Number;\n}\ndeclare module \"core-js/library/es6/object\" {\n    const Object: typeof core.Object;\n    export = Object;\n}\ndeclare module \"core-js/library/es6/promise\" {\n    const Promise: typeof core.Promise;\n    export = Promise;\n}\ndeclare module \"core-js/library/es6/reflect\" {\n    const Reflect: typeof core.Reflect;\n    export = Reflect;\n}\ndeclare module \"core-js/library/es6/regexp\" {\n    const RegExp: typeof core.RegExp;\n    export = RegExp;\n}\ndeclare module \"core-js/library/es6/set\" {\n    const Set: typeof core.Set;\n    export = Set;\n}\ndeclare module \"core-js/library/es6/string\" {\n    const String: typeof core.String;\n    export = String;\n}\ndeclare module \"core-js/library/es6/symbol\" {\n    const Symbol: typeof core.Symbol;\n    export = Symbol;\n}\ndeclare module \"core-js/library/es6/weak-map\" {\n    const WeakMap: typeof core.WeakMap;\n    export = WeakMap;\n}\ndeclare module \"core-js/library/es6/weak-set\" {\n    const WeakSet: typeof core.WeakSet;\n    export = WeakSet;\n}\ndeclare module \"core-js/library/es7\" {\n    export = core;\n}\ndeclare module \"core-js/library/es7/array\" {\n    const Array: typeof core.Array;\n    export = Array;\n}\ndeclare module \"core-js/library/es7/map\" {\n    const Map: typeof core.Map;\n    export = Map;\n}\ndeclare module \"core-js/library/es7/object\" {\n    const Object: typeof core.Object;\n    export = Object;\n}\ndeclare module \"core-js/library/es7/regexp\" {\n    const RegExp: typeof core.RegExp;\n    export = RegExp;\n}\ndeclare module \"core-js/library/es7/set\" {\n    const Set: typeof core.Set;\n    export = Set;\n}\ndeclare module \"core-js/library/es7/string\" {\n    const String: typeof core.String;\n    export = String;\n}\ndeclare module \"core-js/library/js\" {\n    export = core;\n}\ndeclare module \"core-js/library/js/array\" {\n    const Array: typeof core.Array;\n    export = Array;\n}\ndeclare module \"core-js/library/web\" {\n    export = core;\n}\ndeclare module \"core-js/library/web/dom\" {\n    export = core;\n}\ndeclare module \"core-js/library/web/immediate\" {\n    export = core;\n}\ndeclare module \"core-js/library/web/timers\" {\n    export = core;\n}\n"},"https://unpkg.com/typestyle@1.5.1/lib/index.js":{"fullPath":"https://unpkg.com/typestyle@1.5.1/lib/index.js","contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar typestyle_1 = require(\"./internal/typestyle\");\nexports.TypeStyle = typestyle_1.TypeStyle;\n/**\n * All the CSS types in the 'types' namespace\n */\nvar types = require(\"./types\");\nexports.types = types;\n/**\n * Export certain utilities\n */\nvar utilities_1 = require(\"./internal/utilities\");\nexports.extend = utilities_1.extend;\nexports.classes = utilities_1.classes;\nexports.media = utilities_1.media;\n/** Zero configuration, default instance of TypeStyle */\nvar ts = new typestyle_1.TypeStyle({ autoGenerateTag: true });\n/** Sets the target tag where we write the css on style updates */\nexports.setStylesTarget = ts.setStylesTarget;\n/**\n * Insert `raw` CSS as a string. This is useful for e.g.\n * - third party CSS that you are customizing with template strings\n * - generating raw CSS in JavaScript\n * - reset libraries like normalize.css that you can use without loaders\n */\nexports.cssRaw = ts.cssRaw;\n/**\n * Takes CSSProperties and registers it to a global selector (body, html, etc.)\n */\nexports.cssRule = ts.cssRule;\n/**\n * Renders styles to the singleton tag imediately\n * NOTE: You should only call it on initial render to prevent any non CSS flash.\n * After that it is kept sync using `requestAnimationFrame` and we haven't noticed any bad flashes.\n **/\nexports.forceRenderStyles = ts.forceRenderStyles;\n/**\n * Utility function to register an @font-face\n */\nexports.fontFace = ts.fontFace;\n/**\n * Allows use to use the stylesheet in a node.js environment\n */\nexports.getStyles = ts.getStyles;\n/**\n * Takes keyframes and returns a generated animationName\n */\nexports.keyframes = ts.keyframes;\n/**\n * Helps with testing. Reinitializes FreeStyle + raw\n */\nexports.reinit = ts.reinit;\n/**\n * Takes CSSProperties and return a generated className you can use on your component\n */\nexports.style = ts.style;\n/**\n * Creates a new instance of TypeStyle separate from the default instance.\n *\n * - Use this for creating a different typestyle instance for a shadow dom component.\n * - Use this if you don't want an auto tag generated and you just want to collect the CSS.\n *\n * NOTE: styles aren't shared between different instances.\n */\nfunction createTypeStyle(target) {\n    var instance = new typestyle_1.TypeStyle({ autoGenerateTag: false });\n    if (target) {\n        instance.setStylesTarget(target);\n    }\n    return instance;\n}\nexports.createTypeStyle = createTypeStyle;\n"},"https://unpkg.com/@types/node@8.5.2/index.d.ts":{"fullPath":"https://unpkg.com/@types/node@8.5.2/index.d.ts","contents":"// Type definitions for Node.js 8.5.x\r\n// Project: http://nodejs.org/\r\n// Definitions by: Microsoft TypeScript <http://typescriptlang.org>\r\n//                 DefinitelyTyped <https://github.com/DefinitelyTyped/DefinitelyTyped>\r\n//                 Parambir Singh <https://github.com/parambirs>\r\n//                 Christian Vaagland Tellnes <https://github.com/tellnes>\r\n//                 Wilco Bakker <https://github.com/WilcoBakker>\r\n//                 Nicolas Voigt <https://github.com/octo-sniffle>\r\n//                 Chigozirim C. <https://github.com/smac89>\r\n//                 Flarna <https://github.com/Flarna>\r\n//                 Mariusz Wiktorczyk <https://github.com/mwiktorczyk>\r\n//                 wwwy3y3 <https://github.com/wwwy3y3>\r\n//                 Deividas Bakanas <https://github.com/DeividasBakanas>\r\n//                 Kelvin Jin <https://github.com/kjin>\r\n//                 Alvis HT Tang <https://github.com/alvis>\r\n//                 Oliver Joseph Ash <https://github.com/OliverJAsh>\r\n//                 Sebastian Silbermann <https://github.com/eps1lon>\r\n//                 Hannes Magnusson <https://github.com/Hannes-Magnusson-CK>\r\n//                 Alberto Schiabel <https://github.com/jkomyno>\r\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\r\n\r\n/************************************************\r\n*                                               *\r\n*               Node.js v8.5.x API              *\r\n*                                               *\r\n************************************************/\r\n\r\n/** inspector module types */\r\n/// <reference path=\"./inspector.d.ts\" />\r\n\r\n// This needs to be global to avoid TS2403 in case lib.dom.d.ts is present in the same build\r\ninterface Console {\r\n    Console: NodeJS.ConsoleConstructor;\r\n    assert(value: any, message?: string, ...optionalParams: any[]): void;\r\n    dir(obj: any, options?: NodeJS.InspectOptions): void;\r\n    error(message?: any, ...optionalParams: any[]): void;\r\n    info(message?: any, ...optionalParams: any[]): void;\r\n    log(message?: any, ...optionalParams: any[]): void;\r\n    time(label: string): void;\r\n    timeEnd(label: string): void;\r\n    trace(message?: any, ...optionalParams: any[]): void;\r\n    warn(message?: any, ...optionalParams: any[]): void;\r\n}\r\n\r\ninterface Error {\r\n    stack?: string;\r\n}\r\n\r\n// Declare \"static\" methods in Error\r\ninterface ErrorConstructor {\r\n    /** Create .stack property on a target object */\r\n    captureStackTrace(targetObject: Object, constructorOpt?: Function): void;\r\n\r\n    /**\r\n     * Optional override for formatting stack traces\r\n     *\r\n     * @see https://github.com/v8/v8/wiki/Stack%20Trace%20API#customizing-stack-traces\r\n     */\r\n    prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;\r\n\r\n    stackTraceLimit: number;\r\n}\r\n\r\n// compat for TypeScript 1.8\r\n// if you use with --target es3 or --target es5 and use below definitions,\r\n// use the lib.es6.d.ts that is bundled with TypeScript 1.8.\r\ninterface MapConstructor { }\r\ninterface WeakMapConstructor { }\r\ninterface SetConstructor { }\r\ninterface WeakSetConstructor { }\r\n\r\n// Forward-declare needed types from lib.es2015.d.ts (in case users are using `--lib es5`)\r\ninterface Iterable<T> { }\r\ninterface Iterator<T> {\r\n    next(value?: any): IteratorResult<T>;\r\n}\r\ninterface IteratorResult<T> { }\r\ninterface SymbolConstructor {\r\n    readonly iterator: symbol;\r\n}\r\ndeclare var Symbol: SymbolConstructor;\r\n\r\n// Node.js ESNEXT support\r\ninterface String {\r\n    /** Removes whitespace from the left end of a string. */\r\n    trimLeft(): string;\r\n    /** Removes whitespace from the right end of a string. */\r\n    trimRight(): string;\r\n}\r\n\r\n/************************************************\r\n*                                               *\r\n*                   GLOBAL                      *\r\n*                                               *\r\n************************************************/\r\ndeclare var process: NodeJS.Process;\r\ndeclare var global: NodeJS.Global;\r\ndeclare var console: Console;\r\n\r\ndeclare var __filename: string;\r\ndeclare var __dirname: string;\r\n\r\ndeclare function setTimeout(callback: (...args: any[]) => void, ms: number, ...args: any[]): NodeJS.Timer;\r\ndeclare namespace setTimeout {\r\n    export function __promisify__(ms: number): Promise<void>;\r\n    export function __promisify__<T>(ms: number, value: T): Promise<T>;\r\n}\r\ndeclare function clearTimeout(timeoutId: NodeJS.Timer): void;\r\ndeclare function setInterval(callback: (...args: any[]) => void, ms: number, ...args: any[]): NodeJS.Timer;\r\ndeclare function clearInterval(intervalId: NodeJS.Timer): void;\r\ndeclare function setImmediate(callback: (...args: any[]) => void, ...args: any[]): any;\r\ndeclare namespace setImmediate {\r\n    export function __promisify__(): Promise<void>;\r\n    export function __promisify__<T>(value: T): Promise<T>;\r\n}\r\ndeclare function clearImmediate(immediateId: any): void;\r\n\r\n// TODO: change to `type NodeRequireFunction = (id: string) => any;` in next mayor version.\r\ninterface NodeRequireFunction {\r\n/* tslint:disable-next-line:callable-types */\r\n    (id: string): any;\r\n}\r\n\r\ninterface NodeRequire extends NodeRequireFunction {\r\n    resolve(id: string): string;\r\n    cache: any;\r\n    extensions: NodeExtensions;\r\n    main: NodeModule | undefined;\r\n}\r\n\r\ninterface NodeExtensions {\r\n    '.js': (m: NodeModule, filename: string) => any;\r\n    '.json': (m: NodeModule, filename: string) => any;\r\n    '.node': (m: NodeModule, filename: string) => any;\r\n    [ext: string]: (m: NodeModule, filename: string) => any;\r\n}\r\n\r\ndeclare var require: NodeRequire;\r\n\r\ninterface NodeModule {\r\n    exports: any;\r\n    require: NodeRequireFunction;\r\n    id: string;\r\n    filename: string;\r\n    loaded: boolean;\r\n    parent: NodeModule | null;\r\n    children: NodeModule[];\r\n}\r\n\r\ndeclare var module: NodeModule;\r\n\r\n// Same as module.exports\r\ndeclare var exports: any;\r\ndeclare var SlowBuffer: {\r\n    new(str: string, encoding?: string): Buffer;\r\n    new(size: number): Buffer;\r\n    new(size: Uint8Array): Buffer;\r\n    new(array: any[]): Buffer;\r\n    prototype: Buffer;\r\n    isBuffer(obj: any): boolean;\r\n    byteLength(string: string, encoding?: string): number;\r\n    concat(list: Buffer[], totalLength?: number): Buffer;\r\n};\r\n\r\n// Buffer class\r\ntype BufferEncoding = \"ascii\" | \"utf8\" | \"utf16le\" | \"ucs2\" | \"base64\" | \"latin1\" | \"binary\" | \"hex\";\r\ninterface Buffer extends NodeBuffer { }\r\n\r\n/**\r\n * Raw data is stored in instances of the Buffer class.\r\n * A Buffer is similar to an array of integers but corresponds to a raw memory allocation outside the V8 heap.  A Buffer cannot be resized.\r\n * Valid string encodings: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'\r\n */\r\ndeclare var Buffer: {\r\n    /**\r\n     * Allocates a new buffer containing the given {str}.\r\n     *\r\n     * @param str String to store in buffer.\r\n     * @param encoding encoding to use, optional.  Default is 'utf8'\r\n     */\r\n    new(str: string, encoding?: string): Buffer;\r\n    /**\r\n     * Allocates a new buffer of {size} octets.\r\n     *\r\n     * @param size count of octets to allocate.\r\n     */\r\n    new(size: number): Buffer;\r\n    /**\r\n     * Allocates a new buffer containing the given {array} of octets.\r\n     *\r\n     * @param array The octets to store.\r\n     */\r\n    new(array: Uint8Array): Buffer;\r\n    /**\r\n     * Produces a Buffer backed by the same allocated memory as\r\n     * the given {ArrayBuffer}.\r\n     *\r\n     *\r\n     * @param arrayBuffer The ArrayBuffer with which to share memory.\r\n     */\r\n    new(arrayBuffer: ArrayBuffer): Buffer;\r\n    /**\r\n     * Allocates a new buffer containing the given {array} of octets.\r\n     *\r\n     * @param array The octets to store.\r\n     */\r\n    new(array: any[]): Buffer;\r\n    /**\r\n     * Copies the passed {buffer} data onto a new {Buffer} instance.\r\n     *\r\n     * @param buffer The buffer to copy.\r\n     */\r\n    new(buffer: Buffer): Buffer;\r\n    prototype: Buffer;\r\n    /**\r\n     * Allocates a new Buffer using an {array} of octets.\r\n     */\r\n    from(array: any[]): Buffer;\r\n    /**\r\n     * When passed a reference to the .buffer property of a TypedArray instance,\r\n     * the newly created Buffer will share the same allocated memory as the TypedArray.\r\n     * The optional {byteOffset} and {length} arguments specify a memory range\r\n     * within the {arrayBuffer} that will be shared by the Buffer.\r\n     *\r\n     * @param arrayBuffer The .buffer property of a TypedArray or a new ArrayBuffer()\r\n     */\r\n    from(arrayBuffer: ArrayBuffer, byteOffset?: number, length?: number): Buffer;\r\n    /**\r\n     * Copies the passed {buffer} data onto a new Buffer instance.\r\n     */\r\n    from(buffer: Buffer): Buffer;\r\n    /**\r\n     * Creates a new Buffer containing the given JavaScript string {str}.\r\n     * If provided, the {encoding} parameter identifies the character encoding.\r\n     * If not provided, {encoding} defaults to 'utf8'.\r\n     */\r\n    from(str: string, encoding?: string): Buffer;\r\n    /**\r\n     * Returns true if {obj} is a Buffer\r\n     *\r\n     * @param obj object to test.\r\n     */\r\n    isBuffer(obj: any): obj is Buffer;\r\n    /**\r\n     * Returns true if {encoding} is a valid encoding argument.\r\n     * Valid string encodings in Node 0.12: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'\r\n     *\r\n     * @param encoding string to test.\r\n     */\r\n    isEncoding(encoding: string): boolean;\r\n    /**\r\n     * Gives the actual byte length of a string. encoding defaults to 'utf8'.\r\n     * This is not the same as String.prototype.length since that returns the number of characters in a string.\r\n     *\r\n     * @param string string to test. (TypedArray is also allowed, but it is only available starting ES2017)\r\n     * @param encoding encoding used to evaluate (defaults to 'utf8')\r\n     */\r\n    byteLength(string: string | Buffer | DataView | ArrayBuffer, encoding?: string): number;\r\n    /**\r\n     * Returns a buffer which is the result of concatenating all the buffers in the list together.\r\n     *\r\n     * If the list has no items, or if the totalLength is 0, then it returns a zero-length buffer.\r\n     * If the list has exactly one item, then the first item of the list is returned.\r\n     * If the list has more than one item, then a new Buffer is created.\r\n     *\r\n     * @param list An array of Buffer objects to concatenate\r\n     * @param totalLength Total length of the buffers when concatenated.\r\n     *   If totalLength is not provided, it is read from the buffers in the list. However, this adds an additional loop to the function, so it is faster to provide the length explicitly.\r\n     */\r\n    concat(list: Buffer[], totalLength?: number): Buffer;\r\n    /**\r\n     * The same as buf1.compare(buf2).\r\n     */\r\n    compare(buf1: Buffer, buf2: Buffer): number;\r\n    /**\r\n     * Allocates a new buffer of {size} octets.\r\n     *\r\n     * @param size count of octets to allocate.\r\n     * @param fill if specified, buffer will be initialized by calling buf.fill(fill).\r\n     *    If parameter is omitted, buffer will be filled with zeros.\r\n     * @param encoding encoding used for call to buf.fill while initalizing\r\n     */\r\n    alloc(size: number, fill?: string | Buffer | number, encoding?: string): Buffer;\r\n    /**\r\n     * Allocates a new buffer of {size} octets, leaving memory not initialized, so the contents\r\n     * of the newly created Buffer are unknown and may contain sensitive data.\r\n     *\r\n     * @param size count of octets to allocate\r\n     */\r\n    allocUnsafe(size: number): Buffer;\r\n    /**\r\n     * Allocates a new non-pooled buffer of {size} octets, leaving memory not initialized, so the contents\r\n     * of the newly created Buffer are unknown and may contain sensitive data.\r\n     *\r\n     * @param size count of octets to allocate\r\n     */\r\n    allocUnsafeSlow(size: number): Buffer;\r\n    /**\r\n     * This is the number of bytes used to determine the size of pre-allocated, internal Buffer instances used for pooling. This value may be modified.\r\n     */\r\n    poolSize: number;\r\n};\r\n\r\n/************************************************\r\n*                                               *\r\n*               GLOBAL INTERFACES               *\r\n*                                               *\r\n************************************************/\r\ndeclare namespace NodeJS {\r\n    export interface InspectOptions {\r\n        showHidden?: boolean;\r\n        depth?: number | null;\r\n        colors?: boolean;\r\n        customInspect?: boolean;\r\n        showProxy?: boolean;\r\n        maxArrayLength?: number | null;\r\n        breakLength?: number;\r\n    }\r\n\r\n    export interface ConsoleConstructor {\r\n        prototype: Console;\r\n        new(stdout: WritableStream, stderr?: WritableStream): Console;\r\n    }\r\n\r\n    export interface CallSite {\r\n        /**\r\n         * Value of \"this\"\r\n         */\r\n        getThis(): any;\r\n\r\n        /**\r\n         * Type of \"this\" as a string.\r\n         * This is the name of the function stored in the constructor field of\r\n         * \"this\", if available.  Otherwise the object's [[Class]] internal\r\n         * property.\r\n         */\r\n        getTypeName(): string | null;\r\n\r\n        /**\r\n         * Current function\r\n         */\r\n        getFunction(): Function | undefined;\r\n\r\n        /**\r\n         * Name of the current function, typically its name property.\r\n         * If a name property is not available an attempt will be made to try\r\n         * to infer a name from the function's context.\r\n         */\r\n        getFunctionName(): string | null;\r\n\r\n        /**\r\n         * Name of the property [of \"this\" or one of its prototypes] that holds\r\n         * the current function\r\n         */\r\n        getMethodName(): string | null;\r\n\r\n        /**\r\n         * Name of the script [if this function was defined in a script]\r\n         */\r\n        getFileName(): string | null;\r\n\r\n        /**\r\n         * Current line number [if this function was defined in a script]\r\n         */\r\n        getLineNumber(): number | null;\r\n\r\n        /**\r\n         * Current column number [if this function was defined in a script]\r\n         */\r\n        getColumnNumber(): number | null;\r\n\r\n        /**\r\n         * A call site object representing the location where eval was called\r\n         * [if this function was created using a call to eval]\r\n         */\r\n        getEvalOrigin(): string | undefined;\r\n\r\n        /**\r\n         * Is this a toplevel invocation, that is, is \"this\" the global object?\r\n         */\r\n        isToplevel(): boolean;\r\n\r\n        /**\r\n         * Does this call take place in code defined by a call to eval?\r\n         */\r\n        isEval(): boolean;\r\n\r\n        /**\r\n         * Is this call in native V8 code?\r\n         */\r\n        isNative(): boolean;\r\n\r\n        /**\r\n         * Is this a constructor call?\r\n         */\r\n        isConstructor(): boolean;\r\n    }\r\n\r\n    export interface ErrnoException extends Error {\r\n        errno?: number;\r\n        code?: string;\r\n        path?: string;\r\n        syscall?: string;\r\n        stack?: string;\r\n    }\r\n\r\n    export class EventEmitter {\r\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\r\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\r\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\r\n        removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\r\n        removeAllListeners(event?: string | symbol): this;\r\n        setMaxListeners(n: number): this;\r\n        getMaxListeners(): number;\r\n        listeners(event: string | symbol): Function[];\r\n        emit(event: string | symbol, ...args: any[]): boolean;\r\n        listenerCount(type: string | symbol): number;\r\n        // Added in Node 6...\r\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\r\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\r\n        eventNames(): Array<string | symbol>;\r\n    }\r\n\r\n    export interface ReadableStream extends EventEmitter {\r\n        readable: boolean;\r\n        read(size?: number): string | Buffer;\r\n        setEncoding(encoding: string): this;\r\n        pause(): this;\r\n        resume(): this;\r\n        isPaused(): boolean;\r\n        pipe<T extends WritableStream>(destination: T, options?: { end?: boolean; }): T;\r\n        unpipe<T extends WritableStream>(destination?: T): this;\r\n        unshift(chunk: string): void;\r\n        unshift(chunk: Buffer): void;\r\n        wrap(oldStream: ReadableStream): this;\r\n    }\r\n\r\n    export interface WritableStream extends EventEmitter {\r\n        writable: boolean;\r\n        write(buffer: Buffer | string, cb?: Function): boolean;\r\n        write(str: string, encoding?: string, cb?: Function): boolean;\r\n        end(cb?: Function): void;\r\n        end(buffer: Buffer, cb?: Function): void;\r\n        end(str: string, cb?: Function): void;\r\n        end(str: string, encoding?: string, cb?: Function): void;\r\n    }\r\n\r\n    export interface ReadWriteStream extends ReadableStream, WritableStream { }\r\n\r\n    export interface Events extends EventEmitter { }\r\n\r\n    export interface Domain extends Events {\r\n        run(fn: Function): void;\r\n        add(emitter: Events): void;\r\n        remove(emitter: Events): void;\r\n        bind(cb: (err: Error, data: any) => any): any;\r\n        intercept(cb: (data: any) => any): any;\r\n        dispose(): void;\r\n\r\n        addListener(event: string, listener: (...args: any[]) => void): this;\r\n        on(event: string, listener: (...args: any[]) => void): this;\r\n        once(event: string, listener: (...args: any[]) => void): this;\r\n        removeListener(event: string, listener: (...args: any[]) => void): this;\r\n        removeAllListeners(event?: string): this;\r\n    }\r\n\r\n    export interface MemoryUsage {\r\n        rss: number;\r\n        heapTotal: number;\r\n        heapUsed: number;\r\n    }\r\n\r\n    export interface CpuUsage {\r\n        user: number;\r\n        system: number;\r\n    }\r\n\r\n    export interface ProcessVersions {\r\n        http_parser: string;\r\n        node: string;\r\n        v8: string;\r\n        ares: string;\r\n        uv: string;\r\n        zlib: string;\r\n        modules: string;\r\n        openssl: string;\r\n    }\r\n\r\n    type Platform = 'aix'\r\n        | 'android'\r\n        | 'darwin'\r\n        | 'freebsd'\r\n        | 'linux'\r\n        | 'openbsd'\r\n        | 'sunos'\r\n        | 'win32'\r\n        | 'cygwin';\r\n\r\n    type Signals =\r\n        \"SIGABRT\" | \"SIGALRM\" | \"SIGBUS\" | \"SIGCHLD\" | \"SIGCONT\" | \"SIGFPE\" | \"SIGHUP\" | \"SIGILL\" | \"SIGINT\" | \"SIGIO\" |\r\n        \"SIGIOT\" | \"SIGKILL\" | \"SIGPIPE\" | \"SIGPOLL\" | \"SIGPROF\" | \"SIGPWR\" | \"SIGQUIT\" | \"SIGSEGV\" | \"SIGSTKFLT\" |\r\n        \"SIGSTOP\" | \"SIGSYS\" | \"SIGTERM\" | \"SIGTRAP\" | \"SIGTSTP\" | \"SIGTTIN\" | \"SIGTTOU\" | \"SIGUNUSED\" | \"SIGURG\" |\r\n        \"SIGUSR1\" | \"SIGUSR2\" | \"SIGVTALRM\" | \"SIGWINCH\" | \"SIGXCPU\" | \"SIGXFSZ\" | \"SIGBREAK\" | \"SIGLOST\" | \"SIGINFO\";\r\n\r\n    type BeforeExitListener = (code: number) => void;\r\n    type DisconnectListener = () => void;\r\n    type ExitListener = (code: number) => void;\r\n    type RejectionHandledListener = (promise: Promise<any>) => void;\r\n    type UncaughtExceptionListener = (error: Error) => void;\r\n    type UnhandledRejectionListener = (reason: any, promise: Promise<any>) => void;\r\n    type WarningListener = (warning: Error) => void;\r\n    type MessageListener = (message: any, sendHandle: any) => void;\r\n    type SignalsListener = () => void;\r\n    type NewListenerListener = (type: string | symbol, listener: (...args: any[]) => void) => void;\r\n    type RemoveListenerListener = (type: string | symbol, listener: (...args: any[]) => void) => void;\r\n\r\n    export interface Socket extends ReadWriteStream {\r\n        isTTY?: true;\r\n    }\r\n\r\n    export interface ProcessEnv {\r\n        [key: string]: string | undefined;\r\n    }\r\n\r\n    export interface WriteStream extends Socket {\r\n        columns?: number;\r\n        rows?: number;\r\n        _write(chunk: any, encoding: string, callback: Function): void;\r\n        _destroy(err: Error, callback: Function): void;\r\n        _final(callback: Function): void;\r\n        setDefaultEncoding(encoding: string): this;\r\n        cork(): void;\r\n        uncork(): void;\r\n        destroy(error?: Error): void;\r\n    }\r\n    export interface ReadStream extends Socket {\r\n        isRaw?: boolean;\r\n        setRawMode?(mode: boolean): void;\r\n        _read(size: number): void;\r\n        _destroy(err: Error, callback: Function): void;\r\n        push(chunk: any, encoding?: string): boolean;\r\n        destroy(error?: Error): void;\r\n    }\r\n\r\n    export interface Process extends EventEmitter {\r\n        stdout: WriteStream;\r\n        stderr: WriteStream;\r\n        stdin: ReadStream;\r\n        openStdin(): Socket;\r\n        argv: string[];\r\n        argv0: string;\r\n        execArgv: string[];\r\n        execPath: string;\r\n        abort(): void;\r\n        chdir(directory: string): void;\r\n        cwd(): string;\r\n        emitWarning(warning: string | Error, name?: string, ctor?: Function): void;\r\n        env: ProcessEnv;\r\n        exit(code?: number): never;\r\n        exitCode: number;\r\n        getgid(): number;\r\n        setgid(id: number | string): void;\r\n        getuid(): number;\r\n        setuid(id: number | string): void;\r\n        geteuid(): number;\r\n        seteuid(id: number | string): void;\r\n        getegid(): number;\r\n        setegid(id: number | string): void;\r\n        getgroups(): number[];\r\n        setgroups(groups: Array<string | number>): void;\r\n        version: string;\r\n        versions: ProcessVersions;\r\n        config: {\r\n            target_defaults: {\r\n                cflags: any[];\r\n                default_configuration: string;\r\n                defines: string[];\r\n                include_dirs: string[];\r\n                libraries: string[];\r\n            };\r\n            variables: {\r\n                clang: number;\r\n                host_arch: string;\r\n                node_install_npm: boolean;\r\n                node_install_waf: boolean;\r\n                node_prefix: string;\r\n                node_shared_openssl: boolean;\r\n                node_shared_v8: boolean;\r\n                node_shared_zlib: boolean;\r\n                node_use_dtrace: boolean;\r\n                node_use_etw: boolean;\r\n                node_use_openssl: boolean;\r\n                target_arch: string;\r\n                v8_no_strict_aliasing: number;\r\n                v8_use_snapshot: boolean;\r\n                visibility: string;\r\n            };\r\n        };\r\n        kill(pid: number, signal?: string | number): void;\r\n        pid: number;\r\n        title: string;\r\n        arch: string;\r\n        platform: Platform;\r\n        mainModule?: NodeModule;\r\n        memoryUsage(): MemoryUsage;\r\n        cpuUsage(previousValue?: CpuUsage): CpuUsage;\r\n        nextTick(callback: Function, ...args: any[]): void;\r\n        umask(mask?: number): number;\r\n        uptime(): number;\r\n        hrtime(time?: [number, number]): [number, number];\r\n        domain: Domain;\r\n\r\n        // Worker\r\n        send?(message: any, sendHandle?: any): void;\r\n        disconnect(): void;\r\n        connected: boolean;\r\n\r\n        /**\r\n         * EventEmitter\r\n         *   1. beforeExit\r\n         *   2. disconnect\r\n         *   3. exit\r\n         *   4. message\r\n         *   5. rejectionHandled\r\n         *   6. uncaughtException\r\n         *   7. unhandledRejection\r\n         *   8. warning\r\n         *   9. message\r\n         *  10. <All OS Signals>\r\n         *  11. newListener/removeListener inherited from EventEmitter\r\n         */\r\n        addListener(event: \"beforeExit\", listener: BeforeExitListener): this;\r\n        addListener(event: \"disconnect\", listener: DisconnectListener): this;\r\n        addListener(event: \"exit\", listener: ExitListener): this;\r\n        addListener(event: \"rejectionHandled\", listener: RejectionHandledListener): this;\r\n        addListener(event: \"uncaughtException\", listener: UncaughtExceptionListener): this;\r\n        addListener(event: \"unhandledRejection\", listener: UnhandledRejectionListener): this;\r\n        addListener(event: \"warning\", listener: WarningListener): this;\r\n        addListener(event: \"message\", listener: MessageListener): this;\r\n        addListener(event: Signals, listener: SignalsListener): this;\r\n        addListener(event: \"newListener\", listener: NewListenerListener): this;\r\n        addListener(event: \"removeListener\", listener: RemoveListenerListener): this;\r\n\r\n        emit(event: \"beforeExit\", code: number): boolean;\r\n        emit(event: \"disconnect\"): boolean;\r\n        emit(event: \"exit\", code: number): boolean;\r\n        emit(event: \"rejectionHandled\", promise: Promise<any>): boolean;\r\n        emit(event: \"uncaughtException\", error: Error): boolean;\r\n        emit(event: \"unhandledRejection\", reason: any, promise: Promise<any>): boolean;\r\n        emit(event: \"warning\", warning: Error): boolean;\r\n        emit(event: \"message\", message: any, sendHandle: any): this;\r\n        emit(event: Signals): boolean;\r\n        emit(event: \"newListener\", eventName: string | symbol, listener: (...args: any[]) => void): this;\r\n        emit(event: \"removeListener\", eventName: string, listener: (...args: any[]) => void): this;\r\n\r\n        on(event: \"beforeExit\", listener: BeforeExitListener): this;\r\n        on(event: \"disconnect\", listener: DisconnectListener): this;\r\n        on(event: \"exit\", listener: ExitListener): this;\r\n        on(event: \"rejectionHandled\", listener: RejectionHandledListener): this;\r\n        on(event: \"uncaughtException\", listener: UncaughtExceptionListener): this;\r\n        on(event: \"unhandledRejection\", listener: UnhandledRejectionListener): this;\r\n        on(event: \"warning\", listener: WarningListener): this;\r\n        on(event: \"message\", listener: MessageListener): this;\r\n        on(event: Signals, listener: SignalsListener): this;\r\n        on(event: \"newListener\", listener: NewListenerListener): this;\r\n        on(event: \"removeListener\", listener: RemoveListenerListener): this;\r\n\r\n        once(event: \"beforeExit\", listener: BeforeExitListener): this;\r\n        once(event: \"disconnect\", listener: DisconnectListener): this;\r\n        once(event: \"exit\", listener: ExitListener): this;\r\n        once(event: \"rejectionHandled\", listener: RejectionHandledListener): this;\r\n        once(event: \"uncaughtException\", listener: UncaughtExceptionListener): this;\r\n        once(event: \"unhandledRejection\", listener: UnhandledRejectionListener): this;\r\n        once(event: \"warning\", listener: WarningListener): this;\r\n        once(event: \"message\", listener: MessageListener): this;\r\n        once(event: Signals, listener: SignalsListener): this;\r\n        once(event: \"newListener\", listener: NewListenerListener): this;\r\n        once(event: \"removeListener\", listener: RemoveListenerListener): this;\r\n\r\n        prependListener(event: \"beforeExit\", listener: BeforeExitListener): this;\r\n        prependListener(event: \"disconnect\", listener: DisconnectListener): this;\r\n        prependListener(event: \"exit\", listener: ExitListener): this;\r\n        prependListener(event: \"rejectionHandled\", listener: RejectionHandledListener): this;\r\n        prependListener(event: \"uncaughtException\", listener: UncaughtExceptionListener): this;\r\n        prependListener(event: \"unhandledRejection\", listener: UnhandledRejectionListener): this;\r\n        prependListener(event: \"warning\", listener: WarningListener): this;\r\n        prependListener(event: \"message\", listener: MessageListener): this;\r\n        prependListener(event: Signals, listener: SignalsListener): this;\r\n        prependListener(event: \"newListener\", listener: NewListenerListener): this;\r\n        prependListener(event: \"removeListener\", listener: RemoveListenerListener): this;\r\n\r\n        prependOnceListener(event: \"beforeExit\", listener: BeforeExitListener): this;\r\n        prependOnceListener(event: \"disconnect\", listener: DisconnectListener): this;\r\n        prependOnceListener(event: \"exit\", listener: ExitListener): this;\r\n        prependOnceListener(event: \"rejectionHandled\", listener: RejectionHandledListener): this;\r\n        prependOnceListener(event: \"uncaughtException\", listener: UncaughtExceptionListener): this;\r\n        prependOnceListener(event: \"unhandledRejection\", listener: UnhandledRejectionListener): this;\r\n        prependOnceListener(event: \"warning\", listener: WarningListener): this;\r\n        prependOnceListener(event: \"message\", listener: MessageListener): this;\r\n        prependOnceListener(event: Signals, listener: SignalsListener): this;\r\n        prependOnceListener(event: \"newListener\", listener: NewListenerListener): this;\r\n        prependOnceListener(event: \"removeListener\", listener: RemoveListenerListener): this;\r\n\r\n        listeners(event: \"beforeExit\"): BeforeExitListener[];\r\n        listeners(event: \"disconnect\"): DisconnectListener[];\r\n        listeners(event: \"exit\"): ExitListener[];\r\n        listeners(event: \"rejectionHandled\"): RejectionHandledListener[];\r\n        listeners(event: \"uncaughtException\"): UncaughtExceptionListener[];\r\n        listeners(event: \"unhandledRejection\"): UnhandledRejectionListener[];\r\n        listeners(event: \"warning\"): WarningListener[];\r\n        listeners(event: \"message\"): MessageListener[];\r\n        listeners(event: Signals): SignalsListener[];\r\n        listeners(event: \"newListener\"): NewListenerListener[];\r\n        listeners(event: \"removeListener\"): RemoveListenerListener[];\r\n    }\r\n\r\n    export interface Global {\r\n        Array: typeof Array;\r\n        ArrayBuffer: typeof ArrayBuffer;\r\n        Boolean: typeof Boolean;\r\n        Buffer: typeof Buffer;\r\n        DataView: typeof DataView;\r\n        Date: typeof Date;\r\n        Error: typeof Error;\r\n        EvalError: typeof EvalError;\r\n        Float32Array: typeof Float32Array;\r\n        Float64Array: typeof Float64Array;\r\n        Function: typeof Function;\r\n        GLOBAL: Global;\r\n        Infinity: typeof Infinity;\r\n        Int16Array: typeof Int16Array;\r\n        Int32Array: typeof Int32Array;\r\n        Int8Array: typeof Int8Array;\r\n        Intl: typeof Intl;\r\n        JSON: typeof JSON;\r\n        Map: MapConstructor;\r\n        Math: typeof Math;\r\n        NaN: typeof NaN;\r\n        Number: typeof Number;\r\n        Object: typeof Object;\r\n        Promise: Function;\r\n        RangeError: typeof RangeError;\r\n        ReferenceError: typeof ReferenceError;\r\n        RegExp: typeof RegExp;\r\n        Set: SetConstructor;\r\n        String: typeof String;\r\n        Symbol: Function;\r\n        SyntaxError: typeof SyntaxError;\r\n        TypeError: typeof TypeError;\r\n        URIError: typeof URIError;\r\n        Uint16Array: typeof Uint16Array;\r\n        Uint32Array: typeof Uint32Array;\r\n        Uint8Array: typeof Uint8Array;\r\n        Uint8ClampedArray: Function;\r\n        WeakMap: WeakMapConstructor;\r\n        WeakSet: WeakSetConstructor;\r\n        clearImmediate: (immediateId: any) => void;\r\n        clearInterval: (intervalId: NodeJS.Timer) => void;\r\n        clearTimeout: (timeoutId: NodeJS.Timer) => void;\r\n        console: typeof console;\r\n        decodeURI: typeof decodeURI;\r\n        decodeURIComponent: typeof decodeURIComponent;\r\n        encodeURI: typeof encodeURI;\r\n        encodeURIComponent: typeof encodeURIComponent;\r\n        escape: (str: string) => string;\r\n        eval: typeof eval;\r\n        global: Global;\r\n        isFinite: typeof isFinite;\r\n        isNaN: typeof isNaN;\r\n        parseFloat: typeof parseFloat;\r\n        parseInt: typeof parseInt;\r\n        process: Process;\r\n        root: Global;\r\n        setImmediate: (callback: (...args: any[]) => void, ...args: any[]) => any;\r\n        setInterval: (callback: (...args: any[]) => void, ms: number, ...args: any[]) => NodeJS.Timer;\r\n        setTimeout: (callback: (...args: any[]) => void, ms: number, ...args: any[]) => NodeJS.Timer;\r\n        undefined: typeof undefined;\r\n        unescape: (str: string) => string;\r\n        gc: () => void;\r\n        v8debug?: any;\r\n    }\r\n\r\n    export interface Timer {\r\n        ref(): void;\r\n        unref(): void;\r\n    }\r\n\r\n    class Module {\r\n        static runMain(): void;\r\n        static wrap(code: string): string;\r\n\r\n        static Module: typeof Module;\r\n\r\n        exports: any;\r\n        require: NodeRequireFunction;\r\n        id: string;\r\n        filename: string;\r\n        loaded: boolean;\r\n        parent: Module | null;\r\n        children: Module[];\r\n        paths: string[];\r\n\r\n        constructor(id: string, parent?: Module);\r\n    }\r\n}\r\n\r\ninterface IterableIterator<T> { }\r\n\r\n/**\r\n * @deprecated\r\n */\r\ninterface NodeBuffer extends Uint8Array {\r\n    write(string: string, offset?: number, length?: number, encoding?: string): number;\r\n    toString(encoding?: string, start?: number, end?: number): string;\r\n    toJSON(): { type: 'Buffer', data: any[] };\r\n    equals(otherBuffer: Buffer): boolean;\r\n    compare(otherBuffer: Buffer, targetStart?: number, targetEnd?: number, sourceStart?: number, sourceEnd?: number): number;\r\n    copy(targetBuffer: Buffer, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;\r\n    slice(start?: number, end?: number): Buffer;\r\n    writeUIntLE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;\r\n    writeUIntBE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;\r\n    writeIntLE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;\r\n    writeIntBE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;\r\n    readUIntLE(offset: number, byteLength: number, noAssert?: boolean): number;\r\n    readUIntBE(offset: number, byteLength: number, noAssert?: boolean): number;\r\n    readIntLE(offset: number, byteLength: number, noAssert?: boolean): number;\r\n    readIntBE(offset: number, byteLength: number, noAssert?: boolean): number;\r\n    readUInt8(offset: number, noAssert?: boolean): number;\r\n    readUInt16LE(offset: number, noAssert?: boolean): number;\r\n    readUInt16BE(offset: number, noAssert?: boolean): number;\r\n    readUInt32LE(offset: number, noAssert?: boolean): number;\r\n    readUInt32BE(offset: number, noAssert?: boolean): number;\r\n    readInt8(offset: number, noAssert?: boolean): number;\r\n    readInt16LE(offset: number, noAssert?: boolean): number;\r\n    readInt16BE(offset: number, noAssert?: boolean): number;\r\n    readInt32LE(offset: number, noAssert?: boolean): number;\r\n    readInt32BE(offset: number, noAssert?: boolean): number;\r\n    readFloatLE(offset: number, noAssert?: boolean): number;\r\n    readFloatBE(offset: number, noAssert?: boolean): number;\r\n    readDoubleLE(offset: number, noAssert?: boolean): number;\r\n    readDoubleBE(offset: number, noAssert?: boolean): number;\r\n    swap16(): Buffer;\r\n    swap32(): Buffer;\r\n    swap64(): Buffer;\r\n    writeUInt8(value: number, offset: number, noAssert?: boolean): number;\r\n    writeUInt16LE(value: number, offset: number, noAssert?: boolean): number;\r\n    writeUInt16BE(value: number, offset: number, noAssert?: boolean): number;\r\n    writeUInt32LE(value: number, offset: number, noAssert?: boolean): number;\r\n    writeUInt32BE(value: number, offset: number, noAssert?: boolean): number;\r\n    writeInt8(value: number, offset: number, noAssert?: boolean): number;\r\n    writeInt16LE(value: number, offset: number, noAssert?: boolean): number;\r\n    writeInt16BE(value: number, offset: number, noAssert?: boolean): number;\r\n    writeInt32LE(value: number, offset: number, noAssert?: boolean): number;\r\n    writeInt32BE(value: number, offset: number, noAssert?: boolean): number;\r\n    writeFloatLE(value: number, offset: number, noAssert?: boolean): number;\r\n    writeFloatBE(value: number, offset: number, noAssert?: boolean): number;\r\n    writeDoubleLE(value: number, offset: number, noAssert?: boolean): number;\r\n    writeDoubleBE(value: number, offset: number, noAssert?: boolean): number;\r\n    fill(value: any, offset?: number, end?: number): this;\r\n    indexOf(value: string | number | Buffer, byteOffset?: number, encoding?: string): number;\r\n    lastIndexOf(value: string | number | Buffer, byteOffset?: number, encoding?: string): number;\r\n    entries(): IterableIterator<[number, number]>;\r\n    includes(value: string | number | Buffer, byteOffset?: number, encoding?: string): boolean;\r\n    keys(): IterableIterator<number>;\r\n    values(): IterableIterator<number>;\r\n}\r\n\r\n/************************************************\r\n*                                               *\r\n*                   MODULES                     *\r\n*                                               *\r\n************************************************/\r\ndeclare module \"buffer\" {\r\n    export var INSPECT_MAX_BYTES: number;\r\n    var BuffType: typeof Buffer;\r\n    var SlowBuffType: typeof SlowBuffer;\r\n    export { BuffType as Buffer, SlowBuffType as SlowBuffer };\r\n}\r\n\r\ndeclare module \"querystring\" {\r\n    export interface StringifyOptions {\r\n        encodeURIComponent?: Function;\r\n    }\r\n\r\n    export interface ParseOptions {\r\n        maxKeys?: number;\r\n        decodeURIComponent?: Function;\r\n    }\r\n\r\n    interface ParsedUrlQuery { [key: string]: string | string[]; }\r\n\r\n    export function stringify<T>(obj: T, sep?: string, eq?: string, options?: StringifyOptions): string;\r\n    export function parse(str: string, sep?: string, eq?: string, options?: ParseOptions): ParsedUrlQuery;\r\n    export function parse<T extends {}>(str: string, sep?: string, eq?: string, options?: ParseOptions): T;\r\n    export function escape(str: string): string;\r\n    export function unescape(str: string): string;\r\n}\r\n\r\ndeclare module \"events\" {\r\n    class internal extends NodeJS.EventEmitter { }\r\n\r\n    namespace internal {\r\n        export class EventEmitter extends internal {\r\n            static listenerCount(emitter: EventEmitter, event: string | symbol): number; // deprecated\r\n            static defaultMaxListeners: number;\r\n\r\n            addListener(event: string | symbol, listener: (...args: any[]) => void): this;\r\n            on(event: string | symbol, listener: (...args: any[]) => void): this;\r\n            once(event: string | symbol, listener: (...args: any[]) => void): this;\r\n            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\r\n            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\r\n            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\r\n            removeAllListeners(event?: string | symbol): this;\r\n            setMaxListeners(n: number): this;\r\n            getMaxListeners(): number;\r\n            listeners(event: string | symbol): Function[];\r\n            emit(event: string | symbol, ...args: any[]): boolean;\r\n            eventNames(): Array<string | symbol>;\r\n            listenerCount(type: string | symbol): number;\r\n        }\r\n    }\r\n\r\n    export = internal;\r\n}\r\n\r\ndeclare module \"http\" {\r\n    import * as events from \"events\";\r\n    import * as net from \"net\";\r\n    import * as stream from \"stream\";\r\n    import { URL } from \"url\";\r\n\r\n    // incoming headers will never contain number\r\n    export interface IncomingHttpHeaders {\r\n        'accept'?: string;\r\n        'access-control-allow-origin'?: string;\r\n        'access-control-allow-credentials'?: string;\r\n        'access-control-expose-headers'?: string;\r\n        'access-control-max-age'?: string;\r\n        'access-control-allow-methods'?: string;\r\n        'access-control-allow-headers'?: string;\r\n        'accept-patch'?: string;\r\n        'accept-ranges'?: string;\r\n        'age'?: string;\r\n        'allow'?: string;\r\n        'alt-svc'?: string;\r\n        'cache-control'?: string;\r\n        'connection'?: string;\r\n        'content-disposition'?: string;\r\n        'content-encoding'?: string;\r\n        'content-language'?: string;\r\n        'content-length'?: string;\r\n        'content-location'?: string;\r\n        'content-range'?: string;\r\n        'content-type'?: string;\r\n        'date'?: string;\r\n        'expires'?: string;\r\n        'host'?: string;\r\n        'last-modified'?: string;\r\n        'location'?: string;\r\n        'pragma'?: string;\r\n        'proxy-authenticate'?: string;\r\n        'public-key-pins'?: string;\r\n        'retry-after'?: string;\r\n        'set-cookie'?: string[];\r\n        'strict-transport-security'?: string;\r\n        'trailer'?: string;\r\n        'transfer-encoding'?: string;\r\n        'tk'?: string;\r\n        'upgrade'?: string;\r\n        'vary'?: string;\r\n        'via'?: string;\r\n        'warning'?: string;\r\n        'www-authenticate'?: string;\r\n        [header: string]: string | string[] | undefined;\r\n    }\r\n\r\n    // outgoing headers allows numbers (as they are converted internally to strings)\r\n    export interface OutgoingHttpHeaders {\r\n        [header: string]: number | string | string[] | undefined;\r\n    }\r\n\r\n    export interface ClientRequestArgs {\r\n        protocol?: string;\r\n        host?: string;\r\n        hostname?: string;\r\n        family?: number;\r\n        port?: number | string;\r\n        defaultPort?: number | string;\r\n        localAddress?: string;\r\n        socketPath?: string;\r\n        method?: string;\r\n        path?: string;\r\n        headers?: OutgoingHttpHeaders;\r\n        auth?: string;\r\n        agent?: Agent | boolean;\r\n        _defaultAgent?: Agent;\r\n        timeout?: number;\r\n        // https://github.com/nodejs/node/blob/master/lib/_http_client.js#L278\r\n        createConnection?: (options: ClientRequestArgs, oncreate: (err: Error, socket: net.Socket) => void) => net.Socket;\r\n    }\r\n\r\n    export class Server extends net.Server {\r\n        constructor(requestListener?: (req: IncomingMessage, res: ServerResponse) => void);\r\n\r\n        setTimeout(msecs?: number, callback?: () => void): this;\r\n        setTimeout(callback: () => void): this;\r\n        maxHeadersCount: number;\r\n        timeout: number;\r\n        keepAliveTimeout: number;\r\n    }\r\n    /**\r\n     * @deprecated Use IncomingMessage\r\n     */\r\n    export class ServerRequest extends IncomingMessage {\r\n        connection: net.Socket;\r\n    }\r\n\r\n    // https://github.com/nodejs/node/blob/master/lib/_http_outgoing.js\r\n    export class OutgoingMessage extends stream.Writable {\r\n        upgrading: boolean;\r\n        chunkedEncoding: boolean;\r\n        shouldKeepAlive: boolean;\r\n        useChunkedEncodingByDefault: boolean;\r\n        sendDate: boolean;\r\n        finished: boolean;\r\n        headersSent: boolean;\r\n        connection: net.Socket;\r\n\r\n        constructor();\r\n\r\n        setTimeout(msecs: number, callback?: () => void): this;\r\n        destroy(error: Error): void;\r\n        setHeader(name: string, value: number | string | string[]): void;\r\n        getHeader(name: string): number | string | string[] | undefined;\r\n        getHeaders(): OutgoingHttpHeaders;\r\n        getHeaderNames(): string[];\r\n        hasHeader(name: string): boolean;\r\n        removeHeader(name: string): void;\r\n        addTrailers(headers: OutgoingHttpHeaders | Array<[string, string]>): void;\r\n        flushHeaders(): void;\r\n    }\r\n\r\n    // https://github.com/nodejs/node/blob/master/lib/_http_server.js#L108-L256\r\n    export class ServerResponse extends OutgoingMessage {\r\n        statusCode: number;\r\n        statusMessage: string;\r\n\r\n        constructor(req: IncomingMessage);\r\n\r\n        assignSocket(socket: net.Socket): void;\r\n        detachSocket(socket: net.Socket): void;\r\n        // https://github.com/nodejs/node/blob/master/test/parallel/test-http-write-callbacks.js#L53\r\n        // no args in writeContinue callback\r\n        writeContinue(callback?: () => void): void;\r\n        writeHead(statusCode: number, reasonPhrase?: string, headers?: OutgoingHttpHeaders): void;\r\n        writeHead(statusCode: number, headers?: OutgoingHttpHeaders): void;\r\n    }\r\n\r\n    // https://github.com/nodejs/node/blob/master/lib/_http_client.js#L77\r\n    export class ClientRequest extends OutgoingMessage {\r\n        connection: net.Socket;\r\n        socket: net.Socket;\r\n        aborted: number;\r\n\r\n        constructor(url: string | URL | ClientRequestArgs, cb?: (res: IncomingMessage) => void);\r\n\r\n        abort(): void;\r\n        onSocket(socket: net.Socket): void;\r\n        setTimeout(timeout: number, callback?: () => void): this;\r\n        setNoDelay(noDelay?: boolean): void;\r\n        setSocketKeepAlive(enable?: boolean, initialDelay?: number): void;\r\n    }\r\n\r\n    export class IncomingMessage extends stream.Readable {\r\n        constructor(socket: net.Socket);\r\n\r\n        httpVersion: string;\r\n        httpVersionMajor: number;\r\n        httpVersionMinor: number;\r\n        connection: net.Socket;\r\n        headers: IncomingHttpHeaders;\r\n        rawHeaders: string[];\r\n        trailers: { [key: string]: string | undefined };\r\n        rawTrailers: string[];\r\n        setTimeout(msecs: number, callback: () => void): this;\r\n        /**\r\n         * Only valid for request obtained from http.Server.\r\n         */\r\n        method?: string;\r\n        /**\r\n         * Only valid for request obtained from http.Server.\r\n         */\r\n        url?: string;\r\n        /**\r\n         * Only valid for response obtained from http.ClientRequest.\r\n         */\r\n        statusCode?: number;\r\n        /**\r\n         * Only valid for response obtained from http.ClientRequest.\r\n         */\r\n        statusMessage?: string;\r\n        socket: net.Socket;\r\n        destroy(error?: Error): void;\r\n    }\r\n\r\n    /**\r\n     * @deprecated Use IncomingMessage\r\n     */\r\n    export class ClientResponse extends IncomingMessage { }\r\n\r\n    export interface AgentOptions {\r\n        /**\r\n         * Keep sockets around in a pool to be used by other requests in the future. Default = false\r\n         */\r\n        keepAlive?: boolean;\r\n        /**\r\n         * When using HTTP KeepAlive, how often to send TCP KeepAlive packets over sockets being kept alive. Default = 1000.\r\n         * Only relevant if keepAlive is set to true.\r\n         */\r\n        keepAliveMsecs?: number;\r\n        /**\r\n         * Maximum number of sockets to allow per host. Default for Node 0.10 is 5, default for Node 0.12 is Infinity\r\n         */\r\n        maxSockets?: number;\r\n        /**\r\n         * Maximum number of sockets to leave open in a free state. Only relevant if keepAlive is set to true. Default = 256.\r\n         */\r\n        maxFreeSockets?: number;\r\n    }\r\n\r\n    export class Agent {\r\n        maxSockets: number;\r\n        sockets: any;\r\n        requests: any;\r\n\r\n        constructor(opts?: AgentOptions);\r\n\r\n        /**\r\n         * Destroy any sockets that are currently in use by the agent.\r\n         * It is usually not necessary to do this. However, if you are using an agent with KeepAlive enabled,\r\n         * then it is best to explicitly shut down the agent when you know that it will no longer be used. Otherwise,\r\n         * sockets may hang open for quite a long time before the server terminates them.\r\n         */\r\n        destroy(): void;\r\n    }\r\n\r\n    export var METHODS: string[];\r\n\r\n    export var STATUS_CODES: {\r\n        [errorCode: number]: string | undefined;\r\n        [errorCode: string]: string | undefined;\r\n    };\r\n\r\n    export function createServer(requestListener?: (request: IncomingMessage, response: ServerResponse) => void): Server;\r\n    export function createClient(port?: number, host?: string): any;\r\n\r\n    // although RequestOptions are passed as ClientRequestArgs to ClientRequest directly,\r\n    // create interface RequestOptions would make the naming more clear to developers\r\n    export interface RequestOptions extends ClientRequestArgs { }\r\n    export function request(options: RequestOptions | string | URL, callback?: (res: IncomingMessage) => void): ClientRequest;\r\n    export function get(options: RequestOptions | string | URL, callback?: (res: IncomingMessage) => void): ClientRequest;\r\n    export var globalAgent: Agent;\r\n}\r\n\r\ndeclare module \"cluster\" {\r\n    import * as child from \"child_process\";\r\n    import * as events from \"events\";\r\n    import * as net from \"net\";\r\n\r\n    // interfaces\r\n    export interface ClusterSettings {\r\n        execArgv?: string[]; // default: process.execArgv\r\n        exec?: string;\r\n        args?: string[];\r\n        silent?: boolean;\r\n        stdio?: any[];\r\n        uid?: number;\r\n        gid?: number;\r\n    }\r\n\r\n    export interface ClusterSetupMasterSettings {\r\n        exec?: string;  // default: process.argv[1]\r\n        args?: string[];  // default: process.argv.slice(2)\r\n        silent?: boolean;  // default: false\r\n        stdio?: any[];\r\n    }\r\n\r\n    export interface Address {\r\n        address: string;\r\n        port: number;\r\n        addressType: number | \"udp4\" | \"udp6\";  // 4, 6, -1, \"udp4\", \"udp6\"\r\n    }\r\n\r\n    export class Worker extends events.EventEmitter {\r\n        id: number;\r\n        process: child.ChildProcess;\r\n        suicide: boolean;\r\n        send(message: any, sendHandle?: any, callback?: (error: Error) => void): boolean;\r\n        kill(signal?: string): void;\r\n        destroy(signal?: string): void;\r\n        disconnect(): void;\r\n        isConnected(): boolean;\r\n        isDead(): boolean;\r\n        exitedAfterDisconnect: boolean;\r\n\r\n        /**\r\n         * events.EventEmitter\r\n         *   1. disconnect\r\n         *   2. error\r\n         *   3. exit\r\n         *   4. listening\r\n         *   5. message\r\n         *   6. online\r\n         */\r\n        addListener(event: string, listener: (...args: any[]) => void): this;\r\n        addListener(event: \"disconnect\", listener: () => void): this;\r\n        addListener(event: \"error\", listener: (error: Error) => void): this;\r\n        addListener(event: \"exit\", listener: (code: number, signal: string) => void): this;\r\n        addListener(event: \"listening\", listener: (address: Address) => void): this;\r\n        addListener(event: \"message\", listener: (message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\r\n        addListener(event: \"online\", listener: () => void): this;\r\n\r\n        emit(event: string | symbol, ...args: any[]): boolean;\r\n        emit(event: \"disconnect\"): boolean;\r\n        emit(event: \"error\", error: Error): boolean;\r\n        emit(event: \"exit\", code: number, signal: string): boolean;\r\n        emit(event: \"listening\", address: Address): boolean;\r\n        emit(event: \"message\", message: any, handle: net.Socket | net.Server): boolean;\r\n        emit(event: \"online\"): boolean;\r\n\r\n        on(event: string, listener: (...args: any[]) => void): this;\r\n        on(event: \"disconnect\", listener: () => void): this;\r\n        on(event: \"error\", listener: (error: Error) => void): this;\r\n        on(event: \"exit\", listener: (code: number, signal: string) => void): this;\r\n        on(event: \"listening\", listener: (address: Address) => void): this;\r\n        on(event: \"message\", listener: (message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\r\n        on(event: \"online\", listener: () => void): this;\r\n\r\n        once(event: string, listener: (...args: any[]) => void): this;\r\n        once(event: \"disconnect\", listener: () => void): this;\r\n        once(event: \"error\", listener: (error: Error) => void): this;\r\n        once(event: \"exit\", listener: (code: number, signal: string) => void): this;\r\n        once(event: \"listening\", listener: (address: Address) => void): this;\r\n        once(event: \"message\", listener: (message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\r\n        once(event: \"online\", listener: () => void): this;\r\n\r\n        prependListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependListener(event: \"disconnect\", listener: () => void): this;\r\n        prependListener(event: \"error\", listener: (error: Error) => void): this;\r\n        prependListener(event: \"exit\", listener: (code: number, signal: string) => void): this;\r\n        prependListener(event: \"listening\", listener: (address: Address) => void): this;\r\n        prependListener(event: \"message\", listener: (message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\r\n        prependListener(event: \"online\", listener: () => void): this;\r\n\r\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependOnceListener(event: \"disconnect\", listener: () => void): this;\r\n        prependOnceListener(event: \"error\", listener: (error: Error) => void): this;\r\n        prependOnceListener(event: \"exit\", listener: (code: number, signal: string) => void): this;\r\n        prependOnceListener(event: \"listening\", listener: (address: Address) => void): this;\r\n        prependOnceListener(event: \"message\", listener: (message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\r\n        prependOnceListener(event: \"online\", listener: () => void): this;\r\n    }\r\n\r\n    export interface Cluster extends events.EventEmitter {\r\n        Worker: Worker;\r\n        disconnect(callback?: Function): void;\r\n        fork(env?: any): Worker;\r\n        isMaster: boolean;\r\n        isWorker: boolean;\r\n        // TODO: cluster.schedulingPolicy\r\n        settings: ClusterSettings;\r\n        setupMaster(settings?: ClusterSetupMasterSettings): void;\r\n        worker?: Worker;\r\n        workers?: {\r\n            [index: string]: Worker | undefined\r\n        };\r\n\r\n        /**\r\n         * events.EventEmitter\r\n         *   1. disconnect\r\n         *   2. exit\r\n         *   3. fork\r\n         *   4. listening\r\n         *   5. message\r\n         *   6. online\r\n         *   7. setup\r\n         */\r\n        addListener(event: string, listener: (...args: any[]) => void): this;\r\n        addListener(event: \"disconnect\", listener: (worker: Worker) => void): this;\r\n        addListener(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): this;\r\n        addListener(event: \"fork\", listener: (worker: Worker) => void): this;\r\n        addListener(event: \"listening\", listener: (worker: Worker, address: Address) => void): this;\r\n        addListener(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\r\n        addListener(event: \"online\", listener: (worker: Worker) => void): this;\r\n        addListener(event: \"setup\", listener: (settings: any) => void): this;\r\n\r\n        emit(event: string | symbol, ...args: any[]): boolean;\r\n        emit(event: \"disconnect\", worker: Worker): boolean;\r\n        emit(event: \"exit\", worker: Worker, code: number, signal: string): boolean;\r\n        emit(event: \"fork\", worker: Worker): boolean;\r\n        emit(event: \"listening\", worker: Worker, address: Address): boolean;\r\n        emit(event: \"message\", worker: Worker, message: any, handle: net.Socket | net.Server): boolean;\r\n        emit(event: \"online\", worker: Worker): boolean;\r\n        emit(event: \"setup\", settings: any): boolean;\r\n\r\n        on(event: string, listener: (...args: any[]) => void): this;\r\n        on(event: \"disconnect\", listener: (worker: Worker) => void): this;\r\n        on(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): this;\r\n        on(event: \"fork\", listener: (worker: Worker) => void): this;\r\n        on(event: \"listening\", listener: (worker: Worker, address: Address) => void): this;\r\n        on(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\r\n        on(event: \"online\", listener: (worker: Worker) => void): this;\r\n        on(event: \"setup\", listener: (settings: any) => void): this;\r\n\r\n        once(event: string, listener: (...args: any[]) => void): this;\r\n        once(event: \"disconnect\", listener: (worker: Worker) => void): this;\r\n        once(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): this;\r\n        once(event: \"fork\", listener: (worker: Worker) => void): this;\r\n        once(event: \"listening\", listener: (worker: Worker, address: Address) => void): this;\r\n        once(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\r\n        once(event: \"online\", listener: (worker: Worker) => void): this;\r\n        once(event: \"setup\", listener: (settings: any) => void): this;\r\n\r\n        prependListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependListener(event: \"disconnect\", listener: (worker: Worker) => void): this;\r\n        prependListener(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): this;\r\n        prependListener(event: \"fork\", listener: (worker: Worker) => void): this;\r\n        prependListener(event: \"listening\", listener: (worker: Worker, address: Address) => void): this;\r\n        prependListener(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\r\n        prependListener(event: \"online\", listener: (worker: Worker) => void): this;\r\n        prependListener(event: \"setup\", listener: (settings: any) => void): this;\r\n\r\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependOnceListener(event: \"disconnect\", listener: (worker: Worker) => void): this;\r\n        prependOnceListener(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): this;\r\n        prependOnceListener(event: \"fork\", listener: (worker: Worker) => void): this;\r\n        prependOnceListener(event: \"listening\", listener: (worker: Worker, address: Address) => void): this;\r\n        prependOnceListener(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\r\n        prependOnceListener(event: \"online\", listener: (worker: Worker) => void): this;\r\n        prependOnceListener(event: \"setup\", listener: (settings: any) => void): this;\r\n    }\r\n\r\n    export function disconnect(callback?: Function): void;\r\n    export function fork(env?: any): Worker;\r\n    export var isMaster: boolean;\r\n    export var isWorker: boolean;\r\n    // TODO: cluster.schedulingPolicy\r\n    export var settings: ClusterSettings;\r\n    export function setupMaster(settings?: ClusterSetupMasterSettings): void;\r\n    export var worker: Worker;\r\n    export var workers: {\r\n        [index: string]: Worker | undefined\r\n    };\r\n\r\n    /**\r\n     * events.EventEmitter\r\n     *   1. disconnect\r\n     *   2. exit\r\n     *   3. fork\r\n     *   4. listening\r\n     *   5. message\r\n     *   6. online\r\n     *   7. setup\r\n     */\r\n    export function addListener(event: string, listener: (...args: any[]) => void): Cluster;\r\n    export function addListener(event: \"disconnect\", listener: (worker: Worker) => void): Cluster;\r\n    export function addListener(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): Cluster;\r\n    export function addListener(event: \"fork\", listener: (worker: Worker) => void): Cluster;\r\n    export function addListener(event: \"listening\", listener: (worker: Worker, address: Address) => void): Cluster;\r\n    export function addListener(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): Cluster;  // the handle is a net.Socket or net.Server object, or undefined.\r\n    export function addListener(event: \"online\", listener: (worker: Worker) => void): Cluster;\r\n    export function addListener(event: \"setup\", listener: (settings: any) => void): Cluster;\r\n\r\n    export function emit(event: string | symbol, ...args: any[]): boolean;\r\n    export function emit(event: \"disconnect\", worker: Worker): boolean;\r\n    export function emit(event: \"exit\", worker: Worker, code: number, signal: string): boolean;\r\n    export function emit(event: \"fork\", worker: Worker): boolean;\r\n    export function emit(event: \"listening\", worker: Worker, address: Address): boolean;\r\n    export function emit(event: \"message\", worker: Worker, message: any, handle: net.Socket | net.Server): boolean;\r\n    export function emit(event: \"online\", worker: Worker): boolean;\r\n    export function emit(event: \"setup\", settings: any): boolean;\r\n\r\n    export function on(event: string, listener: (...args: any[]) => void): Cluster;\r\n    export function on(event: \"disconnect\", listener: (worker: Worker) => void): Cluster;\r\n    export function on(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): Cluster;\r\n    export function on(event: \"fork\", listener: (worker: Worker) => void): Cluster;\r\n    export function on(event: \"listening\", listener: (worker: Worker, address: Address) => void): Cluster;\r\n    export function on(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): Cluster;  // the handle is a net.Socket or net.Server object, or undefined.\r\n    export function on(event: \"online\", listener: (worker: Worker) => void): Cluster;\r\n    export function on(event: \"setup\", listener: (settings: any) => void): Cluster;\r\n\r\n    export function once(event: string, listener: (...args: any[]) => void): Cluster;\r\n    export function once(event: \"disconnect\", listener: (worker: Worker) => void): Cluster;\r\n    export function once(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): Cluster;\r\n    export function once(event: \"fork\", listener: (worker: Worker) => void): Cluster;\r\n    export function once(event: \"listening\", listener: (worker: Worker, address: Address) => void): Cluster;\r\n    export function once(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): Cluster;  // the handle is a net.Socket or net.Server object, or undefined.\r\n    export function once(event: \"online\", listener: (worker: Worker) => void): Cluster;\r\n    export function once(event: \"setup\", listener: (settings: any) => void): Cluster;\r\n\r\n    export function removeListener(event: string, listener: (...args: any[]) => void): Cluster;\r\n    export function removeAllListeners(event?: string): Cluster;\r\n    export function setMaxListeners(n: number): Cluster;\r\n    export function getMaxListeners(): number;\r\n    export function listeners(event: string): Function[];\r\n    export function listenerCount(type: string): number;\r\n\r\n    export function prependListener(event: string, listener: (...args: any[]) => void): Cluster;\r\n    export function prependListener(event: \"disconnect\", listener: (worker: Worker) => void): Cluster;\r\n    export function prependListener(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): Cluster;\r\n    export function prependListener(event: \"fork\", listener: (worker: Worker) => void): Cluster;\r\n    export function prependListener(event: \"listening\", listener: (worker: Worker, address: Address) => void): Cluster;\r\n    export function prependListener(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): Cluster;  // the handle is a net.Socket or net.Server object, or undefined.\r\n    export function prependListener(event: \"online\", listener: (worker: Worker) => void): Cluster;\r\n    export function prependListener(event: \"setup\", listener: (settings: any) => void): Cluster;\r\n\r\n    export function prependOnceListener(event: string, listener: (...args: any[]) => void): Cluster;\r\n    export function prependOnceListener(event: \"disconnect\", listener: (worker: Worker) => void): Cluster;\r\n    export function prependOnceListener(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): Cluster;\r\n    export function prependOnceListener(event: \"fork\", listener: (worker: Worker) => void): Cluster;\r\n    export function prependOnceListener(event: \"listening\", listener: (worker: Worker, address: Address) => void): Cluster;\r\n    export function prependOnceListener(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): Cluster;  // the handle is a net.Socket or net.Server object, or undefined.\r\n    export function prependOnceListener(event: \"online\", listener: (worker: Worker) => void): Cluster;\r\n    export function prependOnceListener(event: \"setup\", listener: (settings: any) => void): Cluster;\r\n\r\n    export function eventNames(): string[];\r\n}\r\n\r\ndeclare module \"zlib\" {\r\n    import * as stream from \"stream\";\r\n\r\n    export interface ZlibOptions {\r\n        flush?: number; // default: zlib.constants.Z_NO_FLUSH\r\n        finishFlush?: number; // default: zlib.constants.Z_FINISH\r\n        chunkSize?: number; // default: 16*1024\r\n        windowBits?: number;\r\n        level?: number; // compression only\r\n        memLevel?: number; // compression only\r\n        strategy?: number; // compression only\r\n        dictionary?: any; // deflate/inflate only, empty dictionary by default\r\n    }\r\n\r\n    export interface Zlib {\r\n        readonly bytesRead: number;\r\n        close(callback?: () => void): void;\r\n        flush(kind?: number | (() => void), callback?: () => void): void;\r\n    }\r\n\r\n    export interface ZlibParams {\r\n        params(level: number, strategy: number, callback: () => void): void;\r\n    }\r\n\r\n    export interface ZlibReset {\r\n        reset(): void;\r\n    }\r\n\r\n    export interface Gzip extends stream.Transform, Zlib { }\r\n    export interface Gunzip extends stream.Transform, Zlib { }\r\n    export interface Deflate extends stream.Transform, Zlib, ZlibReset, ZlibParams { }\r\n    export interface Inflate extends stream.Transform, Zlib, ZlibReset { }\r\n    export interface DeflateRaw extends stream.Transform, Zlib, ZlibReset, ZlibParams { }\r\n    export interface InflateRaw extends stream.Transform, Zlib, ZlibReset { }\r\n    export interface Unzip extends stream.Transform, Zlib { }\r\n\r\n    export function createGzip(options?: ZlibOptions): Gzip;\r\n    export function createGunzip(options?: ZlibOptions): Gunzip;\r\n    export function createDeflate(options?: ZlibOptions): Deflate;\r\n    export function createInflate(options?: ZlibOptions): Inflate;\r\n    export function createDeflateRaw(options?: ZlibOptions): DeflateRaw;\r\n    export function createInflateRaw(options?: ZlibOptions): InflateRaw;\r\n    export function createUnzip(options?: ZlibOptions): Unzip;\r\n\r\n    export function deflate(buf: Buffer | string, callback: (error: Error | null, result: Buffer) => void): void;\r\n    export function deflate(buf: Buffer | string, options: ZlibOptions, callback: (error: Error | null, result: Buffer) => void): void;\r\n    export function deflateSync(buf: Buffer | string, options?: ZlibOptions): Buffer;\r\n    export function deflateRaw(buf: Buffer | string, callback: (error: Error | null, result: Buffer) => void): void;\r\n    export function deflateRaw(buf: Buffer | string, options: ZlibOptions, callback: (error: Error | null, result: Buffer) => void): void;\r\n    export function deflateRawSync(buf: Buffer | string, options?: ZlibOptions): Buffer;\r\n    export function gzip(buf: Buffer | string, callback: (error: Error | null, result: Buffer) => void): void;\r\n    export function gzip(buf: Buffer | string, options: ZlibOptions, callback: (error: Error | null, result: Buffer) => void): void;\r\n    export function gzipSync(buf: Buffer | string, options?: ZlibOptions): Buffer;\r\n    export function gunzip(buf: Buffer | string, callback: (error: Error | null, result: Buffer) => void): void;\r\n    export function gunzip(buf: Buffer | string, options: ZlibOptions, callback: (error: Error | null, result: Buffer) => void): void;\r\n    export function gunzipSync(buf: Buffer | string, options?: ZlibOptions): Buffer;\r\n    export function inflate(buf: Buffer | string, callback: (error: Error | null, result: Buffer) => void): void;\r\n    export function inflate(buf: Buffer | string, options: ZlibOptions, callback: (error: Error | null, result: Buffer) => void): void;\r\n    export function inflateSync(buf: Buffer | string, options?: ZlibOptions): Buffer;\r\n    export function inflateRaw(buf: Buffer | string, callback: (error: Error | null, result: Buffer) => void): void;\r\n    export function inflateRaw(buf: Buffer | string, options: ZlibOptions, callback: (error: Error | null, result: Buffer) => void): void;\r\n    export function inflateRawSync(buf: Buffer | string, options?: ZlibOptions): Buffer;\r\n    export function unzip(buf: Buffer | string, callback: (error: Error | null, result: Buffer) => void): void;\r\n    export function unzip(buf: Buffer | string, options: ZlibOptions, callback: (error: Error | null, result: Buffer) => void): void;\r\n    export function unzipSync(buf: Buffer | string, options?: ZlibOptions): Buffer;\r\n\r\n    export namespace constants {\r\n        // Allowed flush values.\r\n\r\n        export const Z_NO_FLUSH: number;\r\n        export const Z_PARTIAL_FLUSH: number;\r\n        export const Z_SYNC_FLUSH: number;\r\n        export const Z_FULL_FLUSH: number;\r\n        export const Z_FINISH: number;\r\n        export const Z_BLOCK: number;\r\n        export const Z_TREES: number;\r\n\r\n        // Return codes for the compression/decompression functions. Negative values are errors, positive values are used for special but normal events.\r\n\r\n        export const Z_OK: number;\r\n        export const Z_STREAM_END: number;\r\n        export const Z_NEED_DICT: number;\r\n        export const Z_ERRNO: number;\r\n        export const Z_STREAM_ERROR: number;\r\n        export const Z_DATA_ERROR: number;\r\n        export const Z_MEM_ERROR: number;\r\n        export const Z_BUF_ERROR: number;\r\n        export const Z_VERSION_ERROR: number;\r\n\r\n        // Compression levels.\r\n\r\n        export const Z_NO_COMPRESSION: number;\r\n        export const Z_BEST_SPEED: number;\r\n        export const Z_BEST_COMPRESSION: number;\r\n        export const Z_DEFAULT_COMPRESSION: number;\r\n\r\n        // Compression strategy.\r\n\r\n        export const Z_FILTERED: number;\r\n        export const Z_HUFFMAN_ONLY: number;\r\n        export const Z_RLE: number;\r\n        export const Z_FIXED: number;\r\n        export const Z_DEFAULT_STRATEGY: number;\r\n    }\r\n\r\n    // Constants\r\n    export var Z_NO_FLUSH: number;\r\n    export var Z_PARTIAL_FLUSH: number;\r\n    export var Z_SYNC_FLUSH: number;\r\n    export var Z_FULL_FLUSH: number;\r\n    export var Z_FINISH: number;\r\n    export var Z_BLOCK: number;\r\n    export var Z_TREES: number;\r\n    export var Z_OK: number;\r\n    export var Z_STREAM_END: number;\r\n    export var Z_NEED_DICT: number;\r\n    export var Z_ERRNO: number;\r\n    export var Z_STREAM_ERROR: number;\r\n    export var Z_DATA_ERROR: number;\r\n    export var Z_MEM_ERROR: number;\r\n    export var Z_BUF_ERROR: number;\r\n    export var Z_VERSION_ERROR: number;\r\n    export var Z_NO_COMPRESSION: number;\r\n    export var Z_BEST_SPEED: number;\r\n    export var Z_BEST_COMPRESSION: number;\r\n    export var Z_DEFAULT_COMPRESSION: number;\r\n    export var Z_FILTERED: number;\r\n    export var Z_HUFFMAN_ONLY: number;\r\n    export var Z_RLE: number;\r\n    export var Z_FIXED: number;\r\n    export var Z_DEFAULT_STRATEGY: number;\r\n    export var Z_BINARY: number;\r\n    export var Z_TEXT: number;\r\n    export var Z_ASCII: number;\r\n    export var Z_UNKNOWN: number;\r\n    export var Z_DEFLATED: number;\r\n}\r\n\r\ndeclare module \"os\" {\r\n    export interface CpuInfo {\r\n        model: string;\r\n        speed: number;\r\n        times: {\r\n            user: number;\r\n            nice: number;\r\n            sys: number;\r\n            idle: number;\r\n            irq: number;\r\n        };\r\n    }\r\n\r\n    export interface NetworkInterfaceBase {\r\n        address: string;\r\n        netmask: string;\r\n        mac: string;\r\n        internal: boolean;\r\n    }\r\n\r\n    export interface NetworkInterfaceInfoIPv4 extends NetworkInterfaceBase {\r\n        family: \"IPv4\";\r\n    }\r\n\r\n    export interface NetworkInterfaceInfoIPv6 extends NetworkInterfaceBase {\r\n        family: \"IPv6\";\r\n        scopeid: number;\r\n    }\r\n\r\n    export type NetworkInterfaceInfo = NetworkInterfaceInfoIPv4 | NetworkInterfaceInfoIPv6;\r\n\r\n    export function hostname(): string;\r\n    export function loadavg(): number[];\r\n    export function uptime(): number;\r\n    export function freemem(): number;\r\n    export function totalmem(): number;\r\n    export function cpus(): CpuInfo[];\r\n    export function type(): string;\r\n    export function release(): string;\r\n    export function networkInterfaces(): { [index: string]: NetworkInterfaceInfo[] };\r\n    export function homedir(): string;\r\n    export function userInfo(options?: { encoding: string }): { username: string, uid: number, gid: number, shell: any, homedir: string };\r\n    export var constants: {\r\n        UV_UDP_REUSEADDR: number,\r\n        signals: {\r\n            SIGHUP: number;\r\n            SIGINT: number;\r\n            SIGQUIT: number;\r\n            SIGILL: number;\r\n            SIGTRAP: number;\r\n            SIGABRT: number;\r\n            SIGIOT: number;\r\n            SIGBUS: number;\r\n            SIGFPE: number;\r\n            SIGKILL: number;\r\n            SIGUSR1: number;\r\n            SIGSEGV: number;\r\n            SIGUSR2: number;\r\n            SIGPIPE: number;\r\n            SIGALRM: number;\r\n            SIGTERM: number;\r\n            SIGCHLD: number;\r\n            SIGSTKFLT: number;\r\n            SIGCONT: number;\r\n            SIGSTOP: number;\r\n            SIGTSTP: number;\r\n            SIGTTIN: number;\r\n            SIGTTOU: number;\r\n            SIGURG: number;\r\n            SIGXCPU: number;\r\n            SIGXFSZ: number;\r\n            SIGVTALRM: number;\r\n            SIGPROF: number;\r\n            SIGWINCH: number;\r\n            SIGIO: number;\r\n            SIGPOLL: number;\r\n            SIGPWR: number;\r\n            SIGSYS: number;\r\n            SIGUNUSED: number;\r\n        },\r\n        errno: {\r\n            E2BIG: number;\r\n            EACCES: number;\r\n            EADDRINUSE: number;\r\n            EADDRNOTAVAIL: number;\r\n            EAFNOSUPPORT: number;\r\n            EAGAIN: number;\r\n            EALREADY: number;\r\n            EBADF: number;\r\n            EBADMSG: number;\r\n            EBUSY: number;\r\n            ECANCELED: number;\r\n            ECHILD: number;\r\n            ECONNABORTED: number;\r\n            ECONNREFUSED: number;\r\n            ECONNRESET: number;\r\n            EDEADLK: number;\r\n            EDESTADDRREQ: number;\r\n            EDOM: number;\r\n            EDQUOT: number;\r\n            EEXIST: number;\r\n            EFAULT: number;\r\n            EFBIG: number;\r\n            EHOSTUNREACH: number;\r\n            EIDRM: number;\r\n            EILSEQ: number;\r\n            EINPROGRESS: number;\r\n            EINTR: number;\r\n            EINVAL: number;\r\n            EIO: number;\r\n            EISCONN: number;\r\n            EISDIR: number;\r\n            ELOOP: number;\r\n            EMFILE: number;\r\n            EMLINK: number;\r\n            EMSGSIZE: number;\r\n            EMULTIHOP: number;\r\n            ENAMETOOLONG: number;\r\n            ENETDOWN: number;\r\n            ENETRESET: number;\r\n            ENETUNREACH: number;\r\n            ENFILE: number;\r\n            ENOBUFS: number;\r\n            ENODATA: number;\r\n            ENODEV: number;\r\n            ENOENT: number;\r\n            ENOEXEC: number;\r\n            ENOLCK: number;\r\n            ENOLINK: number;\r\n            ENOMEM: number;\r\n            ENOMSG: number;\r\n            ENOPROTOOPT: number;\r\n            ENOSPC: number;\r\n            ENOSR: number;\r\n            ENOSTR: number;\r\n            ENOSYS: number;\r\n            ENOTCONN: number;\r\n            ENOTDIR: number;\r\n            ENOTEMPTY: number;\r\n            ENOTSOCK: number;\r\n            ENOTSUP: number;\r\n            ENOTTY: number;\r\n            ENXIO: number;\r\n            EOPNOTSUPP: number;\r\n            EOVERFLOW: number;\r\n            EPERM: number;\r\n            EPIPE: number;\r\n            EPROTO: number;\r\n            EPROTONOSUPPORT: number;\r\n            EPROTOTYPE: number;\r\n            ERANGE: number;\r\n            EROFS: number;\r\n            ESPIPE: number;\r\n            ESRCH: number;\r\n            ESTALE: number;\r\n            ETIME: number;\r\n            ETIMEDOUT: number;\r\n            ETXTBSY: number;\r\n            EWOULDBLOCK: number;\r\n            EXDEV: number;\r\n        },\r\n    };\r\n    export function arch(): string;\r\n    export function platform(): NodeJS.Platform;\r\n    export function tmpdir(): string;\r\n    export var EOL: string;\r\n    export function endianness(): \"BE\" | \"LE\";\r\n}\r\n\r\ndeclare module \"https\" {\r\n    import * as tls from \"tls\";\r\n    import * as events from \"events\";\r\n    import * as http from \"http\";\r\n    import { URL } from \"url\";\r\n\r\n    export interface ServerOptions {\r\n        pfx?: any;\r\n        key?: any;\r\n        passphrase?: string;\r\n        cert?: any;\r\n        ca?: any;\r\n        crl?: any;\r\n        ciphers?: string;\r\n        honorCipherOrder?: boolean;\r\n        requestCert?: boolean;\r\n        rejectUnauthorized?: boolean;\r\n        NPNProtocols?: any;\r\n        SNICallback?: (servername: string, cb: (err: Error | null, ctx: tls.SecureContext) => void) => void;\r\n    }\r\n\r\n    export interface RequestOptions extends http.RequestOptions {\r\n        pfx?: any;\r\n        key?: any;\r\n        passphrase?: string;\r\n        cert?: any;\r\n        ca?: any;\r\n        ciphers?: string;\r\n        rejectUnauthorized?: boolean;\r\n        secureProtocol?: string;\r\n        servername?: string;\r\n    }\r\n\r\n    export interface AgentOptions extends http.AgentOptions, tls.ConnectionOptions {\r\n        rejectUnauthorized?: boolean;\r\n        maxCachedSessions?: number;\r\n    }\r\n\r\n    export class Agent extends http.Agent {\r\n        constructor(options?: AgentOptions);\r\n    }\r\n\r\n    export class Server extends tls.Server {\r\n        setTimeout(callback: () => void): this;\r\n        setTimeout(msecs?: number, callback?: () => void): this;\r\n        timeout: number;\r\n        keepAliveTimeout: number;\r\n    }\r\n\r\n    export function createServer(options: ServerOptions, requestListener?: (req: http.IncomingMessage, res: http.ServerResponse) => void): Server;\r\n    export function request(options: RequestOptions | string | URL, callback?: (res: http.IncomingMessage) => void): http.ClientRequest;\r\n    export function get(options: RequestOptions | string | URL, callback?: (res: http.IncomingMessage) => void): http.ClientRequest;\r\n    export var globalAgent: Agent;\r\n}\r\n\r\ndeclare module \"punycode\" {\r\n    export function decode(string: string): string;\r\n    export function encode(string: string): string;\r\n    export function toUnicode(domain: string): string;\r\n    export function toASCII(domain: string): string;\r\n    export var ucs2: ucs2;\r\n    interface ucs2 {\r\n        decode(string: string): number[];\r\n        encode(codePoints: number[]): string;\r\n    }\r\n    export var version: any;\r\n}\r\n\r\ndeclare module \"repl\" {\r\n    import * as stream from \"stream\";\r\n    import * as readline from \"readline\";\r\n\r\n    export interface ReplOptions {\r\n        prompt?: string;\r\n        input?: NodeJS.ReadableStream;\r\n        output?: NodeJS.WritableStream;\r\n        terminal?: boolean;\r\n        eval?: Function;\r\n        useColors?: boolean;\r\n        useGlobal?: boolean;\r\n        ignoreUndefined?: boolean;\r\n        writer?: Function;\r\n        completer?: Function;\r\n        replMode?: any;\r\n        breakEvalOnSigint?: any;\r\n    }\r\n\r\n    export interface REPLServer extends readline.ReadLine {\r\n        context: any;\r\n        inputStream: NodeJS.ReadableStream;\r\n        outputStream: NodeJS.WritableStream;\r\n\r\n        defineCommand(keyword: string, cmd: Function | { help: string, action: Function }): void;\r\n        displayPrompt(preserveCursor?: boolean): void;\r\n\r\n        /**\r\n         * events.EventEmitter\r\n         * 1. exit\r\n         * 2. reset\r\n         */\r\n\r\n        addListener(event: string, listener: (...args: any[]) => void): this;\r\n        addListener(event: \"exit\", listener: () => void): this;\r\n        addListener(event: \"reset\", listener: (...args: any[]) => void): this;\r\n\r\n        emit(event: string | symbol, ...args: any[]): boolean;\r\n        emit(event: \"exit\"): boolean;\r\n        emit(event: \"reset\", context: any): boolean;\r\n\r\n        on(event: string, listener: (...args: any[]) => void): this;\r\n        on(event: \"exit\", listener: () => void): this;\r\n        on(event: \"reset\", listener: (...args: any[]) => void): this;\r\n\r\n        once(event: string, listener: (...args: any[]) => void): this;\r\n        once(event: \"exit\", listener: () => void): this;\r\n        once(event: \"reset\", listener: (...args: any[]) => void): this;\r\n\r\n        prependListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependListener(event: \"exit\", listener: () => void): this;\r\n        prependListener(event: \"reset\", listener: (...args: any[]) => void): this;\r\n\r\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependOnceListener(event: \"exit\", listener: () => void): this;\r\n        prependOnceListener(event: \"reset\", listener: (...args: any[]) => void): this;\r\n    }\r\n\r\n    export function start(options?: string | ReplOptions): REPLServer;\r\n\r\n    export class Recoverable extends SyntaxError {\r\n        err: Error;\r\n\r\n        constructor(err: Error);\r\n    }\r\n}\r\n\r\ndeclare module \"readline\" {\r\n    import * as events from \"events\";\r\n    import * as stream from \"stream\";\r\n\r\n    export interface Key {\r\n        sequence?: string;\r\n        name?: string;\r\n        ctrl?: boolean;\r\n        meta?: boolean;\r\n        shift?: boolean;\r\n    }\r\n\r\n    export interface ReadLine extends events.EventEmitter {\r\n        setPrompt(prompt: string): void;\r\n        prompt(preserveCursor?: boolean): void;\r\n        question(query: string, callback: (answer: string) => void): void;\r\n        pause(): ReadLine;\r\n        resume(): ReadLine;\r\n        close(): void;\r\n        write(data: string | Buffer, key?: Key): void;\r\n\r\n        /**\r\n         * events.EventEmitter\r\n         * 1. close\r\n         * 2. line\r\n         * 3. pause\r\n         * 4. resume\r\n         * 5. SIGCONT\r\n         * 6. SIGINT\r\n         * 7. SIGTSTP\r\n         */\r\n\r\n        addListener(event: string, listener: (...args: any[]) => void): this;\r\n        addListener(event: \"close\", listener: () => void): this;\r\n        addListener(event: \"line\", listener: (input: any) => void): this;\r\n        addListener(event: \"pause\", listener: () => void): this;\r\n        addListener(event: \"resume\", listener: () => void): this;\r\n        addListener(event: \"SIGCONT\", listener: () => void): this;\r\n        addListener(event: \"SIGINT\", listener: () => void): this;\r\n        addListener(event: \"SIGTSTP\", listener: () => void): this;\r\n\r\n        emit(event: string | symbol, ...args: any[]): boolean;\r\n        emit(event: \"close\"): boolean;\r\n        emit(event: \"line\", input: any): boolean;\r\n        emit(event: \"pause\"): boolean;\r\n        emit(event: \"resume\"): boolean;\r\n        emit(event: \"SIGCONT\"): boolean;\r\n        emit(event: \"SIGINT\"): boolean;\r\n        emit(event: \"SIGTSTP\"): boolean;\r\n\r\n        on(event: string, listener: (...args: any[]) => void): this;\r\n        on(event: \"close\", listener: () => void): this;\r\n        on(event: \"line\", listener: (input: any) => void): this;\r\n        on(event: \"pause\", listener: () => void): this;\r\n        on(event: \"resume\", listener: () => void): this;\r\n        on(event: \"SIGCONT\", listener: () => void): this;\r\n        on(event: \"SIGINT\", listener: () => void): this;\r\n        on(event: \"SIGTSTP\", listener: () => void): this;\r\n\r\n        once(event: string, listener: (...args: any[]) => void): this;\r\n        once(event: \"close\", listener: () => void): this;\r\n        once(event: \"line\", listener: (input: any) => void): this;\r\n        once(event: \"pause\", listener: () => void): this;\r\n        once(event: \"resume\", listener: () => void): this;\r\n        once(event: \"SIGCONT\", listener: () => void): this;\r\n        once(event: \"SIGINT\", listener: () => void): this;\r\n        once(event: \"SIGTSTP\", listener: () => void): this;\r\n\r\n        prependListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependListener(event: \"close\", listener: () => void): this;\r\n        prependListener(event: \"line\", listener: (input: any) => void): this;\r\n        prependListener(event: \"pause\", listener: () => void): this;\r\n        prependListener(event: \"resume\", listener: () => void): this;\r\n        prependListener(event: \"SIGCONT\", listener: () => void): this;\r\n        prependListener(event: \"SIGINT\", listener: () => void): this;\r\n        prependListener(event: \"SIGTSTP\", listener: () => void): this;\r\n\r\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependOnceListener(event: \"close\", listener: () => void): this;\r\n        prependOnceListener(event: \"line\", listener: (input: any) => void): this;\r\n        prependOnceListener(event: \"pause\", listener: () => void): this;\r\n        prependOnceListener(event: \"resume\", listener: () => void): this;\r\n        prependOnceListener(event: \"SIGCONT\", listener: () => void): this;\r\n        prependOnceListener(event: \"SIGINT\", listener: () => void): this;\r\n        prependOnceListener(event: \"SIGTSTP\", listener: () => void): this;\r\n    }\r\n\r\n    type Completer = (line: string) => CompleterResult;\r\n    type AsyncCompleter = (line: string, callback: (err: any, result: CompleterResult) => void) => any;\r\n\r\n    export type CompleterResult = [string[], string];\r\n\r\n    export interface ReadLineOptions {\r\n        input: NodeJS.ReadableStream;\r\n        output?: NodeJS.WritableStream;\r\n        completer?: Completer | AsyncCompleter;\r\n        terminal?: boolean;\r\n        historySize?: number;\r\n    }\r\n\r\n    export function createInterface(input: NodeJS.ReadableStream, output?: NodeJS.WritableStream, completer?: Completer | AsyncCompleter, terminal?: boolean): ReadLine;\r\n    export function createInterface(options: ReadLineOptions): ReadLine;\r\n\r\n    export function cursorTo(stream: NodeJS.WritableStream, x: number, y?: number): void;\r\n    export function emitKeypressEvents(stream: NodeJS.ReadableStream, interface?: ReadLine): void;\r\n    export function moveCursor(stream: NodeJS.WritableStream, dx: number | string, dy: number | string): void;\r\n    export function clearLine(stream: NodeJS.WritableStream, dir: number): void;\r\n    export function clearScreenDown(stream: NodeJS.WritableStream): void;\r\n}\r\n\r\ndeclare module \"vm\" {\r\n    export interface Context { }\r\n    export interface ScriptOptions {\r\n        filename?: string;\r\n        lineOffset?: number;\r\n        columnOffset?: number;\r\n        displayErrors?: boolean;\r\n        timeout?: number;\r\n        cachedData?: Buffer;\r\n        produceCachedData?: boolean;\r\n    }\r\n    export interface RunningScriptOptions {\r\n        filename?: string;\r\n        lineOffset?: number;\r\n        columnOffset?: number;\r\n        displayErrors?: boolean;\r\n        timeout?: number;\r\n    }\r\n    export class Script {\r\n        constructor(code: string, options?: ScriptOptions);\r\n        runInContext(contextifiedSandbox: Context, options?: RunningScriptOptions): any;\r\n        runInNewContext(sandbox?: Context, options?: RunningScriptOptions): any;\r\n        runInThisContext(options?: RunningScriptOptions): any;\r\n    }\r\n    export function createContext(sandbox?: Context): Context;\r\n    export function isContext(sandbox: Context): boolean;\r\n    export function runInContext(code: string, contextifiedSandbox: Context, options?: RunningScriptOptions): any;\r\n    export function runInDebugContext(code: string): any;\r\n    export function runInNewContext(code: string, sandbox?: Context, options?: RunningScriptOptions): any;\r\n    export function runInThisContext(code: string, options?: RunningScriptOptions): any;\r\n}\r\n\r\ndeclare module \"child_process\" {\r\n    import * as events from \"events\";\r\n    import * as stream from \"stream\";\r\n    import * as net from \"net\";\r\n\r\n    export interface ChildProcess extends events.EventEmitter {\r\n        stdin: stream.Writable;\r\n        stdout: stream.Readable;\r\n        stderr: stream.Readable;\r\n        stdio: [stream.Writable, stream.Readable, stream.Readable];\r\n        killed: boolean;\r\n        pid: number;\r\n        kill(signal?: string): void;\r\n        send(message: any, callback?: (error: Error) => void): boolean;\r\n        send(message: any, sendHandle?: net.Socket | net.Server, callback?: (error: Error) => void): boolean;\r\n        send(message: any, sendHandle?: net.Socket | net.Server, options?: MessageOptions, callback?: (error: Error) => void): boolean;\r\n        connected: boolean;\r\n        disconnect(): void;\r\n        unref(): void;\r\n        ref(): void;\r\n\r\n        /**\r\n         * events.EventEmitter\r\n         * 1. close\r\n         * 2. disconnect\r\n         * 3. error\r\n         * 4. exit\r\n         * 5. message\r\n         */\r\n\r\n        addListener(event: string, listener: (...args: any[]) => void): this;\r\n        addListener(event: \"close\", listener: (code: number, signal: string) => void): this;\r\n        addListener(event: \"disconnect\", listener: () => void): this;\r\n        addListener(event: \"error\", listener: (err: Error) => void): this;\r\n        addListener(event: \"exit\", listener: (code: number, signal: string) => void): this;\r\n        addListener(event: \"message\", listener: (message: any, sendHandle: net.Socket | net.Server) => void): this;\r\n\r\n        emit(event: string | symbol, ...args: any[]): boolean;\r\n        emit(event: \"close\", code: number, signal: string): boolean;\r\n        emit(event: \"disconnect\"): boolean;\r\n        emit(event: \"error\", err: Error): boolean;\r\n        emit(event: \"exit\", code: number, signal: string): boolean;\r\n        emit(event: \"message\", message: any, sendHandle: net.Socket | net.Server): boolean;\r\n\r\n        on(event: string, listener: (...args: any[]) => void): this;\r\n        on(event: \"close\", listener: (code: number, signal: string) => void): this;\r\n        on(event: \"disconnect\", listener: () => void): this;\r\n        on(event: \"error\", listener: (err: Error) => void): this;\r\n        on(event: \"exit\", listener: (code: number, signal: string) => void): this;\r\n        on(event: \"message\", listener: (message: any, sendHandle: net.Socket | net.Server) => void): this;\r\n\r\n        once(event: string, listener: (...args: any[]) => void): this;\r\n        once(event: \"close\", listener: (code: number, signal: string) => void): this;\r\n        once(event: \"disconnect\", listener: () => void): this;\r\n        once(event: \"error\", listener: (err: Error) => void): this;\r\n        once(event: \"exit\", listener: (code: number, signal: string) => void): this;\r\n        once(event: \"message\", listener: (message: any, sendHandle: net.Socket | net.Server) => void): this;\r\n\r\n        prependListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependListener(event: \"close\", listener: (code: number, signal: string) => void): this;\r\n        prependListener(event: \"disconnect\", listener: () => void): this;\r\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\r\n        prependListener(event: \"exit\", listener: (code: number, signal: string) => void): this;\r\n        prependListener(event: \"message\", listener: (message: any, sendHandle: net.Socket | net.Server) => void): this;\r\n\r\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependOnceListener(event: \"close\", listener: (code: number, signal: string) => void): this;\r\n        prependOnceListener(event: \"disconnect\", listener: () => void): this;\r\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\r\n        prependOnceListener(event: \"exit\", listener: (code: number, signal: string) => void): this;\r\n        prependOnceListener(event: \"message\", listener: (message: any, sendHandle: net.Socket | net.Server) => void): this;\r\n    }\r\n\r\n    export interface MessageOptions {\r\n        keepOpen?: boolean;\r\n    }\r\n\r\n    export interface SpawnOptions {\r\n        cwd?: string;\r\n        env?: any;\r\n        stdio?: any;\r\n        detached?: boolean;\r\n        uid?: number;\r\n        gid?: number;\r\n        shell?: boolean | string;\r\n        windowsVerbatimArguments?: boolean;\r\n    }\r\n\r\n    export function spawn(command: string, args?: string[], options?: SpawnOptions): ChildProcess;\r\n\r\n    export interface ExecOptions {\r\n        cwd?: string;\r\n        env?: any;\r\n        shell?: string;\r\n        timeout?: number;\r\n        maxBuffer?: number;\r\n        killSignal?: string;\r\n        uid?: number;\r\n        gid?: number;\r\n    }\r\n\r\n    export interface ExecOptionsWithStringEncoding extends ExecOptions {\r\n        encoding: BufferEncoding;\r\n    }\r\n\r\n    export interface ExecOptionsWithBufferEncoding extends ExecOptions {\r\n        encoding: string | null; // specify `null`.\r\n    }\r\n\r\n    // no `options` definitely means stdout/stderr are `string`.\r\n    export function exec(command: string, callback?: (error: Error | null, stdout: string, stderr: string) => void): ChildProcess;\r\n\r\n    // `options` with `\"buffer\"` or `null` for `encoding` means stdout/stderr are definitely `Buffer`.\r\n    export function exec(command: string, options: { encoding: \"buffer\" | null } & ExecOptions, callback?: (error: Error | null, stdout: Buffer, stderr: Buffer) => void): ChildProcess;\r\n\r\n    // `options` with well known `encoding` means stdout/stderr are definitely `string`.\r\n    export function exec(command: string, options: { encoding: BufferEncoding } & ExecOptions, callback?: (error: Error | null, stdout: string, stderr: string) => void): ChildProcess;\r\n\r\n    // `options` with an `encoding` whose type is `string` means stdout/stderr could either be `Buffer` or `string`.\r\n    // There is no guarantee the `encoding` is unknown as `string` is a superset of `BufferEncoding`.\r\n    export function exec(command: string, options: { encoding: string } & ExecOptions, callback?: (error: Error | null, stdout: string | Buffer, stderr: string | Buffer) => void): ChildProcess;\r\n\r\n    // `options` without an `encoding` means stdout/stderr are definitely `string`.\r\n    export function exec(command: string, options: ExecOptions, callback?: (error: Error | null, stdout: string, stderr: string) => void): ChildProcess;\r\n\r\n    // fallback if nothing else matches. Worst case is always `string | Buffer`.\r\n    export function exec(command: string, options: ({ encoding?: string | null } & ExecOptions) | undefined | null, callback?: (error: Error | null, stdout: string | Buffer, stderr: string | Buffer) => void): ChildProcess;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace exec {\r\n        export function __promisify__(command: string): Promise<{ stdout: string, stderr: string }>;\r\n        export function __promisify__(command: string, options: { encoding: \"buffer\" | null } & ExecOptions): Promise<{ stdout: Buffer, stderr: Buffer }>;\r\n        export function __promisify__(command: string, options: { encoding: BufferEncoding } & ExecOptions): Promise<{ stdout: string, stderr: string }>;\r\n        export function __promisify__(command: string, options: ExecOptions): Promise<{ stdout: string, stderr: string }>;\r\n        export function __promisify__(command: string, options?: ({ encoding?: string | null } & ExecOptions) | null): Promise<{ stdout: string | Buffer, stderr: string | Buffer }>;\r\n    }\r\n\r\n    export interface ExecFileOptions {\r\n        cwd?: string;\r\n        env?: any;\r\n        timeout?: number;\r\n        maxBuffer?: number;\r\n        killSignal?: string;\r\n        uid?: number;\r\n        gid?: number;\r\n        windowsVerbatimArguments?: boolean;\r\n    }\r\n    export interface ExecFileOptionsWithStringEncoding extends ExecFileOptions {\r\n        encoding: BufferEncoding;\r\n    }\r\n    export interface ExecFileOptionsWithBufferEncoding extends ExecFileOptions {\r\n        encoding: 'buffer' | null;\r\n    }\r\n    export interface ExecFileOptionsWithOtherEncoding extends ExecFileOptions {\r\n        encoding: string;\r\n    }\r\n\r\n    export function execFile(file: string): ChildProcess;\r\n    export function execFile(file: string, options: ({ encoding?: string | null } & ExecFileOptions) | undefined | null): ChildProcess;\r\n    export function execFile(file: string, args: string[] | undefined | null): ChildProcess;\r\n    export function execFile(file: string, args: string[] | undefined | null, options: ({ encoding?: string | null } & ExecFileOptions) | undefined | null): ChildProcess;\r\n\r\n    // no `options` definitely means stdout/stderr are `string`.\r\n    export function execFile(file: string, callback: (error: Error | null, stdout: string, stderr: string) => void): ChildProcess;\r\n    export function execFile(file: string, args: string[] | undefined | null, callback: (error: Error | null, stdout: string, stderr: string) => void): ChildProcess;\r\n\r\n    // `options` with `\"buffer\"` or `null` for `encoding` means stdout/stderr are definitely `Buffer`.\r\n    export function execFile(file: string, options: ExecFileOptionsWithBufferEncoding, callback: (error: Error | null, stdout: Buffer, stderr: Buffer) => void): ChildProcess;\r\n    export function execFile(file: string, args: string[] | undefined | null, options: ExecFileOptionsWithBufferEncoding, callback: (error: Error | null, stdout: Buffer, stderr: Buffer) => void): ChildProcess;\r\n\r\n    // `options` with well known `encoding` means stdout/stderr are definitely `string`.\r\n    export function execFile(file: string, options: ExecFileOptionsWithStringEncoding, callback: (error: Error | null, stdout: string, stderr: string) => void): ChildProcess;\r\n    export function execFile(file: string, args: string[] | undefined | null, options: ExecFileOptionsWithStringEncoding, callback: (error: Error | null, stdout: string, stderr: string) => void): ChildProcess;\r\n\r\n    // `options` with an `encoding` whose type is `string` means stdout/stderr could either be `Buffer` or `string`.\r\n    // There is no guarantee the `encoding` is unknown as `string` is a superset of `BufferEncoding`.\r\n    export function execFile(file: string, options: ExecFileOptionsWithOtherEncoding, callback: (error: Error | null, stdout: string | Buffer, stderr: string | Buffer) => void): ChildProcess;\r\n    export function execFile(file: string, args: string[] | undefined | null, options: ExecFileOptionsWithOtherEncoding, callback: (error: Error | null, stdout: string | Buffer, stderr: string | Buffer) => void): ChildProcess;\r\n\r\n    // `options` without an `encoding` means stdout/stderr are definitely `string`.\r\n    export function execFile(file: string, options: ExecFileOptions, callback: (error: Error | null, stdout: string, stderr: string) => void): ChildProcess;\r\n    export function execFile(file: string, args: string[] | undefined | null, options: ExecFileOptions, callback: (error: Error | null, stdout: string, stderr: string) => void): ChildProcess;\r\n\r\n    // fallback if nothing else matches. Worst case is always `string | Buffer`.\r\n    export function execFile(file: string, options: ({ encoding?: string | null } & ExecFileOptions) | undefined | null, callback: ((error: Error | null, stdout: string | Buffer, stderr: string | Buffer) => void) | undefined | null): ChildProcess;\r\n    export function execFile(file: string, args: string[] | undefined | null, options: ({ encoding?: string | null } & ExecFileOptions) | undefined | null, callback: ((error: Error | null, stdout: string | Buffer, stderr: string | Buffer) => void) | undefined | null): ChildProcess;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace execFile {\r\n        export function __promisify__(file: string): Promise<{ stdout: string, stderr: string }>;\r\n        export function __promisify__(file: string, args: string[] | undefined | null): Promise<{ stdout: string, stderr: string }>;\r\n        export function __promisify__(file: string, options: ExecFileOptionsWithBufferEncoding): Promise<{ stdout: Buffer, stderr: Buffer }>;\r\n        export function __promisify__(file: string, args: string[] | undefined | null, options: ExecFileOptionsWithBufferEncoding): Promise<{ stdout: Buffer, stderr: Buffer }>;\r\n        export function __promisify__(file: string, options: ExecFileOptionsWithStringEncoding): Promise<{ stdout: string, stderr: string }>;\r\n        export function __promisify__(file: string, args: string[] | undefined | null, options: ExecFileOptionsWithStringEncoding): Promise<{ stdout: string, stderr: string }>;\r\n        export function __promisify__(file: string, options: ExecFileOptionsWithOtherEncoding): Promise<{ stdout: string | Buffer, stderr: string | Buffer }>;\r\n        export function __promisify__(file: string, args: string[] | undefined | null, options: ExecFileOptionsWithOtherEncoding): Promise<{ stdout: string | Buffer, stderr: string | Buffer }>;\r\n        export function __promisify__(file: string, options: ExecFileOptions): Promise<{ stdout: string, stderr: string }>;\r\n        export function __promisify__(file: string, args: string[] | undefined | null, options: ExecFileOptions): Promise<{ stdout: string, stderr: string }>;\r\n        export function __promisify__(file: string, options: ({ encoding?: string | null } & ExecFileOptions) | undefined | null): Promise<{ stdout: string | Buffer, stderr: string | Buffer }>;\r\n        export function __promisify__(file: string, args: string[] | undefined | null, options: ({ encoding?: string | null } & ExecFileOptions) | undefined | null): Promise<{ stdout: string | Buffer, stderr: string | Buffer }>;\r\n    }\r\n\r\n    export interface ForkOptions {\r\n        cwd?: string;\r\n        env?: any;\r\n        execPath?: string;\r\n        execArgv?: string[];\r\n        silent?: boolean;\r\n        stdio?: any[];\r\n        uid?: number;\r\n        gid?: number;\r\n        windowsVerbatimArguments?: boolean;\r\n    }\r\n    export function fork(modulePath: string, args?: string[], options?: ForkOptions): ChildProcess;\r\n\r\n    export interface SpawnSyncOptions {\r\n        cwd?: string;\r\n        input?: string | Buffer;\r\n        stdio?: any;\r\n        env?: any;\r\n        uid?: number;\r\n        gid?: number;\r\n        timeout?: number;\r\n        killSignal?: string;\r\n        maxBuffer?: number;\r\n        encoding?: string;\r\n        shell?: boolean | string;\r\n        windowsVerbatimArguments?: boolean;\r\n    }\r\n    export interface SpawnSyncOptionsWithStringEncoding extends SpawnSyncOptions {\r\n        encoding: BufferEncoding;\r\n    }\r\n    export interface SpawnSyncOptionsWithBufferEncoding extends SpawnSyncOptions {\r\n        encoding: string; // specify `null`.\r\n    }\r\n    export interface SpawnSyncReturns<T> {\r\n        pid: number;\r\n        output: string[];\r\n        stdout: T;\r\n        stderr: T;\r\n        status: number;\r\n        signal: string;\r\n        error: Error;\r\n    }\r\n    export function spawnSync(command: string): SpawnSyncReturns<Buffer>;\r\n    export function spawnSync(command: string, options?: SpawnSyncOptionsWithStringEncoding): SpawnSyncReturns<string>;\r\n    export function spawnSync(command: string, options?: SpawnSyncOptionsWithBufferEncoding): SpawnSyncReturns<Buffer>;\r\n    export function spawnSync(command: string, options?: SpawnSyncOptions): SpawnSyncReturns<Buffer>;\r\n    export function spawnSync(command: string, args?: string[], options?: SpawnSyncOptionsWithStringEncoding): SpawnSyncReturns<string>;\r\n    export function spawnSync(command: string, args?: string[], options?: SpawnSyncOptionsWithBufferEncoding): SpawnSyncReturns<Buffer>;\r\n    export function spawnSync(command: string, args?: string[], options?: SpawnSyncOptions): SpawnSyncReturns<Buffer>;\r\n\r\n    export interface ExecSyncOptions {\r\n        cwd?: string;\r\n        input?: string | Buffer;\r\n        stdio?: any;\r\n        env?: any;\r\n        shell?: string;\r\n        uid?: number;\r\n        gid?: number;\r\n        timeout?: number;\r\n        killSignal?: string;\r\n        maxBuffer?: number;\r\n        encoding?: string;\r\n    }\r\n    export interface ExecSyncOptionsWithStringEncoding extends ExecSyncOptions {\r\n        encoding: BufferEncoding;\r\n    }\r\n    export interface ExecSyncOptionsWithBufferEncoding extends ExecSyncOptions {\r\n        encoding: string; // specify `null`.\r\n    }\r\n    export function execSync(command: string): Buffer;\r\n    export function execSync(command: string, options?: ExecSyncOptionsWithStringEncoding): string;\r\n    export function execSync(command: string, options?: ExecSyncOptionsWithBufferEncoding): Buffer;\r\n    export function execSync(command: string, options?: ExecSyncOptions): Buffer;\r\n\r\n    export interface ExecFileSyncOptions {\r\n        cwd?: string;\r\n        input?: string | Buffer;\r\n        stdio?: any;\r\n        env?: any;\r\n        uid?: number;\r\n        gid?: number;\r\n        timeout?: number;\r\n        killSignal?: string;\r\n        maxBuffer?: number;\r\n        encoding?: string;\r\n    }\r\n    export interface ExecFileSyncOptionsWithStringEncoding extends ExecFileSyncOptions {\r\n        encoding: BufferEncoding;\r\n    }\r\n    export interface ExecFileSyncOptionsWithBufferEncoding extends ExecFileSyncOptions {\r\n        encoding: string; // specify `null`.\r\n    }\r\n    export function execFileSync(command: string): Buffer;\r\n    export function execFileSync(command: string, options?: ExecFileSyncOptionsWithStringEncoding): string;\r\n    export function execFileSync(command: string, options?: ExecFileSyncOptionsWithBufferEncoding): Buffer;\r\n    export function execFileSync(command: string, options?: ExecFileSyncOptions): Buffer;\r\n    export function execFileSync(command: string, args?: string[], options?: ExecFileSyncOptionsWithStringEncoding): string;\r\n    export function execFileSync(command: string, args?: string[], options?: ExecFileSyncOptionsWithBufferEncoding): Buffer;\r\n    export function execFileSync(command: string, args?: string[], options?: ExecFileSyncOptions): Buffer;\r\n}\r\n\r\ndeclare module \"url\" {\r\n    import { ParsedUrlQuery } from 'querystring';\r\n\r\n    export interface UrlObjectCommon {\r\n        auth?: string;\r\n        hash?: string;\r\n        host?: string;\r\n        hostname?: string;\r\n        href?: string;\r\n        path?: string;\r\n        pathname?: string;\r\n        protocol?: string;\r\n        search?: string;\r\n        slashes?: boolean;\r\n    }\r\n\r\n    // Input to `url.format`\r\n    export interface UrlObject extends UrlObjectCommon {\r\n        port?: string | number;\r\n        query?: string | null | { [key: string]: any };\r\n    }\r\n\r\n    // Output of `url.parse`\r\n    export interface Url extends UrlObjectCommon {\r\n        port?: string;\r\n        query?: string | null | ParsedUrlQuery;\r\n    }\r\n\r\n    export function parse(urlStr: string, parseQueryString?: boolean, slashesDenoteHost?: boolean): Url;\r\n    export function format(URL: URL, options?: URLFormatOptions): string;\r\n    export function format(urlObject: UrlObject | string): string;\r\n    export function resolve(from: string, to: string): string;\r\n\r\n    export interface URLFormatOptions {\r\n        auth?: boolean;\r\n        fragment?: boolean;\r\n        search?: boolean;\r\n        unicode?: boolean;\r\n    }\r\n\r\n    export class URLSearchParams implements Iterable<[string, string]> {\r\n        constructor(init?: URLSearchParams | string | { [key: string]: string | string[] | undefined } | Iterable<[string, string]> | Array<[string, string]>);\r\n        append(name: string, value: string): void;\r\n        delete(name: string): void;\r\n        entries(): IterableIterator<[string, string]>;\r\n        forEach(callback: (value: string, name: string) => void): void;\r\n        get(name: string): string | null;\r\n        getAll(name: string): string[];\r\n        has(name: string): boolean;\r\n        keys(): IterableIterator<string>;\r\n        set(name: string, value: string): void;\r\n        sort(): void;\r\n        toString(): string;\r\n        values(): IterableIterator<string>;\r\n        [Symbol.iterator](): IterableIterator<[string, string]>;\r\n    }\r\n\r\n    export class URL {\r\n        constructor(input: string, base?: string | URL);\r\n        hash: string;\r\n        host: string;\r\n        hostname: string;\r\n        href: string;\r\n        readonly origin: string;\r\n        password: string;\r\n        pathname: string;\r\n        port: string;\r\n        protocol: string;\r\n        search: string;\r\n        readonly searchParams: URLSearchParams;\r\n        username: string;\r\n        toString(): string;\r\n        toJSON(): string;\r\n    }\r\n}\r\n\r\ndeclare module \"dns\" {\r\n    // Supported getaddrinfo flags.\r\n    export const ADDRCONFIG: number;\r\n    export const V4MAPPED: number;\r\n\r\n    export interface LookupOptions {\r\n        family?: number;\r\n        hints?: number;\r\n        all?: boolean;\r\n    }\r\n\r\n    export interface LookupOneOptions extends LookupOptions {\r\n        all?: false;\r\n    }\r\n\r\n    export interface LookupAllOptions extends LookupOptions {\r\n        all: true;\r\n    }\r\n\r\n    export interface LookupAddress {\r\n        address: string;\r\n        family: number;\r\n    }\r\n\r\n    export function lookup(hostname: string, family: number, callback: (err: NodeJS.ErrnoException, address: string, family: number) => void): void;\r\n    export function lookup(hostname: string, options: LookupOneOptions, callback: (err: NodeJS.ErrnoException, address: string, family: number) => void): void;\r\n    export function lookup(hostname: string, options: LookupAllOptions, callback: (err: NodeJS.ErrnoException, addresses: LookupAddress[]) => void): void;\r\n    export function lookup(hostname: string, options: LookupOptions, callback: (err: NodeJS.ErrnoException, address: string | LookupAddress[], family: number) => void): void;\r\n    export function lookup(hostname: string, callback: (err: NodeJS.ErrnoException, address: string, family: number) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace lookup {\r\n        export function __promisify__(hostname: string, options: LookupAllOptions): Promise<{ address: LookupAddress[] }>;\r\n        export function __promisify__(hostname: string, options?: LookupOneOptions | number): Promise<{ address: string, family: number }>;\r\n        export function __promisify__(hostname: string, options?: LookupOptions | number): Promise<{ address: string | LookupAddress[], family?: number }>;\r\n    }\r\n\r\n    export interface ResolveOptions {\r\n        ttl: boolean;\r\n    }\r\n\r\n    export interface ResolveWithTtlOptions extends ResolveOptions {\r\n        ttl: true;\r\n    }\r\n\r\n    export interface RecordWithTtl {\r\n        address: string;\r\n        ttl: number;\r\n    }\r\n\r\n    export interface MxRecord {\r\n        priority: number;\r\n        exchange: string;\r\n    }\r\n\r\n    export interface NaptrRecord {\r\n        flags: string;\r\n        service: string;\r\n        regexp: string;\r\n        replacement: string;\r\n        order: number;\r\n        preference: number;\r\n    }\r\n\r\n    export interface SoaRecord {\r\n        nsname: string;\r\n        hostmaster: string;\r\n        serial: number;\r\n        refresh: number;\r\n        retry: number;\r\n        expire: number;\r\n        minttl: number;\r\n    }\r\n\r\n    export interface SrvRecord {\r\n        priority: number;\r\n        weight: number;\r\n        port: number;\r\n        name: string;\r\n    }\r\n\r\n    export function resolve(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\r\n    export function resolve(hostname: string, rrtype: \"A\", callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\r\n    export function resolve(hostname: string, rrtype: \"AAAA\", callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\r\n    export function resolve(hostname: string, rrtype: \"CNAME\", callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\r\n    export function resolve(hostname: string, rrtype: \"MX\", callback: (err: NodeJS.ErrnoException, addresses: MxRecord[]) => void): void;\r\n    export function resolve(hostname: string, rrtype: \"NAPTR\", callback: (err: NodeJS.ErrnoException, addresses: NaptrRecord[]) => void): void;\r\n    export function resolve(hostname: string, rrtype: \"NS\", callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\r\n    export function resolve(hostname: string, rrtype: \"PTR\", callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\r\n    export function resolve(hostname: string, rrtype: \"SOA\", callback: (err: NodeJS.ErrnoException, addresses: SoaRecord) => void): void;\r\n    export function resolve(hostname: string, rrtype: \"SRV\", callback: (err: NodeJS.ErrnoException, addresses: SrvRecord[]) => void): void;\r\n    export function resolve(hostname: string, rrtype: \"TXT\", callback: (err: NodeJS.ErrnoException, addresses: string[][]) => void): void;\r\n    export function resolve(hostname: string, rrtype: string, callback: (err: NodeJS.ErrnoException, addresses: string[] | MxRecord[] | NaptrRecord[] | SoaRecord | SrvRecord[] | string[][]) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace resolve {\r\n        export function __promisify__(hostname: string, rrtype?: \"A\" | \"AAAA\" | \"CNAME\" | \"NS\" | \"PTR\"): Promise<string[]>;\r\n        export function __promisify__(hostname: string, rrtype: \"MX\"): Promise<MxRecord[]>;\r\n        export function __promisify__(hostname: string, rrtype: \"NAPTR\"): Promise<NaptrRecord[]>;\r\n        export function __promisify__(hostname: string, rrtype: \"SOA\"): Promise<SoaRecord>;\r\n        export function __promisify__(hostname: string, rrtype: \"SRV\"): Promise<SrvRecord[]>;\r\n        export function __promisify__(hostname: string, rrtype: \"TXT\"): Promise<string[][]>;\r\n        export function __promisify__(hostname: string, rrtype?: string): Promise<string[] | MxRecord[] | NaptrRecord[] | SoaRecord | SrvRecord[] | string[][]>;\r\n    }\r\n\r\n    export function resolve4(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\r\n    export function resolve4(hostname: string, options: ResolveWithTtlOptions, callback: (err: NodeJS.ErrnoException, addresses: RecordWithTtl[]) => void): void;\r\n    export function resolve4(hostname: string, options: ResolveOptions, callback: (err: NodeJS.ErrnoException, addresses: string[] | RecordWithTtl[]) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace resolve4 {\r\n        export function __promisify__(hostname: string): Promise<string[]>;\r\n        export function __promisify__(hostname: string, options: ResolveWithTtlOptions): Promise<RecordWithTtl[]>;\r\n        export function __promisify__(hostname: string, options?: ResolveOptions): Promise<string[] | RecordWithTtl[]>;\r\n    }\r\n\r\n    export function resolve6(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\r\n    export function resolve6(hostname: string, options: ResolveWithTtlOptions, callback: (err: NodeJS.ErrnoException, addresses: RecordWithTtl[]) => void): void;\r\n    export function resolve6(hostname: string, options: ResolveOptions, callback: (err: NodeJS.ErrnoException, addresses: string[] | RecordWithTtl[]) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace resolve6 {\r\n        export function __promisify__(hostname: string): Promise<string[]>;\r\n        export function __promisify__(hostname: string, options: ResolveWithTtlOptions): Promise<RecordWithTtl[]>;\r\n        export function __promisify__(hostname: string, options?: ResolveOptions): Promise<string[] | RecordWithTtl[]>;\r\n    }\r\n\r\n    export function resolveCname(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\r\n    export function resolveMx(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: MxRecord[]) => void): void;\r\n    export function resolveNaptr(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: NaptrRecord[]) => void): void;\r\n    export function resolveNs(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\r\n    export function resolvePtr(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\r\n    export function resolveSoa(hostname: string, callback: (err: NodeJS.ErrnoException, address: SoaRecord) => void): void;\r\n    export function resolveSrv(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: SrvRecord[]) => void): void;\r\n    export function resolveTxt(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[][]) => void): void;\r\n\r\n    export function reverse(ip: string, callback: (err: NodeJS.ErrnoException, hostnames: string[]) => void): void;\r\n    export function setServers(servers: string[]): void;\r\n\r\n    // Error codes\r\n    export var NODATA: string;\r\n    export var FORMERR: string;\r\n    export var SERVFAIL: string;\r\n    export var NOTFOUND: string;\r\n    export var NOTIMP: string;\r\n    export var REFUSED: string;\r\n    export var BADQUERY: string;\r\n    export var BADNAME: string;\r\n    export var BADFAMILY: string;\r\n    export var BADRESP: string;\r\n    export var CONNREFUSED: string;\r\n    export var TIMEOUT: string;\r\n    export var EOF: string;\r\n    export var FILE: string;\r\n    export var NOMEM: string;\r\n    export var DESTRUCTION: string;\r\n    export var BADSTR: string;\r\n    export var BADFLAGS: string;\r\n    export var NONAME: string;\r\n    export var BADHINTS: string;\r\n    export var NOTINITIALIZED: string;\r\n    export var LOADIPHLPAPI: string;\r\n    export var ADDRGETNETWORKPARAMS: string;\r\n    export var CANCELLED: string;\r\n}\r\n\r\ndeclare module \"net\" {\r\n    import * as stream from \"stream\";\r\n    import * as events from \"events\";\r\n    import * as dns from \"dns\";\r\n\r\n    type LookupFunction = (hostname: string, options: dns.LookupOneOptions, callback: (err: NodeJS.ErrnoException | null, address: string, family: number) => void) => void;\r\n\r\n    export interface SocketConstructorOpts {\r\n        fd?: number;\r\n        allowHalfOpen?: boolean;\r\n        readable?: boolean;\r\n        writable?: boolean;\r\n    }\r\n\r\n    export interface TcpSocketConnectOpts {\r\n        port: number;\r\n        host?: string;\r\n        localAddress?: string;\r\n        localPort?: number;\r\n        hints?: number;\r\n        family?: number;\r\n        lookup?: LookupFunction;\r\n    }\r\n\r\n    export interface IpcSocketConnectOpts {\r\n        path: string;\r\n    }\r\n\r\n    export type SocketConnectOpts = TcpSocketConnectOpts | IpcSocketConnectOpts;\r\n\r\n    export class Socket extends stream.Duplex {\r\n        constructor(options?: SocketConstructorOpts);\r\n\r\n        // Extended base methods\r\n        write(buffer: Buffer): boolean;\r\n        write(buffer: Buffer, cb?: Function): boolean;\r\n        write(str: string, cb?: Function): boolean;\r\n        write(str: string, encoding?: string, cb?: Function): boolean;\r\n        write(str: string, encoding?: string, fd?: string): boolean;\r\n        write(data: any, encoding?: string, callback?: Function): void;\r\n\r\n        connect(options: SocketConnectOpts, connectionListener?: Function): this;\r\n        connect(port: number, host: string, connectionListener?: Function): this;\r\n        connect(port: number, connectionListener?: Function): this;\r\n        connect(path: string, connectionListener?: Function): this;\r\n\r\n        bufferSize: number;\r\n        setEncoding(encoding?: string): this;\r\n        destroy(err?: any): void;\r\n        pause(): this;\r\n        resume(): this;\r\n        setTimeout(timeout: number, callback?: Function): void;\r\n        setNoDelay(noDelay?: boolean): void;\r\n        setKeepAlive(enable?: boolean, initialDelay?: number): void;\r\n        address(): { port: number; family: string; address: string; };\r\n        unref(): void;\r\n        ref(): void;\r\n\r\n        remoteAddress?: string;\r\n        remoteFamily?: string;\r\n        remotePort?: number;\r\n        localAddress: string;\r\n        localPort: number;\r\n        bytesRead: number;\r\n        bytesWritten: number;\r\n        connecting: boolean;\r\n        destroyed: boolean;\r\n\r\n        // Extended base methods\r\n        end(): void;\r\n        end(buffer: Buffer, cb?: Function): void;\r\n        end(str: string, cb?: Function): void;\r\n        end(str: string, encoding?: string, cb?: Function): void;\r\n        end(data?: any, encoding?: string): void;\r\n\r\n        /**\r\n         * events.EventEmitter\r\n         *   1. close\r\n         *   2. connect\r\n         *   3. data\r\n         *   4. drain\r\n         *   5. end\r\n         *   6. error\r\n         *   7. lookup\r\n         *   8. timeout\r\n         */\r\n        addListener(event: string, listener: (...args: any[]) => void): this;\r\n        addListener(event: \"close\", listener: (had_error: boolean) => void): this;\r\n        addListener(event: \"connect\", listener: () => void): this;\r\n        addListener(event: \"data\", listener: (data: Buffer) => void): this;\r\n        addListener(event: \"drain\", listener: () => void): this;\r\n        addListener(event: \"end\", listener: () => void): this;\r\n        addListener(event: \"error\", listener: (err: Error) => void): this;\r\n        addListener(event: \"lookup\", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\r\n        addListener(event: \"timeout\", listener: () => void): this;\r\n\r\n        emit(event: string | symbol, ...args: any[]): boolean;\r\n        emit(event: \"close\", had_error: boolean): boolean;\r\n        emit(event: \"connect\"): boolean;\r\n        emit(event: \"data\", data: Buffer): boolean;\r\n        emit(event: \"drain\"): boolean;\r\n        emit(event: \"end\"): boolean;\r\n        emit(event: \"error\", err: Error): boolean;\r\n        emit(event: \"lookup\", err: Error, address: string, family: string | number, host: string): boolean;\r\n        emit(event: \"timeout\"): boolean;\r\n\r\n        on(event: string, listener: (...args: any[]) => void): this;\r\n        on(event: \"close\", listener: (had_error: boolean) => void): this;\r\n        on(event: \"connect\", listener: () => void): this;\r\n        on(event: \"data\", listener: (data: Buffer) => void): this;\r\n        on(event: \"drain\", listener: () => void): this;\r\n        on(event: \"end\", listener: () => void): this;\r\n        on(event: \"error\", listener: (err: Error) => void): this;\r\n        on(event: \"lookup\", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\r\n        on(event: \"timeout\", listener: () => void): this;\r\n\r\n        once(event: string, listener: (...args: any[]) => void): this;\r\n        once(event: \"close\", listener: (had_error: boolean) => void): this;\r\n        once(event: \"connect\", listener: () => void): this;\r\n        once(event: \"data\", listener: (data: Buffer) => void): this;\r\n        once(event: \"drain\", listener: () => void): this;\r\n        once(event: \"end\", listener: () => void): this;\r\n        once(event: \"error\", listener: (err: Error) => void): this;\r\n        once(event: \"lookup\", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\r\n        once(event: \"timeout\", listener: () => void): this;\r\n\r\n        prependListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependListener(event: \"close\", listener: (had_error: boolean) => void): this;\r\n        prependListener(event: \"connect\", listener: () => void): this;\r\n        prependListener(event: \"data\", listener: (data: Buffer) => void): this;\r\n        prependListener(event: \"drain\", listener: () => void): this;\r\n        prependListener(event: \"end\", listener: () => void): this;\r\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\r\n        prependListener(event: \"lookup\", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\r\n        prependListener(event: \"timeout\", listener: () => void): this;\r\n\r\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependOnceListener(event: \"close\", listener: (had_error: boolean) => void): this;\r\n        prependOnceListener(event: \"connect\", listener: () => void): this;\r\n        prependOnceListener(event: \"data\", listener: (data: Buffer) => void): this;\r\n        prependOnceListener(event: \"drain\", listener: () => void): this;\r\n        prependOnceListener(event: \"end\", listener: () => void): this;\r\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\r\n        prependOnceListener(event: \"lookup\", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\r\n        prependOnceListener(event: \"timeout\", listener: () => void): this;\r\n    }\r\n\r\n    export interface ListenOptions {\r\n        port?: number;\r\n        host?: string;\r\n        backlog?: number;\r\n        path?: string;\r\n        exclusive?: boolean;\r\n    }\r\n\r\n    // https://github.com/nodejs/node/blob/master/lib/net.js\r\n    export class Server extends events.EventEmitter {\r\n        constructor(connectionListener?: (socket: Socket) => void);\r\n        constructor(options?: { allowHalfOpen?: boolean, pauseOnConnect?: boolean }, connectionListener?: (socket: Socket) => void);\r\n\r\n        listen(port?: number, hostname?: string, backlog?: number, listeningListener?: Function): this;\r\n        listen(port?: number, hostname?: string, listeningListener?: Function): this;\r\n        listen(port?: number, backlog?: number, listeningListener?: Function): this;\r\n        listen(port?: number, listeningListener?: Function): this;\r\n        listen(path: string, backlog?: number, listeningListener?: Function): this;\r\n        listen(path: string, listeningListener?: Function): this;\r\n        listen(options: ListenOptions, listeningListener?: Function): this;\r\n        listen(handle: any, backlog?: number, listeningListener?: Function): this;\r\n        listen(handle: any, listeningListener?: Function): this;\r\n        close(callback?: Function): this;\r\n        address(): { port: number; family: string; address: string; };\r\n        getConnections(cb: (error: Error | null, count: number) => void): void;\r\n        ref(): this;\r\n        unref(): this;\r\n        maxConnections: number;\r\n        connections: number;\r\n        listening: boolean;\r\n\r\n        /**\r\n         * events.EventEmitter\r\n         *   1. close\r\n         *   2. connection\r\n         *   3. error\r\n         *   4. listening\r\n         */\r\n        addListener(event: string, listener: (...args: any[]) => void): this;\r\n        addListener(event: \"close\", listener: () => void): this;\r\n        addListener(event: \"connection\", listener: (socket: Socket) => void): this;\r\n        addListener(event: \"error\", listener: (err: Error) => void): this;\r\n        addListener(event: \"listening\", listener: () => void): this;\r\n\r\n        emit(event: string | symbol, ...args: any[]): boolean;\r\n        emit(event: \"close\"): boolean;\r\n        emit(event: \"connection\", socket: Socket): boolean;\r\n        emit(event: \"error\", err: Error): boolean;\r\n        emit(event: \"listening\"): boolean;\r\n\r\n        on(event: string, listener: (...args: any[]) => void): this;\r\n        on(event: \"close\", listener: () => void): this;\r\n        on(event: \"connection\", listener: (socket: Socket) => void): this;\r\n        on(event: \"error\", listener: (err: Error) => void): this;\r\n        on(event: \"listening\", listener: () => void): this;\r\n\r\n        once(event: string, listener: (...args: any[]) => void): this;\r\n        once(event: \"close\", listener: () => void): this;\r\n        once(event: \"connection\", listener: (socket: Socket) => void): this;\r\n        once(event: \"error\", listener: (err: Error) => void): this;\r\n        once(event: \"listening\", listener: () => void): this;\r\n\r\n        prependListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependListener(event: \"close\", listener: () => void): this;\r\n        prependListener(event: \"connection\", listener: (socket: Socket) => void): this;\r\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\r\n        prependListener(event: \"listening\", listener: () => void): this;\r\n\r\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependOnceListener(event: \"close\", listener: () => void): this;\r\n        prependOnceListener(event: \"connection\", listener: (socket: Socket) => void): this;\r\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\r\n        prependOnceListener(event: \"listening\", listener: () => void): this;\r\n    }\r\n\r\n    export interface TcpNetConnectOpts extends TcpSocketConnectOpts, SocketConstructorOpts {\r\n        timeout?: number;\r\n    }\r\n\r\n    export interface IpcNetConnectOpts extends IpcSocketConnectOpts, SocketConstructorOpts {\r\n        timeout?: number;\r\n    }\r\n\r\n    export type NetConnectOpts = TcpNetConnectOpts | IpcNetConnectOpts;\r\n\r\n    export function createServer(connectionListener?: (socket: Socket) => void): Server;\r\n    export function createServer(options?: { allowHalfOpen?: boolean, pauseOnConnect?: boolean }, connectionListener?: (socket: Socket) => void): Server;\r\n    export function connect(options: NetConnectOpts, connectionListener?: Function): Socket;\r\n    export function connect(port: number, host?: string, connectionListener?: Function): Socket;\r\n    export function connect(path: string, connectionListener?: Function): Socket;\r\n    export function createConnection(options: NetConnectOpts, connectionListener?: Function): Socket;\r\n    export function createConnection(port: number, host?: string, connectionListener?: Function): Socket;\r\n    export function createConnection(path: string, connectionListener?: Function): Socket;\r\n    export function isIP(input: string): number;\r\n    export function isIPv4(input: string): boolean;\r\n    export function isIPv6(input: string): boolean;\r\n}\r\n\r\ndeclare module \"dgram\" {\r\n    import * as events from \"events\";\r\n    import * as dns from \"dns\";\r\n\r\n    interface RemoteInfo {\r\n        address: string;\r\n        family: string;\r\n        port: number;\r\n    }\r\n\r\n    interface AddressInfo {\r\n        address: string;\r\n        family: string;\r\n        port: number;\r\n    }\r\n\r\n    interface BindOptions {\r\n        port: number;\r\n        address?: string;\r\n        exclusive?: boolean;\r\n    }\r\n\r\n    type SocketType = \"udp4\" | \"udp6\";\r\n\r\n    interface SocketOptions {\r\n        type: SocketType;\r\n        reuseAddr?: boolean;\r\n        recvBufferSize?: number;\r\n        sendBufferSize?: number;\r\n        lookup?: (hostname: string, options: dns.LookupOneOptions, callback: (err: NodeJS.ErrnoException, address: string, family: number) => void) => void;\r\n    }\r\n\r\n    export function createSocket(type: SocketType, callback?: (msg: Buffer, rinfo: RemoteInfo) => void): Socket;\r\n    export function createSocket(options: SocketOptions, callback?: (msg: Buffer, rinfo: RemoteInfo) => void): Socket;\r\n\r\n    export class Socket extends events.EventEmitter {\r\n        send(msg: Buffer | String | any[], port: number, address: string, callback?: (error: Error | null, bytes: number) => void): void;\r\n        send(msg: Buffer | String | any[], offset: number, length: number, port: number, address: string, callback?: (error: Error | null, bytes: number) => void): void;\r\n        bind(port?: number, address?: string, callback?: () => void): void;\r\n        bind(port?: number, callback?: () => void): void;\r\n        bind(callback?: () => void): void;\r\n        bind(options: BindOptions, callback?: Function): void;\r\n        close(callback?: () => void): void;\r\n        address(): AddressInfo;\r\n        setBroadcast(flag: boolean): void;\r\n        setTTL(ttl: number): void;\r\n        setMulticastTTL(ttl: number): void;\r\n        setMulticastInterface(multicastInterface: string): void;\r\n        setMulticastLoopback(flag: boolean): void;\r\n        addMembership(multicastAddress: string, multicastInterface?: string): void;\r\n        dropMembership(multicastAddress: string, multicastInterface?: string): void;\r\n        ref(): this;\r\n        unref(): this;\r\n        setRecvBufferSize(size: number): void;\r\n        setSendBufferSize(size: number): void;\r\n        getRecvBufferSize(): number;\r\n        getSendBufferSize(): number;\r\n\r\n        /**\r\n         * events.EventEmitter\r\n         * 1. close\r\n         * 2. error\r\n         * 3. listening\r\n         * 4. message\r\n         */\r\n        addListener(event: string, listener: (...args: any[]) => void): this;\r\n        addListener(event: \"close\", listener: () => void): this;\r\n        addListener(event: \"error\", listener: (err: Error) => void): this;\r\n        addListener(event: \"listening\", listener: () => void): this;\r\n        addListener(event: \"message\", listener: (msg: Buffer, rinfo: AddressInfo) => void): this;\r\n\r\n        emit(event: string | symbol, ...args: any[]): boolean;\r\n        emit(event: \"close\"): boolean;\r\n        emit(event: \"error\", err: Error): boolean;\r\n        emit(event: \"listening\"): boolean;\r\n        emit(event: \"message\", msg: Buffer, rinfo: AddressInfo): boolean;\r\n\r\n        on(event: string, listener: (...args: any[]) => void): this;\r\n        on(event: \"close\", listener: () => void): this;\r\n        on(event: \"error\", listener: (err: Error) => void): this;\r\n        on(event: \"listening\", listener: () => void): this;\r\n        on(event: \"message\", listener: (msg: Buffer, rinfo: AddressInfo) => void): this;\r\n\r\n        once(event: string, listener: (...args: any[]) => void): this;\r\n        once(event: \"close\", listener: () => void): this;\r\n        once(event: \"error\", listener: (err: Error) => void): this;\r\n        once(event: \"listening\", listener: () => void): this;\r\n        once(event: \"message\", listener: (msg: Buffer, rinfo: AddressInfo) => void): this;\r\n\r\n        prependListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependListener(event: \"close\", listener: () => void): this;\r\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\r\n        prependListener(event: \"listening\", listener: () => void): this;\r\n        prependListener(event: \"message\", listener: (msg: Buffer, rinfo: AddressInfo) => void): this;\r\n\r\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependOnceListener(event: \"close\", listener: () => void): this;\r\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\r\n        prependOnceListener(event: \"listening\", listener: () => void): this;\r\n        prependOnceListener(event: \"message\", listener: (msg: Buffer, rinfo: AddressInfo) => void): this;\r\n    }\r\n}\r\n\r\ndeclare module \"fs\" {\r\n    import * as stream from \"stream\";\r\n    import * as events from \"events\";\r\n    import { URL } from \"url\";\r\n\r\n    /**\r\n     * Valid types for path values in \"fs\".\r\n     */\r\n    export type PathLike = string | Buffer | URL;\r\n\r\n    export class Stats {\r\n        isFile(): boolean;\r\n        isDirectory(): boolean;\r\n        isBlockDevice(): boolean;\r\n        isCharacterDevice(): boolean;\r\n        isSymbolicLink(): boolean;\r\n        isFIFO(): boolean;\r\n        isSocket(): boolean;\r\n        dev: number;\r\n        ino: number;\r\n        mode: number;\r\n        nlink: number;\r\n        uid: number;\r\n        gid: number;\r\n        rdev: number;\r\n        size: number;\r\n        blksize: number;\r\n        blocks: number;\r\n        atimeMs: number;\r\n        mtimeMs: number;\r\n        ctimeMs: number;\r\n        birthtimeMs: number;\r\n        atime: Date;\r\n        mtime: Date;\r\n        ctime: Date;\r\n        birthtime: Date;\r\n    }\r\n\r\n    export interface FSWatcher extends events.EventEmitter {\r\n        close(): void;\r\n\r\n        /**\r\n         * events.EventEmitter\r\n         *   1. change\r\n         *   2. error\r\n         */\r\n        addListener(event: string, listener: (...args: any[]) => void): this;\r\n        addListener(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\r\n        addListener(event: \"error\", listener: (error: Error) => void): this;\r\n\r\n        on(event: string, listener: (...args: any[]) => void): this;\r\n        on(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\r\n        on(event: \"error\", listener: (error: Error) => void): this;\r\n\r\n        once(event: string, listener: (...args: any[]) => void): this;\r\n        once(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\r\n        once(event: \"error\", listener: (error: Error) => void): this;\r\n\r\n        prependListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependListener(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\r\n        prependListener(event: \"error\", listener: (error: Error) => void): this;\r\n\r\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependOnceListener(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\r\n        prependOnceListener(event: \"error\", listener: (error: Error) => void): this;\r\n    }\r\n\r\n    export class ReadStream extends stream.Readable {\r\n        close(): void;\r\n        destroy(): void;\r\n        bytesRead: number;\r\n        path: string | Buffer;\r\n\r\n        /**\r\n         * events.EventEmitter\r\n         *   1. open\r\n         *   2. close\r\n         */\r\n        addListener(event: string, listener: (...args: any[]) => void): this;\r\n        addListener(event: \"open\", listener: (fd: number) => void): this;\r\n        addListener(event: \"close\", listener: () => void): this;\r\n\r\n        on(event: string, listener: (...args: any[]) => void): this;\r\n        on(event: \"open\", listener: (fd: number) => void): this;\r\n        on(event: \"close\", listener: () => void): this;\r\n\r\n        once(event: string, listener: (...args: any[]) => void): this;\r\n        once(event: \"open\", listener: (fd: number) => void): this;\r\n        once(event: \"close\", listener: () => void): this;\r\n\r\n        prependListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependListener(event: \"open\", listener: (fd: number) => void): this;\r\n        prependListener(event: \"close\", listener: () => void): this;\r\n\r\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependOnceListener(event: \"open\", listener: (fd: number) => void): this;\r\n        prependOnceListener(event: \"close\", listener: () => void): this;\r\n    }\r\n\r\n    export class WriteStream extends stream.Writable {\r\n        close(): void;\r\n        bytesWritten: number;\r\n        path: string | Buffer;\r\n\r\n        /**\r\n         * events.EventEmitter\r\n         *   1. open\r\n         *   2. close\r\n         */\r\n        addListener(event: string, listener: (...args: any[]) => void): this;\r\n        addListener(event: \"open\", listener: (fd: number) => void): this;\r\n        addListener(event: \"close\", listener: () => void): this;\r\n\r\n        on(event: string, listener: (...args: any[]) => void): this;\r\n        on(event: \"open\", listener: (fd: number) => void): this;\r\n        on(event: \"close\", listener: () => void): this;\r\n\r\n        once(event: string, listener: (...args: any[]) => void): this;\r\n        once(event: \"open\", listener: (fd: number) => void): this;\r\n        once(event: \"close\", listener: () => void): this;\r\n\r\n        prependListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependListener(event: \"open\", listener: (fd: number) => void): this;\r\n        prependListener(event: \"close\", listener: () => void): this;\r\n\r\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependOnceListener(event: \"open\", listener: (fd: number) => void): this;\r\n        prependOnceListener(event: \"close\", listener: () => void): this;\r\n    }\r\n\r\n    /**\r\n     * Asynchronous rename(2) - Change the name or location of a file or directory.\r\n     * @param oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * URL support is _experimental_.\r\n     * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * URL support is _experimental_.\r\n     */\r\n    export function rename(oldPath: PathLike, newPath: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace rename {\r\n        /**\r\n         * Asynchronous rename(2) - Change the name or location of a file or directory.\r\n         * @param oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n         * URL support is _experimental_.\r\n         * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n         * URL support is _experimental_.\r\n         */\r\n        export function __promisify__(oldPath: PathLike, newPath: PathLike): Promise<void>;\r\n    }\r\n\r\n    /**\r\n     * Synchronous rename(2) - Change the name or location of a file or directory.\r\n     * @param oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * URL support is _experimental_.\r\n     * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * URL support is _experimental_.\r\n     */\r\n    export function renameSync(oldPath: PathLike, newPath: PathLike): void;\r\n\r\n    /**\r\n     * Asynchronous truncate(2) - Truncate a file to a specified length.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param len If not specified, defaults to `0`.\r\n     */\r\n    export function truncate(path: PathLike, len: number | undefined | null, callback: (err: NodeJS.ErrnoException) => void): void;\r\n\r\n    /**\r\n     * Asynchronous truncate(2) - Truncate a file to a specified length.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * URL support is _experimental_.\r\n     */\r\n    export function truncate(path: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace truncate {\r\n        /**\r\n         * Asynchronous truncate(2) - Truncate a file to a specified length.\r\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n         * @param len If not specified, defaults to `0`.\r\n         */\r\n        export function __promisify__(path: PathLike, len?: number | null): Promise<void>;\r\n    }\r\n\r\n    /**\r\n     * Synchronous truncate(2) - Truncate a file to a specified length.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param len If not specified, defaults to `0`.\r\n     */\r\n    export function truncateSync(path: PathLike, len?: number | null): void;\r\n\r\n    /**\r\n     * Asynchronous ftruncate(2) - Truncate a file to a specified length.\r\n     * @param fd A file descriptor.\r\n     * @param len If not specified, defaults to `0`.\r\n     */\r\n    export function ftruncate(fd: number, len: number | undefined | null, callback: (err: NodeJS.ErrnoException) => void): void;\r\n\r\n    /**\r\n     * Asynchronous ftruncate(2) - Truncate a file to a specified length.\r\n     * @param fd A file descriptor.\r\n     */\r\n    export function ftruncate(fd: number, callback: (err: NodeJS.ErrnoException) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace ftruncate {\r\n        /**\r\n         * Asynchronous ftruncate(2) - Truncate a file to a specified length.\r\n         * @param fd A file descriptor.\r\n         * @param len If not specified, defaults to `0`.\r\n         */\r\n        export function __promisify__(fd: number, len?: number | null): Promise<void>;\r\n    }\r\n\r\n    /**\r\n     * Synchronous ftruncate(2) - Truncate a file to a specified length.\r\n     * @param fd A file descriptor.\r\n     * @param len If not specified, defaults to `0`.\r\n     */\r\n    export function ftruncateSync(fd: number, len?: number | null): void;\r\n\r\n    /**\r\n     * Asynchronous chown(2) - Change ownership of a file.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     */\r\n    export function chown(path: PathLike, uid: number, gid: number, callback: (err: NodeJS.ErrnoException) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace chown {\r\n        /**\r\n         * Asynchronous chown(2) - Change ownership of a file.\r\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n         */\r\n        export function __promisify__(path: PathLike, uid: number, gid: number): Promise<void>;\r\n    }\r\n\r\n    /**\r\n     * Synchronous chown(2) - Change ownership of a file.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     */\r\n    export function chownSync(path: PathLike, uid: number, gid: number): void;\r\n\r\n    /**\r\n     * Asynchronous fchown(2) - Change ownership of a file.\r\n     * @param fd A file descriptor.\r\n     */\r\n    export function fchown(fd: number, uid: number, gid: number, callback: (err: NodeJS.ErrnoException) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace fchown {\r\n        /**\r\n         * Asynchronous fchown(2) - Change ownership of a file.\r\n         * @param fd A file descriptor.\r\n         */\r\n        export function __promisify__(fd: number, uid: number, gid: number): Promise<void>;\r\n    }\r\n\r\n    /**\r\n     * Synchronous fchown(2) - Change ownership of a file.\r\n     * @param fd A file descriptor.\r\n     */\r\n    export function fchownSync(fd: number, uid: number, gid: number): void;\r\n\r\n    /**\r\n     * Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     */\r\n    export function lchown(path: PathLike, uid: number, gid: number, callback: (err: NodeJS.ErrnoException) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace lchown {\r\n        /**\r\n         * Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.\r\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n         */\r\n        export function __promisify__(path: PathLike, uid: number, gid: number): Promise<void>;\r\n    }\r\n\r\n    /**\r\n     * Synchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     */\r\n    export function lchownSync(path: PathLike, uid: number, gid: number): void;\r\n\r\n    /**\r\n     * Asynchronous chmod(2) - Change permissions of a file.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\r\n     */\r\n    export function chmod(path: PathLike, mode: string | number, callback: (err: NodeJS.ErrnoException) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace chmod {\r\n        /**\r\n         * Asynchronous chmod(2) - Change permissions of a file.\r\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\r\n         */\r\n        export function __promisify__(path: PathLike, mode: string | number): Promise<void>;\r\n    }\r\n\r\n    /**\r\n     * Synchronous chmod(2) - Change permissions of a file.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\r\n     */\r\n    export function chmodSync(path: PathLike, mode: string | number): void;\r\n\r\n    /**\r\n     * Asynchronous fchmod(2) - Change permissions of a file.\r\n     * @param fd A file descriptor.\r\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\r\n     */\r\n    export function fchmod(fd: number, mode: string | number, callback: (err: NodeJS.ErrnoException) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace fchmod {\r\n        /**\r\n         * Asynchronous fchmod(2) - Change permissions of a file.\r\n         * @param fd A file descriptor.\r\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\r\n         */\r\n        export function __promisify__(fd: number, mode: string | number): Promise<void>;\r\n    }\r\n\r\n    /**\r\n     * Synchronous fchmod(2) - Change permissions of a file.\r\n     * @param fd A file descriptor.\r\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\r\n     */\r\n    export function fchmodSync(fd: number, mode: string | number): void;\r\n\r\n    /**\r\n     * Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\r\n     */\r\n    export function lchmod(path: PathLike, mode: string | number, callback: (err: NodeJS.ErrnoException) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace lchmod {\r\n        /**\r\n         * Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.\r\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\r\n         */\r\n        export function __promisify__(path: PathLike, mode: string | number): Promise<void>;\r\n    }\r\n\r\n    /**\r\n     * Synchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\r\n     */\r\n    export function lchmodSync(path: PathLike, mode: string | number): void;\r\n\r\n    /**\r\n     * Asynchronous stat(2) - Get file status.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     */\r\n    export function stat(path: PathLike, callback: (err: NodeJS.ErrnoException, stats: Stats) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace stat {\r\n        /**\r\n         * Asynchronous stat(2) - Get file status.\r\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n         */\r\n        export function __promisify__(path: PathLike): Promise<Stats>;\r\n    }\r\n\r\n    /**\r\n     * Synchronous stat(2) - Get file status.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     */\r\n    export function statSync(path: PathLike): Stats;\r\n\r\n    /**\r\n     * Asynchronous fstat(2) - Get file status.\r\n     * @param fd A file descriptor.\r\n     */\r\n    export function fstat(fd: number, callback: (err: NodeJS.ErrnoException, stats: Stats) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace fstat {\r\n        /**\r\n         * Asynchronous fstat(2) - Get file status.\r\n         * @param fd A file descriptor.\r\n         */\r\n        export function __promisify__(fd: number): Promise<Stats>;\r\n    }\r\n\r\n    /**\r\n     * Synchronous fstat(2) - Get file status.\r\n     * @param fd A file descriptor.\r\n     */\r\n    export function fstatSync(fd: number): Stats;\r\n\r\n    /**\r\n     * Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     */\r\n    export function lstat(path: PathLike, callback: (err: NodeJS.ErrnoException, stats: Stats) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace lstat {\r\n        /**\r\n         * Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.\r\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n         */\r\n        export function __promisify__(path: PathLike): Promise<Stats>;\r\n    }\r\n\r\n    /**\r\n     * Synchronous lstat(2) - Get file status. Does not dereference symbolic links.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     */\r\n    export function lstatSync(path: PathLike): Stats;\r\n\r\n    /**\r\n     * Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.\r\n     * @param existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     */\r\n    export function link(existingPath: PathLike, newPath: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace link {\r\n        /**\r\n         * Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.\r\n         * @param existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n         * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n         */\r\n        export function link(existingPath: PathLike, newPath: PathLike): Promise<void>;\r\n    }\r\n\r\n    /**\r\n     * Synchronous link(2) - Create a new link (also known as a hard link) to an existing file.\r\n     * @param existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     */\r\n    export function linkSync(existingPath: PathLike, newPath: PathLike): void;\r\n\r\n    /**\r\n     * Asynchronous symlink(2) - Create a new symbolic link to an existing file.\r\n     * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.\r\n     * @param type May be set to `'dir'`, `'file'`, or `'junction'` (default is `'file'`) and is only available on Windows (ignored on other platforms).\r\n     * When using `'junction'`, the `target` argument will automatically be normalized to an absolute path.\r\n     */\r\n    export function symlink(target: PathLike, path: PathLike, type: string | undefined | null, callback: (err: NodeJS.ErrnoException) => void): void;\r\n\r\n    /**\r\n     * Asynchronous symlink(2) - Create a new symbolic link to an existing file.\r\n     * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.\r\n     */\r\n    export function symlink(target: PathLike, path: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace symlink {\r\n        /**\r\n         * Asynchronous symlink(2) - Create a new symbolic link to an existing file.\r\n         * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.\r\n         * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.\r\n         * @param type May be set to `'dir'`, `'file'`, or `'junction'` (default is `'file'`) and is only available on Windows (ignored on other platforms).\r\n         * When using `'junction'`, the `target` argument will automatically be normalized to an absolute path.\r\n         */\r\n        export function __promisify__(target: PathLike, path: PathLike, type?: string | null): Promise<void>;\r\n    }\r\n\r\n    /**\r\n     * Synchronous symlink(2) - Create a new symbolic link to an existing file.\r\n     * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.\r\n     * @param type May be set to `'dir'`, `'file'`, or `'junction'` (default is `'file'`) and is only available on Windows (ignored on other platforms).\r\n     * When using `'junction'`, the `target` argument will automatically be normalized to an absolute path.\r\n     */\r\n    export function symlinkSync(target: PathLike, path: PathLike, type?: string | null): void;\r\n\r\n    /**\r\n     * Asynchronous readlink(2) - read value of a symbolic link.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n     */\r\n    export function readlink(path: PathLike, options: { encoding?: BufferEncoding | null } | BufferEncoding | undefined | null, callback: (err: NodeJS.ErrnoException, linkString: string) => void): void;\r\n\r\n    /**\r\n     * Asynchronous readlink(2) - read value of a symbolic link.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n     */\r\n    export function readlink(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\", callback: (err: NodeJS.ErrnoException, linkString: Buffer) => void): void;\r\n\r\n    /**\r\n     * Asynchronous readlink(2) - read value of a symbolic link.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n     */\r\n    export function readlink(path: PathLike, options: { encoding?: string | null } | string | undefined | null, callback: (err: NodeJS.ErrnoException, linkString: string | Buffer) => void): void;\r\n\r\n    /**\r\n     * Asynchronous readlink(2) - read value of a symbolic link.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     */\r\n    export function readlink(path: PathLike, callback: (err: NodeJS.ErrnoException, linkString: string) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace readlink {\r\n        /**\r\n         * Asynchronous readlink(2) - read value of a symbolic link.\r\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n         */\r\n        export function __promisify__(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\r\n\r\n        /**\r\n         * Asynchronous readlink(2) - read value of a symbolic link.\r\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n         */\r\n        export function __promisify__(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer>;\r\n\r\n        /**\r\n         * Asynchronous readlink(2) - read value of a symbolic link.\r\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n         */\r\n        export function __promisify__(path: PathLike, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\r\n    }\r\n\r\n    /**\r\n     * Synchronous readlink(2) - read value of a symbolic link.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n     */\r\n    export function readlinkSync(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): string;\r\n\r\n    /**\r\n     * Synchronous readlink(2) - read value of a symbolic link.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n     */\r\n    export function readlinkSync(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Buffer;\r\n\r\n    /**\r\n     * Synchronous readlink(2) - read value of a symbolic link.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n     */\r\n    export function readlinkSync(path: PathLike, options?: { encoding?: string | null } | string | null): string | Buffer;\r\n\r\n    /**\r\n     * Asynchronous realpath(3) - return the canonicalized absolute pathname.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n     */\r\n    export function realpath(path: PathLike, options: { encoding?: BufferEncoding | null } | BufferEncoding | undefined | null, callback: (err: NodeJS.ErrnoException, resolvedPath: string) => void): void;\r\n\r\n    /**\r\n     * Asynchronous realpath(3) - return the canonicalized absolute pathname.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n     */\r\n    export function realpath(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\", callback: (err: NodeJS.ErrnoException, resolvedPath: Buffer) => void): void;\r\n\r\n    /**\r\n     * Asynchronous realpath(3) - return the canonicalized absolute pathname.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n     */\r\n    export function realpath(path: PathLike, options: { encoding?: string | null } | string | undefined | null, callback: (err: NodeJS.ErrnoException, resolvedPath: string | Buffer) => void): void;\r\n\r\n    /**\r\n     * Asynchronous realpath(3) - return the canonicalized absolute pathname.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     */\r\n    export function realpath(path: PathLike, callback: (err: NodeJS.ErrnoException, resolvedPath: string) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace realpath {\r\n        /**\r\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\r\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n         */\r\n        export function __promisify__(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\r\n\r\n        /**\r\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\r\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n         */\r\n        export function __promisify__(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer>;\r\n\r\n        /**\r\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\r\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n         */\r\n        export function __promisify__(path: PathLike, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\r\n    }\r\n\r\n    /**\r\n     * Synchronous realpath(3) - return the canonicalized absolute pathname.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n     */\r\n    export function realpathSync(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): string;\r\n\r\n    /**\r\n     * Synchronous realpath(3) - return the canonicalized absolute pathname.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n     */\r\n    export function realpathSync(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Buffer;\r\n\r\n    /**\r\n     * Synchronous realpath(3) - return the canonicalized absolute pathname.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n     */\r\n    export function realpathSync(path: PathLike, options?: { encoding?: string | null } | string | null): string | Buffer;\r\n\r\n    /**\r\n     * Asynchronous unlink(2) - delete a name and possibly the file it refers to.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     */\r\n    export function unlink(path: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace unlink {\r\n        /**\r\n         * Asynchronous unlink(2) - delete a name and possibly the file it refers to.\r\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n         */\r\n        export function __promisify__(path: PathLike): Promise<void>;\r\n    }\r\n\r\n    /**\r\n     * Synchronous unlink(2) - delete a name and possibly the file it refers to.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     */\r\n    export function unlinkSync(path: PathLike): void;\r\n\r\n    /**\r\n     * Asynchronous rmdir(2) - delete a directory.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     */\r\n    export function rmdir(path: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace rmdir {\r\n        /**\r\n         * Asynchronous rmdir(2) - delete a directory.\r\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n         */\r\n        export function __promisify__(path: PathLike): Promise<void>;\r\n    }\r\n\r\n    /**\r\n     * Synchronous rmdir(2) - delete a directory.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     */\r\n    export function rmdirSync(path: PathLike): void;\r\n\r\n    /**\r\n     * Asynchronous mkdir(2) - create a directory.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\r\n     */\r\n    export function mkdir(path: PathLike, mode: number | string | undefined | null, callback: (err: NodeJS.ErrnoException) => void): void;\r\n\r\n    /**\r\n     * Asynchronous mkdir(2) - create a directory with a mode of `0o777`.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     */\r\n    export function mkdir(path: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace mkdir {\r\n        /**\r\n         * Asynchronous mkdir(2) - create a directory.\r\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\r\n         */\r\n        export function __promisify__(path: PathLike, mode?: number | string | null): Promise<void>;\r\n    }\r\n\r\n    /**\r\n     * Synchronous mkdir(2) - create a directory.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\r\n     */\r\n    export function mkdirSync(path: PathLike, mode?: number | string | null): void;\r\n\r\n    /**\r\n     * Asynchronously creates a unique temporary directory.\r\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\r\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n     */\r\n    export function mkdtemp(prefix: string, options: { encoding?: BufferEncoding | null } | BufferEncoding | undefined | null, callback: (err: NodeJS.ErrnoException, folder: string) => void): void;\r\n\r\n    /**\r\n     * Asynchronously creates a unique temporary directory.\r\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\r\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n     */\r\n    export function mkdtemp(prefix: string, options: \"buffer\" | { encoding: \"buffer\" }, callback: (err: NodeJS.ErrnoException, folder: Buffer) => void): void;\r\n\r\n    /**\r\n     * Asynchronously creates a unique temporary directory.\r\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\r\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n     */\r\n    export function mkdtemp(prefix: string, options: { encoding?: string | null } | string | undefined | null, callback: (err: NodeJS.ErrnoException, folder: string | Buffer) => void): void;\r\n\r\n    /**\r\n     * Asynchronously creates a unique temporary directory.\r\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\r\n     */\r\n    export function mkdtemp(prefix: string, callback: (err: NodeJS.ErrnoException, folder: string) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace mkdtemp {\r\n        /**\r\n         * Asynchronously creates a unique temporary directory.\r\n         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\r\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n         */\r\n        export function __promisify__(prefix: string, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\r\n\r\n        /**\r\n         * Asynchronously creates a unique temporary directory.\r\n         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\r\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n         */\r\n        export function __promisify__(prefix: string, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer>;\r\n\r\n        /**\r\n         * Asynchronously creates a unique temporary directory.\r\n         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\r\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n         */\r\n        export function __promisify__(prefix: string, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\r\n    }\r\n\r\n    /**\r\n     * Synchronously creates a unique temporary directory.\r\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\r\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n     */\r\n    export function mkdtempSync(prefix: string, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): string;\r\n\r\n    /**\r\n     * Synchronously creates a unique temporary directory.\r\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\r\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n     */\r\n    export function mkdtempSync(prefix: string, options: { encoding: \"buffer\" } | \"buffer\"): Buffer;\r\n\r\n    /**\r\n     * Synchronously creates a unique temporary directory.\r\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\r\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n     */\r\n    export function mkdtempSync(prefix: string, options?: { encoding?: string | null } | string | null): string | Buffer;\r\n\r\n    /**\r\n     * Asynchronous readdir(3) - read a directory.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n     */\r\n    export function readdir(path: PathLike, options: { encoding: BufferEncoding | null } | BufferEncoding | undefined | null, callback: (err: NodeJS.ErrnoException, files: string[]) => void): void;\r\n\r\n    /**\r\n     * Asynchronous readdir(3) - read a directory.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n     */\r\n    export function readdir(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\", callback: (err: NodeJS.ErrnoException, files: Buffer[]) => void): void;\r\n\r\n    /**\r\n     * Asynchronous readdir(3) - read a directory.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n     */\r\n    export function readdir(path: PathLike, options: { encoding?: string | null } | string | undefined | null, callback: (err: NodeJS.ErrnoException, files: Array<string | Buffer>) => void): void;\r\n\r\n    /**\r\n     * Asynchronous readdir(3) - read a directory.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     */\r\n    export function readdir(path: PathLike, callback: (err: NodeJS.ErrnoException, files: string[]) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace readdir {\r\n        /**\r\n         * Asynchronous readdir(3) - read a directory.\r\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n         */\r\n        export function __promisify__(path: PathLike, options?: { encoding: BufferEncoding | null } | BufferEncoding | null): Promise<string[]>;\r\n\r\n        /**\r\n         * Asynchronous readdir(3) - read a directory.\r\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n         */\r\n        export function __promisify__(path: PathLike, options: \"buffer\" | { encoding: \"buffer\" }): Promise<Buffer[]>;\r\n\r\n        /**\r\n         * Asynchronous readdir(3) - read a directory.\r\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n         */\r\n        export function __promisify__(path: PathLike, options?: { encoding?: string | null } | string | null): Promise<Array<string | Buffer>>;\r\n    }\r\n\r\n    /**\r\n     * Synchronous readdir(3) - read a directory.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n     */\r\n    export function readdirSync(path: PathLike, options?: { encoding: BufferEncoding | null } | BufferEncoding | null): string[];\r\n\r\n    /**\r\n     * Synchronous readdir(3) - read a directory.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n     */\r\n    export function readdirSync(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Buffer[];\r\n\r\n    /**\r\n     * Synchronous readdir(3) - read a directory.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\r\n     */\r\n    export function readdirSync(path: PathLike, options?: { encoding?: string | null } | string | null): Array<string | Buffer>;\r\n\r\n    /**\r\n     * Asynchronous close(2) - close a file descriptor.\r\n     * @param fd A file descriptor.\r\n     */\r\n    export function close(fd: number, callback: (err: NodeJS.ErrnoException) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace close {\r\n        /**\r\n         * Asynchronous close(2) - close a file descriptor.\r\n         * @param fd A file descriptor.\r\n         */\r\n        export function __promisify__(fd: number): Promise<void>;\r\n    }\r\n\r\n    /**\r\n     * Synchronous close(2) - close a file descriptor.\r\n     * @param fd A file descriptor.\r\n     */\r\n    export function closeSync(fd: number): void;\r\n\r\n    /**\r\n     * Asynchronous open(2) - open and possibly create a file.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to `0o666`.\r\n     */\r\n    export function open(path: PathLike, flags: string | number, mode: string | number | undefined | null, callback: (err: NodeJS.ErrnoException, fd: number) => void): void;\r\n\r\n    /**\r\n     * Asynchronous open(2) - open and possibly create a file. If the file is created, its mode will be `0o666`.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     */\r\n    export function open(path: PathLike, flags: string | number, callback: (err: NodeJS.ErrnoException, fd: number) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace open {\r\n        /**\r\n         * Asynchronous open(2) - open and possibly create a file.\r\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to `0o666`.\r\n         */\r\n        export function __promisify__(path: PathLike, flags: string | number, mode?: string | number | null): Promise<number>;\r\n    }\r\n\r\n    /**\r\n     * Synchronous open(2) - open and possibly create a file, returning a file descriptor..\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to `0o666`.\r\n     */\r\n    export function openSync(path: PathLike, flags: string | number, mode?: string | number | null): number;\r\n\r\n    /**\r\n     * Asynchronously change file timestamps of the file referenced by the supplied path.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param atime The last access time. If a string is provided, it will be coerced to number.\r\n     * @param mtime The last modified time. If a string is provided, it will be coerced to number.\r\n     */\r\n    export function utimes(path: PathLike, atime: string | number | Date, mtime: string | number | Date, callback: (err: NodeJS.ErrnoException) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace utimes {\r\n        /**\r\n         * Asynchronously change file timestamps of the file referenced by the supplied path.\r\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n         * @param atime The last access time. If a string is provided, it will be coerced to number.\r\n         * @param mtime The last modified time. If a string is provided, it will be coerced to number.\r\n         */\r\n        export function __promisify__(path: PathLike, atime: string | number | Date, mtime: string | number | Date): Promise<void>;\r\n    }\r\n\r\n    /**\r\n     * Synchronously change file timestamps of the file referenced by the supplied path.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * @param atime The last access time. If a string is provided, it will be coerced to number.\r\n     * @param mtime The last modified time. If a string is provided, it will be coerced to number.\r\n     */\r\n    export function utimesSync(path: PathLike, atime: string | number | Date, mtime: string | number | Date): void;\r\n\r\n    /**\r\n     * Asynchronously change file timestamps of the file referenced by the supplied file descriptor.\r\n     * @param fd A file descriptor.\r\n     * @param atime The last access time. If a string is provided, it will be coerced to number.\r\n     * @param mtime The last modified time. If a string is provided, it will be coerced to number.\r\n     */\r\n    export function futimes(fd: number, atime: string | number | Date, mtime: string | number | Date, callback: (err: NodeJS.ErrnoException) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace futimes {\r\n        /**\r\n         * Asynchronously change file timestamps of the file referenced by the supplied file descriptor.\r\n         * @param fd A file descriptor.\r\n         * @param atime The last access time. If a string is provided, it will be coerced to number.\r\n         * @param mtime The last modified time. If a string is provided, it will be coerced to number.\r\n         */\r\n        export function __promisify__(fd: number, atime: string | number | Date, mtime: string | number | Date): Promise<void>;\r\n    }\r\n\r\n    /**\r\n     * Synchronously change file timestamps of the file referenced by the supplied file descriptor.\r\n     * @param fd A file descriptor.\r\n     * @param atime The last access time. If a string is provided, it will be coerced to number.\r\n     * @param mtime The last modified time. If a string is provided, it will be coerced to number.\r\n     */\r\n    export function futimesSync(fd: number, atime: string | number | Date, mtime: string | number | Date): void;\r\n\r\n    /**\r\n     * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.\r\n     * @param fd A file descriptor.\r\n     */\r\n    export function fsync(fd: number, callback: (err: NodeJS.ErrnoException) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace fsync {\r\n        /**\r\n         * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.\r\n         * @param fd A file descriptor.\r\n         */\r\n        export function __promisify__(fd: number): Promise<void>;\r\n    }\r\n\r\n    /**\r\n     * Synchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.\r\n     * @param fd A file descriptor.\r\n     */\r\n    export function fsyncSync(fd: number): void;\r\n\r\n    /**\r\n     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.\r\n     * @param fd A file descriptor.\r\n     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\r\n     * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.\r\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\r\n     */\r\n    export function write<TBuffer extends Buffer | Uint8Array>(fd: number, buffer: TBuffer, offset: number | undefined | null, length: number | undefined | null, position: number | undefined | null, callback: (err: NodeJS.ErrnoException, written: number, buffer: TBuffer) => void): void;\r\n\r\n    /**\r\n     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.\r\n     * @param fd A file descriptor.\r\n     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\r\n     * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.\r\n     */\r\n    export function write<TBuffer extends Buffer | Uint8Array>(fd: number, buffer: TBuffer, offset: number | undefined | null, length: number | undefined | null, callback: (err: NodeJS.ErrnoException, written: number, buffer: TBuffer) => void): void;\r\n\r\n    /**\r\n     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.\r\n     * @param fd A file descriptor.\r\n     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\r\n     */\r\n    export function write<TBuffer extends Buffer | Uint8Array>(fd: number, buffer: TBuffer, offset: number | undefined | null, callback: (err: NodeJS.ErrnoException, written: number, buffer: TBuffer) => void): void;\r\n\r\n    /**\r\n     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.\r\n     * @param fd A file descriptor.\r\n     */\r\n    export function write<TBuffer extends Buffer | Uint8Array>(fd: number, buffer: TBuffer, callback: (err: NodeJS.ErrnoException, written: number, buffer: TBuffer) => void): void;\r\n\r\n    /**\r\n     * Asynchronously writes `string` to the file referenced by the supplied file descriptor.\r\n     * @param fd A file descriptor.\r\n     * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\r\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\r\n     * @param encoding The expected string encoding.\r\n     */\r\n    export function write(fd: number, string: any, position: number | undefined | null, encoding: string | undefined | null, callback: (err: NodeJS.ErrnoException, written: number, str: string) => void): void;\r\n\r\n    /**\r\n     * Asynchronously writes `string` to the file referenced by the supplied file descriptor.\r\n     * @param fd A file descriptor.\r\n     * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\r\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\r\n     */\r\n    export function write(fd: number, string: any, position: number | undefined | null, callback: (err: NodeJS.ErrnoException, written: number, str: string) => void): void;\r\n\r\n    /**\r\n     * Asynchronously writes `string` to the file referenced by the supplied file descriptor.\r\n     * @param fd A file descriptor.\r\n     * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\r\n     */\r\n    export function write(fd: number, string: any, callback: (err: NodeJS.ErrnoException, written: number, str: string) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace write {\r\n        /**\r\n         * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.\r\n         * @param fd A file descriptor.\r\n         * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\r\n         * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.\r\n         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\r\n         */\r\n        export function __promisify__<TBuffer extends Buffer | Uint8Array>(fd: number, buffer?: TBuffer, offset?: number, length?: number, position?: number | null): Promise<{ bytesWritten: number, buffer: TBuffer }>;\r\n\r\n        /**\r\n         * Asynchronously writes `string` to the file referenced by the supplied file descriptor.\r\n         * @param fd A file descriptor.\r\n         * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\r\n         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\r\n         * @param encoding The expected string encoding.\r\n         */\r\n        export function __promisify__(fd: number, string: any, position?: number | null, encoding?: string | null): Promise<{ bytesWritten: number, buffer: string }>;\r\n    }\r\n\r\n    /**\r\n     * Synchronously writes `buffer` to the file referenced by the supplied file descriptor, returning the number of bytes written.\r\n     * @param fd A file descriptor.\r\n     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\r\n     * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.\r\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\r\n     */\r\n    export function writeSync(fd: number, buffer: Buffer | Uint8Array, offset?: number | null, length?: number | null, position?: number | null): number;\r\n\r\n    /**\r\n     * Synchronously writes `string` to the file referenced by the supplied file descriptor, returning the number of bytes written.\r\n     * @param fd A file descriptor.\r\n     * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\r\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\r\n     * @param encoding The expected string encoding.\r\n     */\r\n    export function writeSync(fd: number, string: any, position?: number | null, encoding?: string | null): number;\r\n\r\n    /**\r\n     * Asynchronously reads data from the file referenced by the supplied file descriptor.\r\n     * @param fd A file descriptor.\r\n     * @param buffer The buffer that the data will be written to.\r\n     * @param offset The offset in the buffer at which to start writing.\r\n     * @param length The number of bytes to read.\r\n     * @param position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.\r\n     */\r\n    export function read<TBuffer extends Buffer | Uint8Array>(fd: number, buffer: TBuffer, offset: number, length: number, position: number | null, callback?: (err: NodeJS.ErrnoException, bytesRead: number, buffer: TBuffer) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace read {\r\n        /**\r\n         * @param fd A file descriptor.\r\n         * @param buffer The buffer that the data will be written to.\r\n         * @param offset The offset in the buffer at which to start writing.\r\n         * @param length The number of bytes to read.\r\n         * @param position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.\r\n         */\r\n        export function __promisify__<TBuffer extends Buffer | Uint8Array>(fd: number, buffer: TBuffer, offset: number, length: number, position: number | null): Promise<{ bytesRead: number, buffer: TBuffer }>;\r\n    }\r\n\r\n    /**\r\n     * Synchronously reads data from the file referenced by the supplied file descriptor, returning the number of bytes read.\r\n     * @param fd A file descriptor.\r\n     * @param buffer The buffer that the data will be written to.\r\n     * @param offset The offset in the buffer at which to start writing.\r\n     * @param length The number of bytes to read.\r\n     * @param position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.\r\n     */\r\n    export function readSync(fd: number, buffer: Buffer | Uint8Array, offset: number, length: number, position: number | null): number;\r\n\r\n    /**\r\n     * Asynchronously reads the entire contents of a file.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\r\n     * @param options An object that may contain an optional flag.\r\n     * If a flag is not provided, it defaults to `'r'`.\r\n     */\r\n    export function readFile(path: PathLike | number, options: { encoding?: null; flag?: string; } | undefined | null, callback: (err: NodeJS.ErrnoException, data: Buffer) => void): void;\r\n\r\n    /**\r\n     * Asynchronously reads the entire contents of a file.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * URL support is _experimental_.\r\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\r\n     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\r\n     * If a flag is not provided, it defaults to `'r'`.\r\n     */\r\n    export function readFile(path: PathLike | number, options: { encoding: string; flag?: string; } | string, callback: (err: NodeJS.ErrnoException, data: string) => void): void;\r\n\r\n    /**\r\n     * Asynchronously reads the entire contents of a file.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * URL support is _experimental_.\r\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\r\n     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\r\n     * If a flag is not provided, it defaults to `'r'`.\r\n     */\r\n    export function readFile(path: PathLike | number, options: { encoding?: string | null; flag?: string; } | string | undefined | null, callback: (err: NodeJS.ErrnoException, data: string | Buffer) => void): void;\r\n\r\n    /**\r\n     * Asynchronously reads the entire contents of a file.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\r\n     */\r\n    export function readFile(path: PathLike | number, callback: (err: NodeJS.ErrnoException, data: Buffer) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace readFile {\r\n        /**\r\n         * Asynchronously reads the entire contents of a file.\r\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\r\n         * @param options An object that may contain an optional flag.\r\n         * If a flag is not provided, it defaults to `'r'`.\r\n         */\r\n        export function __promisify__(path: PathLike | number, options?: { encoding?: null; flag?: string; } | null): Promise<Buffer>;\r\n\r\n        /**\r\n         * Asynchronously reads the entire contents of a file.\r\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n         * URL support is _experimental_.\r\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\r\n         * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\r\n         * If a flag is not provided, it defaults to `'r'`.\r\n         */\r\n        export function __promisify__(path: PathLike | number, options: { encoding: string; flag?: string; } | string): Promise<string>;\r\n\r\n        /**\r\n         * Asynchronously reads the entire contents of a file.\r\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n         * URL support is _experimental_.\r\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\r\n         * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\r\n         * If a flag is not provided, it defaults to `'r'`.\r\n         */\r\n        export function __promisify__(path: PathLike | number, options?: { encoding?: string | null; flag?: string; } | string | null): Promise<string | Buffer>;\r\n    }\r\n\r\n    /**\r\n     * Synchronously reads the entire contents of a file.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * URL support is _experimental_.\r\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\r\n     * @param options An object that may contain an optional flag. If a flag is not provided, it defaults to `'r'`.\r\n     */\r\n    export function readFileSync(path: PathLike | number, options?: { encoding?: null; flag?: string; } | null): Buffer;\r\n\r\n    /**\r\n     * Synchronously reads the entire contents of a file.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * URL support is _experimental_.\r\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\r\n     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\r\n     * If a flag is not provided, it defaults to `'r'`.\r\n     */\r\n    export function readFileSync(path: PathLike | number, options: { encoding: string; flag?: string; } | string): string;\r\n\r\n    /**\r\n     * Synchronously reads the entire contents of a file.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * URL support is _experimental_.\r\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\r\n     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\r\n     * If a flag is not provided, it defaults to `'r'`.\r\n     */\r\n    export function readFileSync(path: PathLike | number, options?: { encoding?: string | null; flag?: string; } | string | null): string | Buffer;\r\n\r\n    /**\r\n     * Asynchronously writes data to a file, replacing the file if it already exists.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * URL support is _experimental_.\r\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\r\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\r\n     * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\r\n     * If `encoding` is not supplied, the default of `'utf8'` is used.\r\n     * If `mode` is not supplied, the default of `0o666` is used.\r\n     * If `mode` is a string, it is parsed as an octal integer.\r\n     * If `flag` is not supplied, the default of `'w'` is used.\r\n     */\r\n    export function writeFile(path: PathLike | number, data: any, options: { encoding?: string | null; mode?: number | string; flag?: string; } | string | undefined | null, callback: (err: NodeJS.ErrnoException) => void): void;\r\n\r\n    /**\r\n     * Asynchronously writes data to a file, replacing the file if it already exists.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * URL support is _experimental_.\r\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\r\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\r\n     */\r\n    export function writeFile(path: PathLike | number, data: any, callback: (err: NodeJS.ErrnoException) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace writeFile {\r\n        /**\r\n         * Asynchronously writes data to a file, replacing the file if it already exists.\r\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n         * URL support is _experimental_.\r\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\r\n         * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\r\n         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\r\n         * If `encoding` is not supplied, the default of `'utf8'` is used.\r\n         * If `mode` is not supplied, the default of `0o666` is used.\r\n         * If `mode` is a string, it is parsed as an octal integer.\r\n         * If `flag` is not supplied, the default of `'w'` is used.\r\n         */\r\n        export function __promisify__(path: PathLike | number, data: any, options?: { encoding?: string | null; mode?: number | string; flag?: string; } | string | null): Promise<void>;\r\n    }\r\n\r\n    /**\r\n     * Synchronously writes data to a file, replacing the file if it already exists.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * URL support is _experimental_.\r\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\r\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\r\n     * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\r\n     * If `encoding` is not supplied, the default of `'utf8'` is used.\r\n     * If `mode` is not supplied, the default of `0o666` is used.\r\n     * If `mode` is a string, it is parsed as an octal integer.\r\n     * If `flag` is not supplied, the default of `'w'` is used.\r\n     */\r\n    export function writeFileSync(path: PathLike | number, data: any, options?: { encoding?: string | null; mode?: number | string; flag?: string; } | string | null): void;\r\n\r\n    /**\r\n     * Asynchronously append data to a file, creating the file if it does not exist.\r\n     * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * URL support is _experimental_.\r\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\r\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\r\n     * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\r\n     * If `encoding` is not supplied, the default of `'utf8'` is used.\r\n     * If `mode` is not supplied, the default of `0o666` is used.\r\n     * If `mode` is a string, it is parsed as an octal integer.\r\n     * If `flag` is not supplied, the default of `'a'` is used.\r\n     */\r\n    export function appendFile(file: PathLike | number, data: any, options: { encoding?: string | null, mode?: string | number, flag?: string } | string | undefined | null, callback: (err: NodeJS.ErrnoException) => void): void;\r\n\r\n    /**\r\n     * Asynchronously append data to a file, creating the file if it does not exist.\r\n     * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * URL support is _experimental_.\r\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\r\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\r\n     */\r\n    export function appendFile(file: PathLike | number, data: any, callback: (err: NodeJS.ErrnoException) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace appendFile {\r\n        /**\r\n         * Asynchronously append data to a file, creating the file if it does not exist.\r\n         * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n         * URL support is _experimental_.\r\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\r\n         * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\r\n         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\r\n         * If `encoding` is not supplied, the default of `'utf8'` is used.\r\n         * If `mode` is not supplied, the default of `0o666` is used.\r\n         * If `mode` is a string, it is parsed as an octal integer.\r\n         * If `flag` is not supplied, the default of `'a'` is used.\r\n         */\r\n        export function __promisify__(file: PathLike | number, data: any, options?: { encoding?: string | null, mode?: string | number, flag?: string } | string | null): Promise<void>;\r\n    }\r\n\r\n    /**\r\n     * Synchronously append data to a file, creating the file if it does not exist.\r\n     * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * URL support is _experimental_.\r\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\r\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\r\n     * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\r\n     * If `encoding` is not supplied, the default of `'utf8'` is used.\r\n     * If `mode` is not supplied, the default of `0o666` is used.\r\n     * If `mode` is a string, it is parsed as an octal integer.\r\n     * If `flag` is not supplied, the default of `'a'` is used.\r\n     */\r\n    export function appendFileSync(file: PathLike | number, data: any, options?: { encoding?: string | null; mode?: number | string; flag?: string; } | string | null): void;\r\n\r\n    /**\r\n     * Watch for changes on `filename`. The callback `listener` will be called each time the file is accessed.\r\n     */\r\n    export function watchFile(filename: PathLike, options: { persistent?: boolean; interval?: number; } | undefined, listener: (curr: Stats, prev: Stats) => void): void;\r\n\r\n    /**\r\n     * Watch for changes on `filename`. The callback `listener` will be called each time the file is accessed.\r\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\r\n     * URL support is _experimental_.\r\n     */\r\n    export function watchFile(filename: PathLike, listener: (curr: Stats, prev: Stats) => void): void;\r\n\r\n    /**\r\n     * Stop watching for changes on `filename`.\r\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\r\n     * URL support is _experimental_.\r\n     */\r\n    export function unwatchFile(filename: PathLike, listener?: (curr: Stats, prev: Stats) => void): void;\r\n\r\n    /**\r\n     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.\r\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\r\n     * URL support is _experimental_.\r\n     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.\r\n     * If `encoding` is not supplied, the default of `'utf8'` is used.\r\n     * If `persistent` is not supplied, the default of `true` is used.\r\n     * If `recursive` is not supplied, the default of `false` is used.\r\n     */\r\n    export function watch(filename: PathLike, options: { encoding?: BufferEncoding | null, persistent?: boolean, recursive?: boolean } | BufferEncoding | undefined | null, listener?: (event: string, filename: string) => void): FSWatcher;\r\n\r\n    /**\r\n     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.\r\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\r\n     * URL support is _experimental_.\r\n     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.\r\n     * If `encoding` is not supplied, the default of `'utf8'` is used.\r\n     * If `persistent` is not supplied, the default of `true` is used.\r\n     * If `recursive` is not supplied, the default of `false` is used.\r\n     */\r\n    export function watch(filename: PathLike, options: { encoding: \"buffer\", persistent?: boolean, recursive?: boolean } | \"buffer\", listener?: (event: string, filename: Buffer) => void): FSWatcher;\r\n\r\n    /**\r\n     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.\r\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\r\n     * URL support is _experimental_.\r\n     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.\r\n     * If `encoding` is not supplied, the default of `'utf8'` is used.\r\n     * If `persistent` is not supplied, the default of `true` is used.\r\n     * If `recursive` is not supplied, the default of `false` is used.\r\n     */\r\n    export function watch(filename: PathLike, options: { encoding?: string | null, persistent?: boolean, recursive?: boolean } | string | null, listener?: (event: string, filename: string | Buffer) => void): FSWatcher;\r\n\r\n    /**\r\n     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.\r\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\r\n     * URL support is _experimental_.\r\n     */\r\n    export function watch(filename: PathLike, listener?: (event: string, filename: string) => any): FSWatcher;\r\n\r\n    /**\r\n     * Asynchronously tests whether or not the given path exists by checking with the file system.\r\n     * @deprecated\r\n     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\r\n     * URL support is _experimental_.\r\n     */\r\n    export function exists(path: PathLike, callback: (exists: boolean) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace exists {\r\n        /**\r\n         * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\r\n         * URL support is _experimental_.\r\n         */\r\n        function __promisify__(path: PathLike): Promise<boolean>;\r\n    }\r\n\r\n    /**\r\n     * Synchronously tests whether or not the given path exists by checking with the file system.\r\n     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\r\n     * URL support is _experimental_.\r\n     */\r\n    export function existsSync(path: PathLike): boolean;\r\n\r\n    export namespace constants {\r\n        // File Access Constants\r\n\r\n        /** Constant for fs.access(). File is visible to the calling process. */\r\n        export const F_OK: number;\r\n\r\n        /** Constant for fs.access(). File can be read by the calling process. */\r\n        export const R_OK: number;\r\n\r\n        /** Constant for fs.access(). File can be written by the calling process. */\r\n        export const W_OK: number;\r\n\r\n        /** Constant for fs.access(). File can be executed by the calling process. */\r\n        export const X_OK: number;\r\n\r\n        // File Open Constants\r\n\r\n        /** Constant for fs.open(). Flag indicating to open a file for read-only access. */\r\n        export const O_RDONLY: number;\r\n\r\n        /** Constant for fs.open(). Flag indicating to open a file for write-only access. */\r\n        export const O_WRONLY: number;\r\n\r\n        /** Constant for fs.open(). Flag indicating to open a file for read-write access. */\r\n        export const O_RDWR: number;\r\n\r\n        /** Constant for fs.open(). Flag indicating to create the file if it does not already exist. */\r\n        export const O_CREAT: number;\r\n\r\n        /** Constant for fs.open(). Flag indicating that opening a file should fail if the O_CREAT flag is set and the file already exists. */\r\n        export const O_EXCL: number;\r\n\r\n        /** Constant for fs.open(). Flag indicating that if path identifies a terminal device, opening the path shall not cause that terminal to become the controlling terminal for the process (if the process does not already have one). */\r\n        export const O_NOCTTY: number;\r\n\r\n        /** Constant for fs.open(). Flag indicating that if the file exists and is a regular file, and the file is opened successfully for write access, its length shall be truncated to zero. */\r\n        export const O_TRUNC: number;\r\n\r\n        /** Constant for fs.open(). Flag indicating that data will be appended to the end of the file. */\r\n        export const O_APPEND: number;\r\n\r\n        /** Constant for fs.open(). Flag indicating that the open should fail if the path is not a directory. */\r\n        export const O_DIRECTORY: number;\r\n\r\n        /** Constant for fs.open(). Flag indicating reading accesses to the file system will no longer result in an update to the atime information associated with the file. This flag is available on Linux operating systems only. */\r\n        export const O_NOATIME: number;\r\n\r\n        /** Constant for fs.open(). Flag indicating that the open should fail if the path is a symbolic link. */\r\n        export const O_NOFOLLOW: number;\r\n\r\n        /** Constant for fs.open(). Flag indicating that the file is opened for synchronous I/O. */\r\n        export const O_SYNC: number;\r\n\r\n        /** Constant for fs.open(). Flag indicating that the file is opened for synchronous I/O with write operations waiting for data integrity. */\r\n        export const O_DSYNC: number;\r\n\r\n        /** Constant for fs.open(). Flag indicating to open the symbolic link itself rather than the resource it is pointing to. */\r\n        export const O_SYMLINK: number;\r\n\r\n        /** Constant for fs.open(). When set, an attempt will be made to minimize caching effects of file I/O. */\r\n        export const O_DIRECT: number;\r\n\r\n        /** Constant for fs.open(). Flag indicating to open the file in nonblocking mode when possible. */\r\n        export const O_NONBLOCK: number;\r\n\r\n        // File Type Constants\r\n\r\n        /** Constant for fs.Stats mode property for determining a file's type. Bit mask used to extract the file type code. */\r\n        export const S_IFMT: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a regular file. */\r\n        export const S_IFREG: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a directory. */\r\n        export const S_IFDIR: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a character-oriented device file. */\r\n        export const S_IFCHR: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a block-oriented device file. */\r\n        export const S_IFBLK: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a FIFO/pipe. */\r\n        export const S_IFIFO: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a symbolic link. */\r\n        export const S_IFLNK: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a socket. */\r\n        export const S_IFSOCK: number;\r\n\r\n        // File Mode Constants\r\n\r\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by owner. */\r\n        export const S_IRWXU: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by owner. */\r\n        export const S_IRUSR: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by owner. */\r\n        export const S_IWUSR: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by owner. */\r\n        export const S_IXUSR: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by group. */\r\n        export const S_IRWXG: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by group. */\r\n        export const S_IRGRP: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by group. */\r\n        export const S_IWGRP: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by group. */\r\n        export const S_IXGRP: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by others. */\r\n        export const S_IRWXO: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by others. */\r\n        export const S_IROTH: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by others. */\r\n        export const S_IWOTH: number;\r\n\r\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by others. */\r\n        export const S_IXOTH: number;\r\n\r\n        /** Constant for fs.copyFile. Flag indicating the destination file should not be overwritten if it already exists. */\r\n        export const COPYFILE_EXCL: number;\r\n    }\r\n\r\n    /**\r\n     * Asynchronously tests a user's permissions for the file specified by path.\r\n     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\r\n     * URL support is _experimental_.\r\n     */\r\n    export function access(path: PathLike, mode: number | undefined, callback: (err: NodeJS.ErrnoException) => void): void;\r\n\r\n    /**\r\n     * Asynchronously tests a user's permissions for the file specified by path.\r\n     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\r\n     * URL support is _experimental_.\r\n     */\r\n    export function access(path: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace access {\r\n        /**\r\n         * Asynchronously tests a user's permissions for the file specified by path.\r\n         * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\r\n         * URL support is _experimental_.\r\n         */\r\n        export function __promisify__(path: PathLike, mode?: number): Promise<void>;\r\n    }\r\n\r\n    /**\r\n     * Synchronously tests a user's permissions for the file specified by path.\r\n     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\r\n     * URL support is _experimental_.\r\n     */\r\n    export function accessSync(path: PathLike, mode?: number): void;\r\n\r\n    /**\r\n     * Returns a new `ReadStream` object.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * URL support is _experimental_.\r\n     */\r\n    export function createReadStream(path: PathLike, options?: string | {\r\n        flags?: string;\r\n        encoding?: string;\r\n        fd?: number;\r\n        mode?: number;\r\n        autoClose?: boolean;\r\n        start?: number;\r\n        end?: number;\r\n        highWaterMark?: number;\r\n    }): ReadStream;\r\n\r\n    /**\r\n     * Returns a new `WriteStream` object.\r\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\r\n     * URL support is _experimental_.\r\n     */\r\n    export function createWriteStream(path: PathLike, options?: string | {\r\n        flags?: string;\r\n        encoding?: string;\r\n        fd?: number;\r\n        mode?: number;\r\n        autoClose?: boolean;\r\n        start?: number;\r\n    }): WriteStream;\r\n\r\n    /**\r\n     * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.\r\n     * @param fd A file descriptor.\r\n     */\r\n    export function fdatasync(fd: number, callback: (err: NodeJS.ErrnoException) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace fdatasync {\r\n        /**\r\n         * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.\r\n         * @param fd A file descriptor.\r\n         */\r\n        export function __promisify__(fd: number): Promise<void>;\r\n    }\r\n\r\n    /**\r\n     * Synchronous fdatasync(2) - synchronize a file's in-core state with storage device.\r\n     * @param fd A file descriptor.\r\n     */\r\n    export function fdatasyncSync(fd: number): void;\r\n\r\n    /**\r\n     * Asynchronously copies src to dest. By default, dest is overwritten if it already exists.\r\n     * No arguments other than a possible exception are given to the callback function.\r\n     * Node.js makes no guarantees about the atomicity of the copy operation.\r\n     * If an error occurs after the destination file has been opened for writing, Node.js will attempt\r\n     * to remove the destination.\r\n     * @param src A path to the source file.\r\n     * @param dest A path to the destination file.\r\n     */\r\n    export function copyFile(src: PathLike, dest: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\r\n    /**\r\n     * Asynchronously copies src to dest. By default, dest is overwritten if it already exists.\r\n     * No arguments other than a possible exception are given to the callback function.\r\n     * Node.js makes no guarantees about the atomicity of the copy operation.\r\n     * If an error occurs after the destination file has been opened for writing, Node.js will attempt\r\n     * to remove the destination.\r\n     * @param src A path to the source file.\r\n     * @param dest A path to the destination file.\r\n     * @param flags An integer that specifies the behavior of the copy operation. The only supported flag is fs.constants.COPYFILE_EXCL, which causes the copy operation to fail if dest already exists.\r\n     */\r\n    export function copyFile(src: PathLike, dest: PathLike, flags: number, callback: (err: NodeJS.ErrnoException) => void): void;\r\n\r\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\r\n    export namespace copyFile {\r\n        /**\r\n         * Asynchronously copies src to dest. By default, dest is overwritten if it already exists.\r\n         * No arguments other than a possible exception are given to the callback function.\r\n         * Node.js makes no guarantees about the atomicity of the copy operation.\r\n         * If an error occurs after the destination file has been opened for writing, Node.js will attempt\r\n         * to remove the destination.\r\n         * @param src A path to the source file.\r\n         * @param dest A path to the destination file.\r\n         * @param flags An optional integer that specifies the behavior of the copy operation. The only supported flag is fs.constants.COPYFILE_EXCL, which causes the copy operation to fail if dest already exists.\r\n         */\r\n        export function __promisify__(src: PathLike, dst: PathLike, flags?: number): Promise<void>;\r\n    }\r\n\r\n    /**\r\n     * Synchronously copies src to dest. By default, dest is overwritten if it already exists.\r\n     * Node.js makes no guarantees about the atomicity of the copy operation.\r\n     * If an error occurs after the destination file has been opened for writing, Node.js will attempt\r\n     * to remove the destination.\r\n     * @param src A path to the source file.\r\n     * @param dest A path to the destination file.\r\n     * @param flags An optional integer that specifies the behavior of the copy operation. The only supported flag is fs.constants.COPYFILE_EXCL, which causes the copy operation to fail if dest already exists.\r\n     */\r\n    export function copyFileSync(src: PathLike, dest: PathLike, flags?: number): void;\r\n}\r\n\r\ndeclare module \"path\" {\r\n    /**\r\n     * A parsed path object generated by path.parse() or consumed by path.format().\r\n     */\r\n    export interface ParsedPath {\r\n        /**\r\n         * The root of the path such as '/' or 'c:\\'\r\n         */\r\n        root: string;\r\n        /**\r\n         * The full directory path such as '/home/user/dir' or 'c:\\path\\dir'\r\n         */\r\n        dir: string;\r\n        /**\r\n         * The file name including extension (if any) such as 'index.html'\r\n         */\r\n        base: string;\r\n        /**\r\n         * The file extension (if any) such as '.html'\r\n         */\r\n        ext: string;\r\n        /**\r\n         * The file name without extension (if any) such as 'index'\r\n         */\r\n        name: string;\r\n    }\r\n\r\n    export interface FormatInputPathObject {\r\n        /**\r\n         * The root of the path such as '/' or 'c:\\'\r\n         */\r\n        root?: string;\r\n        /**\r\n         * The full directory path such as '/home/user/dir' or 'c:\\path\\dir'\r\n         */\r\n        dir?: string;\r\n        /**\r\n         * The file name including extension (if any) such as 'index.html'\r\n         */\r\n        base?: string;\r\n        /**\r\n         * The file extension (if any) such as '.html'\r\n         */\r\n        ext?: string;\r\n        /**\r\n         * The file name without extension (if any) such as 'index'\r\n         */\r\n        name?: string;\r\n    }\r\n\r\n    /**\r\n     * Normalize a string path, reducing '..' and '.' parts.\r\n     * When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.\r\n     *\r\n     * @param p string path to normalize.\r\n     */\r\n    export function normalize(p: string): string;\r\n    /**\r\n     * Join all arguments together and normalize the resulting path.\r\n     * Arguments must be strings. In v0.8, non-string arguments were silently ignored. In v0.10 and up, an exception is thrown.\r\n     *\r\n     * @param paths paths to join.\r\n     */\r\n    export function join(...paths: string[]): string;\r\n    /**\r\n     * The right-most parameter is considered {to}.  Other parameters are considered an array of {from}.\r\n     *\r\n     * Starting from leftmost {from} paramter, resolves {to} to an absolute path.\r\n     *\r\n     * If {to} isn't already absolute, {from} arguments are prepended in right to left order, until an absolute path is found. If after using all {from} paths still no absolute path is found, the current working directory is used as well. The resulting path is normalized, and trailing slashes are removed unless the path gets resolved to the root directory.\r\n     *\r\n     * @param pathSegments string paths to join.  Non-string arguments are ignored.\r\n     */\r\n    export function resolve(...pathSegments: any[]): string;\r\n    /**\r\n     * Determines whether {path} is an absolute path. An absolute path will always resolve to the same location, regardless of the working directory.\r\n     *\r\n     * @param path path to test.\r\n     */\r\n    export function isAbsolute(path: string): boolean;\r\n    /**\r\n     * Solve the relative path from {from} to {to}.\r\n     * At times we have two absolute paths, and we need to derive the relative path from one to the other. This is actually the reverse transform of path.resolve.\r\n     */\r\n    export function relative(from: string, to: string): string;\r\n    /**\r\n     * Return the directory name of a path. Similar to the Unix dirname command.\r\n     *\r\n     * @param p the path to evaluate.\r\n     */\r\n    export function dirname(p: string): string;\r\n    /**\r\n     * Return the last portion of a path. Similar to the Unix basename command.\r\n     * Often used to extract the file name from a fully qualified path.\r\n     *\r\n     * @param p the path to evaluate.\r\n     * @param ext optionally, an extension to remove from the result.\r\n     */\r\n    export function basename(p: string, ext?: string): string;\r\n    /**\r\n     * Return the extension of the path, from the last '.' to end of string in the last portion of the path.\r\n     * If there is no '.' in the last portion of the path or the first character of it is '.', then it returns an empty string\r\n     *\r\n     * @param p the path to evaluate.\r\n     */\r\n    export function extname(p: string): string;\r\n    /**\r\n     * The platform-specific file separator. '\\\\' or '/'.\r\n     */\r\n    export var sep: string;\r\n    /**\r\n     * The platform-specific file delimiter. ';' or ':'.\r\n     */\r\n    export var delimiter: string;\r\n    /**\r\n     * Returns an object from a path string - the opposite of format().\r\n     *\r\n     * @param pathString path to evaluate.\r\n     */\r\n    export function parse(pathString: string): ParsedPath;\r\n    /**\r\n     * Returns a path string from an object - the opposite of parse().\r\n     *\r\n     * @param pathString path to evaluate.\r\n     */\r\n    export function format(pathObject: FormatInputPathObject): string;\r\n\r\n    export module posix {\r\n        export function normalize(p: string): string;\r\n        export function join(...paths: any[]): string;\r\n        export function resolve(...pathSegments: any[]): string;\r\n        export function isAbsolute(p: string): boolean;\r\n        export function relative(from: string, to: string): string;\r\n        export function dirname(p: string): string;\r\n        export function basename(p: string, ext?: string): string;\r\n        export function extname(p: string): string;\r\n        export var sep: string;\r\n        export var delimiter: string;\r\n        export function parse(p: string): ParsedPath;\r\n        export function format(pP: ParsedPath): string;\r\n    }\r\n\r\n    export module win32 {\r\n        export function normalize(p: string): string;\r\n        export function join(...paths: any[]): string;\r\n        export function resolve(...pathSegments: any[]): string;\r\n        export function isAbsolute(p: string): boolean;\r\n        export function relative(from: string, to: string): string;\r\n        export function dirname(p: string): string;\r\n        export function basename(p: string, ext?: string): string;\r\n        export function extname(p: string): string;\r\n        export var sep: string;\r\n        export var delimiter: string;\r\n        export function parse(p: string): ParsedPath;\r\n        export function format(pP: ParsedPath): string;\r\n    }\r\n}\r\n\r\ndeclare module \"string_decoder\" {\r\n    export interface NodeStringDecoder {\r\n        write(buffer: Buffer): string;\r\n        end(buffer?: Buffer): string;\r\n    }\r\n    export var StringDecoder: {\r\n        new(encoding?: string): NodeStringDecoder;\r\n    };\r\n}\r\n\r\ndeclare module \"tls\" {\r\n    import * as crypto from \"crypto\";\r\n    import * as dns from \"dns\";\r\n    import * as net from \"net\";\r\n    import * as stream from \"stream\";\r\n\r\n    var CLIENT_RENEG_LIMIT: number;\r\n    var CLIENT_RENEG_WINDOW: number;\r\n\r\n    export interface Certificate {\r\n        /**\r\n         * Country code.\r\n         */\r\n        C: string;\r\n        /**\r\n         * Street.\r\n         */\r\n        ST: string;\r\n        /**\r\n         * Locality.\r\n         */\r\n        L: string;\r\n        /**\r\n         * Organization.\r\n         */\r\n        O: string;\r\n        /**\r\n         * Organizational unit.\r\n         */\r\n        OU: string;\r\n        /**\r\n         * Common name.\r\n         */\r\n        CN: string;\r\n    }\r\n\r\n    export interface PeerCertificate {\r\n        subject: Certificate;\r\n        issuer: Certificate;\r\n        subjectaltname: string;\r\n        infoAccess: { [index: string]: string[] | undefined };\r\n        modulus: string;\r\n        exponent: string;\r\n        valid_from: string;\r\n        valid_to: string;\r\n        fingerprint: string;\r\n        ext_key_usage: string[];\r\n        serialNumber: string;\r\n        raw: Buffer;\r\n    }\r\n\r\n    export interface DetailedPeerCertificate extends PeerCertificate {\r\n        issuerCertificate: DetailedPeerCertificate;\r\n    }\r\n\r\n    export interface CipherNameAndProtocol {\r\n        /**\r\n         * The cipher name.\r\n         */\r\n        name: string;\r\n        /**\r\n         * SSL/TLS protocol version.\r\n         */\r\n        version: string;\r\n    }\r\n\r\n    export class TLSSocket extends net.Socket {\r\n        /**\r\n         * Construct a new tls.TLSSocket object from an existing TCP socket.\r\n         */\r\n        constructor(socket: net.Socket, options?: {\r\n            /**\r\n             * An optional TLS context object from tls.createSecureContext()\r\n             */\r\n            secureContext?: SecureContext,\r\n            /**\r\n             * If true the TLS socket will be instantiated in server-mode.\r\n             * Defaults to false.\r\n             */\r\n            isServer?: boolean,\r\n            /**\r\n             * An optional net.Server instance.\r\n             */\r\n            server?: net.Server,\r\n            /**\r\n             * If true the server will request a certificate from clients that\r\n             * connect and attempt to verify that certificate. Defaults to\r\n             * false.\r\n             */\r\n            requestCert?: boolean,\r\n            /**\r\n             * If true the server will reject any connection which is not\r\n             * authorized with the list of supplied CAs. This option only has an\r\n             * effect if requestCert is true. Defaults to false.\r\n             */\r\n            rejectUnauthorized?: boolean,\r\n            /**\r\n             * An array of strings or a Buffer naming possible NPN protocols.\r\n             * (Protocols should be ordered by their priority.)\r\n             */\r\n            NPNProtocols?: string[] | Buffer,\r\n            /**\r\n             * An array of strings or a Buffer naming possible ALPN protocols.\r\n             * (Protocols should be ordered by their priority.) When the server\r\n             * receives both NPN and ALPN extensions from the client, ALPN takes\r\n             * precedence over NPN and the server does not send an NPN extension\r\n             * to the client.\r\n             */\r\n            ALPNProtocols?: string[] | Buffer,\r\n            /**\r\n             * SNICallback(servername, cb) <Function> A function that will be\r\n             * called if the client supports SNI TLS extension. Two arguments\r\n             * will be passed when called: servername and cb. SNICallback should\r\n             * invoke cb(null, ctx), where ctx is a SecureContext instance.\r\n             * (tls.createSecureContext(...) can be used to get a proper\r\n             * SecureContext.) If SNICallback wasn't provided the default callback\r\n             * with high-level API will be used (see below).\r\n             */\r\n            SNICallback?: (servername: string, cb: (err: Error | null, ctx: SecureContext) => void) => void,\r\n            /**\r\n             * An optional Buffer instance containing a TLS session.\r\n             */\r\n            session?: Buffer,\r\n            /**\r\n             * If true, specifies that the OCSP status request extension will be\r\n             * added to the client hello and an 'OCSPResponse' event will be\r\n             * emitted on the socket before establishing a secure communication\r\n             */\r\n            requestOCSP?: boolean\r\n        });\r\n\r\n        /**\r\n         * A boolean that is true if the peer certificate was signed by one of the specified CAs, otherwise false.\r\n         */\r\n        authorized: boolean;\r\n        /**\r\n         * The reason why the peer's certificate has not been verified.\r\n         * This property becomes available only when tlsSocket.authorized === false.\r\n         */\r\n        authorizationError: Error;\r\n        /**\r\n         * Static boolean value, always true.\r\n         * May be used to distinguish TLS sockets from regular ones.\r\n         */\r\n        encrypted: boolean;\r\n        /**\r\n         * Returns an object representing the cipher name and the SSL/TLS protocol version of the current connection.\r\n         * @returns Returns an object representing the cipher name\r\n         * and the SSL/TLS protocol version of the current connection.\r\n         */\r\n        getCipher(): CipherNameAndProtocol;\r\n        /**\r\n         * Returns an object representing the peer's certificate.\r\n         * The returned object has some properties corresponding to the field of the certificate.\r\n         * If detailed argument is true the full chain with issuer property will be returned,\r\n         * if false only the top certificate without issuer property.\r\n         * If the peer does not provide a certificate, it returns null or an empty object.\r\n         * @param detailed - If true; the full chain with issuer property will be returned.\r\n         * @returns An object representing the peer's certificate.\r\n         */\r\n        getPeerCertificate(detailed: true): DetailedPeerCertificate;\r\n        getPeerCertificate(detailed?: false): PeerCertificate;\r\n        getPeerCertificate(detailed?: boolean): PeerCertificate | DetailedPeerCertificate;\r\n        /**\r\n         * Could be used to speed up handshake establishment when reconnecting to the server.\r\n         * @returns ASN.1 encoded TLS session or undefined if none was negotiated.\r\n         */\r\n        getSession(): any;\r\n        /**\r\n         * NOTE: Works only with client TLS sockets.\r\n         * Useful only for debugging, for session reuse provide session option to tls.connect().\r\n         * @returns TLS session ticket or undefined if none was negotiated.\r\n         */\r\n        getTLSTicket(): any;\r\n        /**\r\n         * Initiate TLS renegotiation process.\r\n         *\r\n         * NOTE: Can be used to request peer's certificate after the secure connection has been established.\r\n         * ANOTHER NOTE: When running as the server, socket will be destroyed with an error after handshakeTimeout timeout.\r\n         * @param options - The options may contain the following fields: rejectUnauthorized,\r\n         * requestCert (See tls.createServer() for details).\r\n         * @param callback - callback(err) will be executed with null as err, once the renegotiation\r\n         * is successfully completed.\r\n         */\r\n        renegotiate(options: TlsOptions, callback: (err: Error | null) => void): any;\r\n        /**\r\n         * Set maximum TLS fragment size (default and maximum value is: 16384, minimum is: 512).\r\n         * Smaller fragment size decreases buffering latency on the client: large fragments are buffered by\r\n         * the TLS layer until the entire fragment is received and its integrity is verified;\r\n         * large fragments can span multiple roundtrips, and their processing can be delayed due to packet\r\n         * loss or reordering. However, smaller fragments add extra TLS framing bytes and CPU overhead,\r\n         * which may decrease overall server throughput.\r\n         * @param size - TLS fragment size (default and maximum value is: 16384, minimum is: 512).\r\n         * @returns Returns true on success, false otherwise.\r\n         */\r\n        setMaxSendFragment(size: number): boolean;\r\n\r\n        /**\r\n         * events.EventEmitter\r\n         * 1. OCSPResponse\r\n         * 2. secureConnect\r\n         */\r\n        addListener(event: string, listener: (...args: any[]) => void): this;\r\n        addListener(event: \"OCSPResponse\", listener: (response: Buffer) => void): this;\r\n        addListener(event: \"secureConnect\", listener: () => void): this;\r\n\r\n        emit(event: string | symbol, ...args: any[]): boolean;\r\n        emit(event: \"OCSPResponse\", response: Buffer): boolean;\r\n        emit(event: \"secureConnect\"): boolean;\r\n\r\n        on(event: string, listener: (...args: any[]) => void): this;\r\n        on(event: \"OCSPResponse\", listener: (response: Buffer) => void): this;\r\n        on(event: \"secureConnect\", listener: () => void): this;\r\n\r\n        once(event: string, listener: (...args: any[]) => void): this;\r\n        once(event: \"OCSPResponse\", listener: (response: Buffer) => void): this;\r\n        once(event: \"secureConnect\", listener: () => void): this;\r\n\r\n        prependListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependListener(event: \"OCSPResponse\", listener: (response: Buffer) => void): this;\r\n        prependListener(event: \"secureConnect\", listener: () => void): this;\r\n\r\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependOnceListener(event: \"OCSPResponse\", listener: (response: Buffer) => void): this;\r\n        prependOnceListener(event: \"secureConnect\", listener: () => void): this;\r\n    }\r\n\r\n    export interface TlsOptions {\r\n        host?: string;\r\n        port?: number;\r\n        pfx?: string | Buffer[];\r\n        key?: string | string[] | Buffer | any[];\r\n        passphrase?: string;\r\n        cert?: string | string[] | Buffer | Buffer[];\r\n        ca?: string | string[] | Buffer | Buffer[];\r\n        crl?: string | string[];\r\n        ciphers?: string;\r\n        honorCipherOrder?: boolean;\r\n        requestCert?: boolean;\r\n        rejectUnauthorized?: boolean;\r\n        NPNProtocols?: string[] | Buffer;\r\n        SNICallback?: (servername: string, cb: (err: Error | null, ctx: SecureContext) => void) => void;\r\n        ecdhCurve?: string;\r\n        dhparam?: string | Buffer;\r\n        handshakeTimeout?: number;\r\n        ALPNProtocols?: string[] | Buffer;\r\n        sessionTimeout?: number;\r\n        ticketKeys?: Buffer;\r\n        sessionIdContext?: string;\r\n        secureProtocol?: string;\r\n        secureOptions?: number;\r\n    }\r\n\r\n    export interface ConnectionOptions extends SecureContextOptions {\r\n        host?: string;\r\n        port?: number;\r\n        path?: string; // Creates unix socket connection to path. If this option is specified, `host` and `port` are ignored.\r\n        socket?: net.Socket; // Establish secure connection on a given socket rather than creating a new socket\r\n        rejectUnauthorized?: boolean; // Defaults to true\r\n        NPNProtocols?: Array<string | Buffer>;\r\n        ALPNProtocols?: Array<string | Buffer>;\r\n        checkServerIdentity?: typeof checkServerIdentity;\r\n        servername?: string; // SNI TLS Extension\r\n        session?: Buffer;\r\n        minDHSize?: number;\r\n        secureContext?: SecureContext; // If not provided, the entire ConnectionOptions object will be passed to tls.createSecureContext()\r\n        lookup?: net.LookupFunction;\r\n    }\r\n\r\n    export class Server extends net.Server {\r\n        addContext(hostName: string, credentials: {\r\n            key: string;\r\n            cert: string;\r\n            ca: string;\r\n        }): void;\r\n\r\n        /**\r\n         * events.EventEmitter\r\n         * 1. tlsClientError\r\n         * 2. newSession\r\n         * 3. OCSPRequest\r\n         * 4. resumeSession\r\n         * 5. secureConnection\r\n         */\r\n        addListener(event: string, listener: (...args: any[]) => void): this;\r\n        addListener(event: \"tlsClientError\", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\r\n        addListener(event: \"newSession\", listener: (sessionId: any, sessionData: any, callback: (err: Error, resp: Buffer) => void) => void): this;\r\n        addListener(event: \"OCSPRequest\", listener: (certificate: Buffer, issuer: Buffer, callback: Function) => void): this;\r\n        addListener(event: \"resumeSession\", listener: (sessionId: any, callback: (err: Error, sessionData: any) => void) => void): this;\r\n        addListener(event: \"secureConnection\", listener: (tlsSocket: TLSSocket) => void): this;\r\n\r\n        emit(event: string | symbol, ...args: any[]): boolean;\r\n        emit(event: \"tlsClientError\", err: Error, tlsSocket: TLSSocket): boolean;\r\n        emit(event: \"newSession\", sessionId: any, sessionData: any, callback: (err: Error, resp: Buffer) => void): boolean;\r\n        emit(event: \"OCSPRequest\", certificate: Buffer, issuer: Buffer, callback: Function): boolean;\r\n        emit(event: \"resumeSession\", sessionId: any, callback: (err: Error, sessionData: any) => void): boolean;\r\n        emit(event: \"secureConnection\", tlsSocket: TLSSocket): boolean;\r\n\r\n        on(event: string, listener: (...args: any[]) => void): this;\r\n        on(event: \"tlsClientError\", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\r\n        on(event: \"newSession\", listener: (sessionId: any, sessionData: any, callback: (err: Error, resp: Buffer) => void) => void): this;\r\n        on(event: \"OCSPRequest\", listener: (certificate: Buffer, issuer: Buffer, callback: Function) => void): this;\r\n        on(event: \"resumeSession\", listener: (sessionId: any, callback: (err: Error, sessionData: any) => void) => void): this;\r\n        on(event: \"secureConnection\", listener: (tlsSocket: TLSSocket) => void): this;\r\n\r\n        once(event: string, listener: (...args: any[]) => void): this;\r\n        once(event: \"tlsClientError\", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\r\n        once(event: \"newSession\", listener: (sessionId: any, sessionData: any, callback: (err: Error, resp: Buffer) => void) => void): this;\r\n        once(event: \"OCSPRequest\", listener: (certificate: Buffer, issuer: Buffer, callback: Function) => void): this;\r\n        once(event: \"resumeSession\", listener: (sessionId: any, callback: (err: Error, sessionData: any) => void) => void): this;\r\n        once(event: \"secureConnection\", listener: (tlsSocket: TLSSocket) => void): this;\r\n\r\n        prependListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependListener(event: \"tlsClientError\", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\r\n        prependListener(event: \"newSession\", listener: (sessionId: any, sessionData: any, callback: (err: Error, resp: Buffer) => void) => void): this;\r\n        prependListener(event: \"OCSPRequest\", listener: (certificate: Buffer, issuer: Buffer, callback: Function) => void): this;\r\n        prependListener(event: \"resumeSession\", listener: (sessionId: any, callback: (err: Error, sessionData: any) => void) => void): this;\r\n        prependListener(event: \"secureConnection\", listener: (tlsSocket: TLSSocket) => void): this;\r\n\r\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependOnceListener(event: \"tlsClientError\", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\r\n        prependOnceListener(event: \"newSession\", listener: (sessionId: any, sessionData: any, callback: (err: Error, resp: Buffer) => void) => void): this;\r\n        prependOnceListener(event: \"OCSPRequest\", listener: (certificate: Buffer, issuer: Buffer, callback: Function) => void): this;\r\n        prependOnceListener(event: \"resumeSession\", listener: (sessionId: any, callback: (err: Error, sessionData: any) => void) => void): this;\r\n        prependOnceListener(event: \"secureConnection\", listener: (tlsSocket: TLSSocket) => void): this;\r\n    }\r\n\r\n    export interface ClearTextStream extends stream.Duplex {\r\n        authorized: boolean;\r\n        authorizationError: Error;\r\n        getPeerCertificate(): any;\r\n        getCipher: {\r\n            name: string;\r\n            version: string;\r\n        };\r\n        address: {\r\n            port: number;\r\n            family: string;\r\n            address: string;\r\n        };\r\n        remoteAddress: string;\r\n        remotePort: number;\r\n    }\r\n\r\n    export interface SecurePair {\r\n        encrypted: any;\r\n        cleartext: any;\r\n    }\r\n\r\n    export interface SecureContextOptions {\r\n        pfx?: string | Buffer | Array<string | Buffer | Object>;\r\n        key?: string | Buffer | Array<Buffer | Object>;\r\n        passphrase?: string;\r\n        cert?: string | Buffer | Array<string | Buffer>;\r\n        ca?: string | Buffer | Array<string | Buffer>;\r\n        ciphers?: string;\r\n        honorCipherOrder?: boolean;\r\n        ecdhCurve?: string;\r\n        crl?: string | Buffer | Array<string | Buffer>;\r\n        dhparam?: string | Buffer;\r\n        secureOptions?: number; // Value is a numeric bitmask of the `SSL_OP_*` options\r\n        secureProtocol?: string; // SSL Method, e.g. SSLv23_method\r\n        sessionIdContext?: string;\r\n    }\r\n\r\n    export interface SecureContext {\r\n        context: any;\r\n    }\r\n\r\n    /*\r\n     * Verifies the certificate `cert` is issued to host `host`.\r\n     * @host The hostname to verify the certificate against\r\n     * @cert PeerCertificate representing the peer's certificate\r\n     *\r\n     * Returns Error object, populating it with the reason, host and cert on failure.  On success, returns undefined.\r\n     */\r\n    export function checkServerIdentity(host: string, cert: PeerCertificate): Error | undefined;\r\n    export function createServer(options: TlsOptions, secureConnectionListener?: (socket: TLSSocket) => void): Server;\r\n    export function connect(options: ConnectionOptions, secureConnectionListener?: () => void): TLSSocket;\r\n    export function connect(port: number, host?: string, options?: ConnectionOptions, secureConnectListener?: () => void): TLSSocket;\r\n    export function connect(port: number, options?: ConnectionOptions, secureConnectListener?: () => void): TLSSocket;\r\n    export function createSecurePair(credentials?: crypto.Credentials, isServer?: boolean, requestCert?: boolean, rejectUnauthorized?: boolean): SecurePair;\r\n    export function createSecureContext(details: SecureContextOptions): SecureContext;\r\n    export function getCiphers(): string[];\r\n\r\n    export var DEFAULT_ECDH_CURVE: string;\r\n}\r\n\r\ndeclare module \"crypto\" {\r\n    export interface Certificate {\r\n        exportChallenge(spkac: string | Buffer): Buffer;\r\n        exportPublicKey(spkac: string | Buffer): Buffer;\r\n        verifySpkac(spkac: Buffer): boolean;\r\n    }\r\n    export var Certificate: {\r\n        new(): Certificate;\r\n        (): Certificate;\r\n    };\r\n\r\n    export var fips: boolean;\r\n\r\n    export interface CredentialDetails {\r\n        pfx: string;\r\n        key: string;\r\n        passphrase: string;\r\n        cert: string;\r\n        ca: string | string[];\r\n        crl: string | string[];\r\n        ciphers: string;\r\n    }\r\n    export interface Credentials { context?: any; }\r\n    export function createCredentials(details: CredentialDetails): Credentials;\r\n    export function createHash(algorithm: string): Hash;\r\n    export function createHmac(algorithm: string, key: string | Buffer): Hmac;\r\n\r\n    type Utf8AsciiLatin1Encoding = \"utf8\" | \"ascii\" | \"latin1\";\r\n    type HexBase64Latin1Encoding = \"latin1\" | \"hex\" | \"base64\";\r\n    type Utf8AsciiBinaryEncoding = \"utf8\" | \"ascii\" | \"binary\";\r\n    type HexBase64BinaryEncoding = \"binary\" | \"base64\" | \"hex\";\r\n    type ECDHKeyFormat = \"compressed\" | \"uncompressed\" | \"hybrid\";\r\n\r\n    export interface Hash extends NodeJS.ReadWriteStream {\r\n        update(data: string | Buffer | DataView): Hash;\r\n        update(data: string | Buffer | DataView, input_encoding: Utf8AsciiLatin1Encoding): Hash;\r\n        digest(): Buffer;\r\n        digest(encoding: HexBase64Latin1Encoding): string;\r\n    }\r\n    export interface Hmac extends NodeJS.ReadWriteStream {\r\n        update(data: string | Buffer | DataView): Hmac;\r\n        update(data: string | Buffer | DataView, input_encoding: Utf8AsciiLatin1Encoding): Hmac;\r\n        digest(): Buffer;\r\n        digest(encoding: HexBase64Latin1Encoding): string;\r\n    }\r\n    export function createCipher(algorithm: string, password: any): Cipher;\r\n    export function createCipheriv(algorithm: string, key: any, iv: any): Cipher;\r\n    export interface Cipher extends NodeJS.ReadWriteStream {\r\n        update(data: Buffer | DataView): Buffer;\r\n        update(data: string, input_encoding: Utf8AsciiBinaryEncoding): Buffer;\r\n        update(data: Buffer | DataView, input_encoding: any, output_encoding: HexBase64BinaryEncoding): string;\r\n        update(data: string, input_encoding: Utf8AsciiBinaryEncoding, output_encoding: HexBase64BinaryEncoding): string;\r\n        final(): Buffer;\r\n        final(output_encoding: string): string;\r\n        setAutoPadding(auto_padding?: boolean): void;\r\n        getAuthTag(): Buffer;\r\n        setAAD(buffer: Buffer): void;\r\n    }\r\n    export function createDecipher(algorithm: string, password: any): Decipher;\r\n    export function createDecipheriv(algorithm: string, key: any, iv: any): Decipher;\r\n    export interface Decipher extends NodeJS.ReadWriteStream {\r\n        update(data: Buffer | DataView): Buffer;\r\n        update(data: string, input_encoding: HexBase64BinaryEncoding): Buffer;\r\n        update(data: Buffer | DataView, input_encoding: any, output_encoding: Utf8AsciiBinaryEncoding): string;\r\n        update(data: string, input_encoding: HexBase64BinaryEncoding, output_encoding: Utf8AsciiBinaryEncoding): string;\r\n        final(): Buffer;\r\n        final(output_encoding: string): string;\r\n        setAutoPadding(auto_padding?: boolean): void;\r\n        setAuthTag(tag: Buffer): void;\r\n        setAAD(buffer: Buffer): void;\r\n    }\r\n    export function createSign(algorithm: string): Signer;\r\n    export interface Signer extends NodeJS.WritableStream {\r\n        update(data: string | Buffer | DataView): Signer;\r\n        update(data: string | Buffer | DataView, input_encoding: Utf8AsciiLatin1Encoding): Signer;\r\n        sign(private_key: string | { key: string; passphrase: string }): Buffer;\r\n        sign(private_key: string | { key: string; passphrase: string }, output_format: HexBase64Latin1Encoding): string;\r\n    }\r\n    export function createVerify(algorith: string): Verify;\r\n    export interface Verify extends NodeJS.WritableStream {\r\n        update(data: string | Buffer | DataView): Verify;\r\n        update(data: string | Buffer | DataView, input_encoding: Utf8AsciiLatin1Encoding): Verify;\r\n        verify(object: string | Object, signature: Buffer | DataView): boolean;\r\n        verify(object: string | Object, signature: string, signature_format: HexBase64Latin1Encoding): boolean;\r\n        // https://nodejs.org/api/crypto.html#crypto_verifier_verify_object_signature_signature_format\r\n        // The signature field accepts a TypedArray type, but it is only available starting ES2017\r\n    }\r\n    export function createDiffieHellman(prime_length: number, generator?: number): DiffieHellman;\r\n    export function createDiffieHellman(prime: Buffer): DiffieHellman;\r\n    export function createDiffieHellman(prime: string, prime_encoding: HexBase64Latin1Encoding): DiffieHellman;\r\n    export function createDiffieHellman(prime: string, prime_encoding: HexBase64Latin1Encoding, generator: number | Buffer): DiffieHellman;\r\n    export function createDiffieHellman(prime: string, prime_encoding: HexBase64Latin1Encoding, generator: string, generator_encoding: HexBase64Latin1Encoding): DiffieHellman;\r\n    export interface DiffieHellman {\r\n        generateKeys(): Buffer;\r\n        generateKeys(encoding: HexBase64Latin1Encoding): string;\r\n        computeSecret(other_public_key: Buffer): Buffer;\r\n        computeSecret(other_public_key: string, input_encoding: HexBase64Latin1Encoding): Buffer;\r\n        computeSecret(other_public_key: string, input_encoding: HexBase64Latin1Encoding, output_encoding: HexBase64Latin1Encoding): string;\r\n        getPrime(): Buffer;\r\n        getPrime(encoding: HexBase64Latin1Encoding): string;\r\n        getGenerator(): Buffer;\r\n        getGenerator(encoding: HexBase64Latin1Encoding): string;\r\n        getPublicKey(): Buffer;\r\n        getPublicKey(encoding: HexBase64Latin1Encoding): string;\r\n        getPrivateKey(): Buffer;\r\n        getPrivateKey(encoding: HexBase64Latin1Encoding): string;\r\n        setPublicKey(public_key: Buffer): void;\r\n        setPublicKey(public_key: string, encoding: string): void;\r\n        setPrivateKey(private_key: Buffer): void;\r\n        setPrivateKey(private_key: string, encoding: string): void;\r\n        verifyError: number;\r\n    }\r\n    export function getDiffieHellman(group_name: string): DiffieHellman;\r\n    export function pbkdf2(password: string | Buffer, salt: string | Buffer, iterations: number, keylen: number, digest: string, callback: (err: Error, derivedKey: Buffer) => any): void;\r\n    export function pbkdf2Sync(password: string | Buffer, salt: string | Buffer, iterations: number, keylen: number, digest: string): Buffer;\r\n    export function randomBytes(size: number): Buffer;\r\n    export function randomBytes(size: number, callback: (err: Error, buf: Buffer) => void): void;\r\n    export function pseudoRandomBytes(size: number): Buffer;\r\n    export function pseudoRandomBytes(size: number, callback: (err: Error, buf: Buffer) => void): void;\r\n    export function randomFillSync(buffer: Buffer | Uint8Array, offset?: number, size?: number): Buffer;\r\n    export function randomFill(buffer: Buffer, callback: (err: Error, buf: Buffer) => void): void;\r\n    export function randomFill(buffer: Uint8Array, callback: (err: Error, buf: Uint8Array) => void): void;\r\n    export function randomFill(buffer: Buffer, offset: number, callback: (err: Error, buf: Buffer) => void): void;\r\n    export function randomFill(buffer: Uint8Array, offset: number, callback: (err: Error, buf: Uint8Array) => void): void;\r\n    export function randomFill(buffer: Buffer, offset: number, size: number, callback: (err: Error, buf: Buffer) => void): void;\r\n    export function randomFill(buffer: Uint8Array, offset: number, size: number, callback: (err: Error, buf: Uint8Array) => void): void;\r\n    export interface RsaPublicKey {\r\n        key: string;\r\n        padding?: number;\r\n    }\r\n    export interface RsaPrivateKey {\r\n        key: string;\r\n        passphrase?: string;\r\n        padding?: number;\r\n    }\r\n    export function publicEncrypt(public_key: string | RsaPublicKey, buffer: Buffer): Buffer;\r\n    export function privateDecrypt(private_key: string | RsaPrivateKey, buffer: Buffer): Buffer;\r\n    export function privateEncrypt(private_key: string | RsaPrivateKey, buffer: Buffer): Buffer;\r\n    export function publicDecrypt(public_key: string | RsaPublicKey, buffer: Buffer): Buffer;\r\n    export function getCiphers(): string[];\r\n    export function getCurves(): string[];\r\n    export function getHashes(): string[];\r\n    export interface ECDH {\r\n        generateKeys(): Buffer;\r\n        generateKeys(encoding: HexBase64Latin1Encoding): string;\r\n        generateKeys(encoding: HexBase64Latin1Encoding, format: ECDHKeyFormat): string;\r\n        computeSecret(other_public_key: Buffer): Buffer;\r\n        computeSecret(other_public_key: string, input_encoding: HexBase64Latin1Encoding): Buffer;\r\n        computeSecret(other_public_key: string, input_encoding: HexBase64Latin1Encoding, output_encoding: HexBase64Latin1Encoding): string;\r\n        getPrivateKey(): Buffer;\r\n        getPrivateKey(encoding: HexBase64Latin1Encoding): string;\r\n        getPublicKey(): Buffer;\r\n        getPublicKey(encoding: HexBase64Latin1Encoding): string;\r\n        getPublicKey(encoding: HexBase64Latin1Encoding, format: ECDHKeyFormat): string;\r\n        setPrivateKey(private_key: Buffer): void;\r\n        setPrivateKey(private_key: string, encoding: HexBase64Latin1Encoding): void;\r\n    }\r\n    export function createECDH(curve_name: string): ECDH;\r\n    export function timingSafeEqual(a: Buffer, b: Buffer): boolean;\r\n    export var DEFAULT_ENCODING: string;\r\n}\r\n\r\ndeclare module \"stream\" {\r\n    import * as events from \"events\";\r\n\r\n    class internal extends events.EventEmitter {\r\n        pipe<T extends NodeJS.WritableStream>(destination: T, options?: { end?: boolean; }): T;\r\n    }\r\n\r\n    namespace internal {\r\n        export class Stream extends internal { }\r\n\r\n        export interface ReadableOptions {\r\n            highWaterMark?: number;\r\n            encoding?: string;\r\n            objectMode?: boolean;\r\n            read?: (this: Readable, size?: number) => any;\r\n            destroy?: (error?: Error) => any;\r\n        }\r\n\r\n        export class Readable extends Stream implements NodeJS.ReadableStream {\r\n            readable: boolean;\r\n            constructor(opts?: ReadableOptions);\r\n            _read(size: number): void;\r\n            read(size?: number): any;\r\n            setEncoding(encoding: string): this;\r\n            pause(): this;\r\n            resume(): this;\r\n            isPaused(): boolean;\r\n            unpipe<T extends NodeJS.WritableStream>(destination?: T): this;\r\n            unshift(chunk: any): void;\r\n            wrap(oldStream: NodeJS.ReadableStream): this;\r\n            push(chunk: any, encoding?: string): boolean;\r\n            _destroy(err: Error, callback: Function): void;\r\n            destroy(error?: Error): void;\r\n\r\n            /**\r\n             * Event emitter\r\n             * The defined events on documents including:\r\n             * 1. close\r\n             * 2. data\r\n             * 3. end\r\n             * 4. readable\r\n             * 5. error\r\n             */\r\n            addListener(event: string, listener: (...args: any[]) => void): this;\r\n            addListener(event: string, listener: (...args: any[]) => void): this;\r\n            addListener(event: \"close\", listener: () => void): this;\r\n            addListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\r\n            addListener(event: \"end\", listener: () => void): this;\r\n            addListener(event: \"readable\", listener: () => void): this;\r\n            addListener(event: \"error\", listener: (err: Error) => void): this;\r\n\r\n            emit(event: string | symbol, ...args: any[]): boolean;\r\n            emit(event: \"close\"): boolean;\r\n            emit(event: \"data\", chunk: Buffer | string): boolean;\r\n            emit(event: \"end\"): boolean;\r\n            emit(event: \"readable\"): boolean;\r\n            emit(event: \"error\", err: Error): boolean;\r\n\r\n            on(event: string, listener: (...args: any[]) => void): this;\r\n            on(event: \"close\", listener: () => void): this;\r\n            on(event: \"data\", listener: (chunk: Buffer | string) => void): this;\r\n            on(event: \"end\", listener: () => void): this;\r\n            on(event: \"readable\", listener: () => void): this;\r\n            on(event: \"error\", listener: (err: Error) => void): this;\r\n\r\n            once(event: string, listener: (...args: any[]) => void): this;\r\n            once(event: \"close\", listener: () => void): this;\r\n            once(event: \"data\", listener: (chunk: Buffer | string) => void): this;\r\n            once(event: \"end\", listener: () => void): this;\r\n            once(event: \"readable\", listener: () => void): this;\r\n            once(event: \"error\", listener: (err: Error) => void): this;\r\n\r\n            prependListener(event: string, listener: (...args: any[]) => void): this;\r\n            prependListener(event: \"close\", listener: () => void): this;\r\n            prependListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\r\n            prependListener(event: \"end\", listener: () => void): this;\r\n            prependListener(event: \"readable\", listener: () => void): this;\r\n            prependListener(event: \"error\", listener: (err: Error) => void): this;\r\n\r\n            prependOnceListener(event: string, listener: (...args: any[]) => void): this;\r\n            prependOnceListener(event: \"close\", listener: () => void): this;\r\n            prependOnceListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\r\n            prependOnceListener(event: \"end\", listener: () => void): this;\r\n            prependOnceListener(event: \"readable\", listener: () => void): this;\r\n            prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\r\n\r\n            removeListener(event: string, listener: (...args: any[]) => void): this;\r\n            removeListener(event: \"close\", listener: () => void): this;\r\n            removeListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\r\n            removeListener(event: \"end\", listener: () => void): this;\r\n            removeListener(event: \"readable\", listener: () => void): this;\r\n            removeListener(event: \"error\", listener: (err: Error) => void): this;\r\n        }\r\n\r\n        export interface WritableOptions {\r\n            highWaterMark?: number;\r\n            decodeStrings?: boolean;\r\n            objectMode?: boolean;\r\n            write?: (chunk: string | Buffer, encoding: string, callback: Function) => any;\r\n            writev?: (chunks: Array<{ chunk: string | Buffer, encoding: string }>, callback: Function) => any;\r\n            destroy?: (error?: Error) => any;\r\n            final?: (callback: (error?: Error) => void) => void;\r\n        }\r\n\r\n        export class Writable extends Stream implements NodeJS.WritableStream {\r\n            writable: boolean;\r\n            constructor(opts?: WritableOptions);\r\n            _write(chunk: any, encoding: string, callback: (err?: Error) => void): void;\r\n            _writev?(chunks: Array<{chunk: any, encoding: string}>, callback: (err?: Error) => void): void;\r\n            _destroy(err: Error, callback: Function): void;\r\n            _final(callback: Function): void;\r\n            write(chunk: any, cb?: Function): boolean;\r\n            write(chunk: any, encoding?: string, cb?: Function): boolean;\r\n            setDefaultEncoding(encoding: string): this;\r\n            end(cb?: Function): void;\r\n            end(chunk: any, cb?: Function): void;\r\n            end(chunk: any, encoding?: string, cb?: Function): void;\r\n            cork(): void;\r\n            uncork(): void;\r\n            destroy(error?: Error): void;\r\n\r\n            /**\r\n             * Event emitter\r\n             * The defined events on documents including:\r\n             * 1. close\r\n             * 2. drain\r\n             * 3. error\r\n             * 4. finish\r\n             * 5. pipe\r\n             * 6. unpipe\r\n             */\r\n            addListener(event: string, listener: (...args: any[]) => void): this;\r\n            addListener(event: \"close\", listener: () => void): this;\r\n            addListener(event: \"drain\", listener: () => void): this;\r\n            addListener(event: \"error\", listener: (err: Error) => void): this;\r\n            addListener(event: \"finish\", listener: () => void): this;\r\n            addListener(event: \"pipe\", listener: (src: Readable) => void): this;\r\n            addListener(event: \"unpipe\", listener: (src: Readable) => void): this;\r\n\r\n            emit(event: string | symbol, ...args: any[]): boolean;\r\n            emit(event: \"close\"): boolean;\r\n            emit(event: \"drain\", chunk: Buffer | string): boolean;\r\n            emit(event: \"error\", err: Error): boolean;\r\n            emit(event: \"finish\"): boolean;\r\n            emit(event: \"pipe\", src: Readable): boolean;\r\n            emit(event: \"unpipe\", src: Readable): boolean;\r\n\r\n            on(event: string, listener: (...args: any[]) => void): this;\r\n            on(event: \"close\", listener: () => void): this;\r\n            on(event: \"drain\", listener: () => void): this;\r\n            on(event: \"error\", listener: (err: Error) => void): this;\r\n            on(event: \"finish\", listener: () => void): this;\r\n            on(event: \"pipe\", listener: (src: Readable) => void): this;\r\n            on(event: \"unpipe\", listener: (src: Readable) => void): this;\r\n\r\n            once(event: string, listener: (...args: any[]) => void): this;\r\n            once(event: \"close\", listener: () => void): this;\r\n            once(event: \"drain\", listener: () => void): this;\r\n            once(event: \"error\", listener: (err: Error) => void): this;\r\n            once(event: \"finish\", listener: () => void): this;\r\n            once(event: \"pipe\", listener: (src: Readable) => void): this;\r\n            once(event: \"unpipe\", listener: (src: Readable) => void): this;\r\n\r\n            prependListener(event: string, listener: (...args: any[]) => void): this;\r\n            prependListener(event: \"close\", listener: () => void): this;\r\n            prependListener(event: \"drain\", listener: () => void): this;\r\n            prependListener(event: \"error\", listener: (err: Error) => void): this;\r\n            prependListener(event: \"finish\", listener: () => void): this;\r\n            prependListener(event: \"pipe\", listener: (src: Readable) => void): this;\r\n            prependListener(event: \"unpipe\", listener: (src: Readable) => void): this;\r\n\r\n            prependOnceListener(event: string, listener: (...args: any[]) => void): this;\r\n            prependOnceListener(event: \"close\", listener: () => void): this;\r\n            prependOnceListener(event: \"drain\", listener: () => void): this;\r\n            prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\r\n            prependOnceListener(event: \"finish\", listener: () => void): this;\r\n            prependOnceListener(event: \"pipe\", listener: (src: Readable) => void): this;\r\n            prependOnceListener(event: \"unpipe\", listener: (src: Readable) => void): this;\r\n\r\n            removeListener(event: string, listener: (...args: any[]) => void): this;\r\n            removeListener(event: \"close\", listener: () => void): this;\r\n            removeListener(event: \"drain\", listener: () => void): this;\r\n            removeListener(event: \"error\", listener: (err: Error) => void): this;\r\n            removeListener(event: \"finish\", listener: () => void): this;\r\n            removeListener(event: \"pipe\", listener: (src: Readable) => void): this;\r\n            removeListener(event: \"unpipe\", listener: (src: Readable) => void): this;\r\n        }\r\n\r\n        export interface DuplexOptions extends ReadableOptions, WritableOptions {\r\n            allowHalfOpen?: boolean;\r\n            readableObjectMode?: boolean;\r\n            writableObjectMode?: boolean;\r\n        }\r\n\r\n        // Note: Duplex extends both Readable and Writable.\r\n        export class Duplex extends Readable implements Writable {\r\n            writable: boolean;\r\n            constructor(opts?: DuplexOptions);\r\n            _write(chunk: any, encoding: string, callback: (err?: Error) => void): void;\r\n            _writev?(chunks: Array<{chunk: any, encoding: string}>, callback: (err?: Error) => void): void;\r\n            _destroy(err: Error, callback: Function): void;\r\n            _final(callback: Function): void;\r\n            write(chunk: any, cb?: Function): boolean;\r\n            write(chunk: any, encoding?: string, cb?: Function): boolean;\r\n            setDefaultEncoding(encoding: string): this;\r\n            end(cb?: Function): void;\r\n            end(chunk: any, cb?: Function): void;\r\n            end(chunk: any, encoding?: string, cb?: Function): void;\r\n            cork(): void;\r\n            uncork(): void;\r\n        }\r\n\r\n        export interface TransformOptions extends DuplexOptions {\r\n            transform?: (chunk: string | Buffer, encoding: string, callback: Function) => any;\r\n            flush?: (callback: Function) => any;\r\n        }\r\n\r\n        export class Transform extends Duplex {\r\n            constructor(opts?: TransformOptions);\r\n            _transform(chunk: any, encoding: string, callback: Function): void;\r\n            destroy(error?: Error): void;\r\n        }\r\n\r\n        export class PassThrough extends Transform { }\r\n    }\r\n\r\n    export = internal;\r\n}\r\n\r\ndeclare module \"util\" {\r\n    export interface InspectOptions extends NodeJS.InspectOptions { }\r\n    export function format(format: any, ...param: any[]): string;\r\n    export function debug(string: string): void;\r\n    export function error(...param: any[]): void;\r\n    export function puts(...param: any[]): void;\r\n    export function print(...param: any[]): void;\r\n    export function log(string: string): void;\r\n    export var inspect: {\r\n        (object: any, showHidden?: boolean, depth?: number | null, color?: boolean): string;\r\n        (object: any, options: InspectOptions): string;\r\n        colors: {\r\n            [color: string]: [number, number] | undefined\r\n        }\r\n        styles: {\r\n            [style: string]: string | undefined\r\n        }\r\n        defaultOptions: InspectOptions;\r\n        custom: symbol;\r\n    };\r\n    export function isArray(object: any): object is any[];\r\n    export function isRegExp(object: any): object is RegExp;\r\n    export function isDate(object: any): object is Date;\r\n    export function isError(object: any): object is Error;\r\n    export function inherits(constructor: any, superConstructor: any): void;\r\n    export function debuglog(key: string): (msg: string, ...param: any[]) => void;\r\n    export function isBoolean(object: any): object is boolean;\r\n    export function isBuffer(object: any): object is Buffer;\r\n    export function isFunction(object: any): boolean;\r\n    export function isNull(object: any): object is null;\r\n    export function isNullOrUndefined(object: any): object is null | undefined;\r\n    export function isNumber(object: any): object is number;\r\n    export function isObject(object: any): boolean;\r\n    export function isPrimitive(object: any): boolean;\r\n    export function isString(object: any): object is string;\r\n    export function isSymbol(object: any): object is symbol;\r\n    export function isUndefined(object: any): object is undefined;\r\n    export function deprecate<T extends Function>(fn: T, message: string): T;\r\n\r\n    export interface CustomPromisify<TCustom extends Function> extends Function {\r\n        __promisify__: TCustom;\r\n    }\r\n\r\n    export function callbackify(fn: () => Promise<void>): (callback: (err: NodeJS.ErrnoException) => void) => void;\r\n    export function callbackify<TResult>(fn: () => Promise<TResult>): (callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\r\n    export function callbackify<T1>(fn: (arg1: T1) => Promise<void>): (arg1: T1, callback: (err: NodeJS.ErrnoException) => void) => void;\r\n    export function callbackify<T1, TResult>(fn: (arg1: T1) => Promise<TResult>): (arg1: T1, callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\r\n    export function callbackify<T1, T2>(fn: (arg1: T1, arg2: T2) => Promise<void>): (arg1: T1, arg2: T2, callback: (err: NodeJS.ErrnoException) => void) => void;\r\n    export function callbackify<T1, T2, TResult>(fn: (arg1: T1, arg2: T2) => Promise<TResult>): (arg1: T1, arg2: T2, callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\r\n    export function callbackify<T1, T2, T3>(fn: (arg1: T1, arg2: T2, arg3: T3) => Promise<void>): (arg1: T1, arg2: T2, arg3: T3, callback: (err: NodeJS.ErrnoException) => void) => void;\r\n    export function callbackify<T1, T2, T3, TResult>(fn: (arg1: T1, arg2: T2, arg3: T3) => Promise<TResult>): (arg1: T1, arg2: T2, arg3: T3,  callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\r\n    export function callbackify<T1, T2, T3, T4>(fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<void>): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: (err: NodeJS.ErrnoException) => void) => void;\r\n    export function callbackify<T1, T2, T3, T4, TResult>(fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<TResult>): (arg1: T1, arg2: T2, arg3: T3, arg4: T4,  callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\r\n    export function callbackify<T1, T2, T3, T4, T5>(fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<void>): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: (err: NodeJS.ErrnoException) => void) => void;\r\n    export function callbackify<T1, T2, T3, T4, T5, TResult>(fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<TResult>): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\r\n    export function callbackify<T1, T2, T3, T4, T5, T6>(fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6) => Promise<void>): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, callback: (err: NodeJS.ErrnoException) => void) => void;\r\n    export function callbackify<T1, T2, T3, T4, T5, T6, TResult>(fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6) => Promise<TResult>): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\r\n\r\n    export function promisify<TCustom extends Function>(fn: CustomPromisify<TCustom>): TCustom;\r\n    export function promisify<TResult>(fn: (callback: (err: Error, result: TResult) => void) => void): () => Promise<TResult>;\r\n    export function promisify(fn: (callback: (err: Error) => void) => void): () => Promise<void>;\r\n    export function promisify<T1, TResult>(fn: (arg1: T1, callback: (err: Error, result: TResult) => void) => void): (arg1: T1) => Promise<TResult>;\r\n    export function promisify<T1>(fn: (arg1: T1, callback: (err: Error) => void) => void): (arg1: T1) => Promise<void>;\r\n    export function promisify<T1, T2, TResult>(fn: (arg1: T1, arg2: T2, callback: (err: Error, result: TResult) => void) => void): (arg1: T1, arg2: T2) => Promise<TResult>;\r\n    export function promisify<T1, T2>(fn: (arg1: T1, arg2: T2, callback: (err: Error) => void) => void): (arg1: T1, arg2: T2) => Promise<void>;\r\n    export function promisify<T1, T2, T3, TResult>(fn: (arg1: T1, arg2: T2, arg3: T3, callback: (err: Error, result: TResult) => void) => void): (arg1: T1, arg2: T2, arg3: T3) => Promise<TResult>;\r\n    export function promisify<T1, T2, T3>(fn: (arg1: T1, arg2: T2, arg3: T3, callback: (err: Error) => void) => void): (arg1: T1, arg2: T2, arg3: T3) => Promise<void>;\r\n    export function promisify<T1, T2, T3, T4, TResult>(fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: (err: Error, result: TResult) => void) => void): (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<TResult>;\r\n    export function promisify<T1, T2, T3, T4>(fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: (err: Error) => void) => void): (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<void>;\r\n    export function promisify<T1, T2, T3, T4, T5, TResult>(fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: (err: Error, result: TResult) => void) => void): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<TResult>;\r\n    export function promisify<T1, T2, T3, T4, T5>(fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: (err: Error) => void) => void): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<void>;\r\n    export function promisify(fn: Function): Function;\r\n    export namespace promisify {\r\n        const custom: symbol;\r\n    }\r\n}\r\n\r\ndeclare module \"assert\" {\r\n    function internal(value: any, message?: string): void;\r\n    namespace internal {\r\n        export class AssertionError implements Error {\r\n            name: string;\r\n            message: string;\r\n            actual: any;\r\n            expected: any;\r\n            operator: string;\r\n            generatedMessage: boolean;\r\n\r\n            constructor(options?: {\r\n                message?: string; actual?: any; expected?: any;\r\n                operator?: string; stackStartFunction?: Function\r\n            });\r\n        }\r\n\r\n        export function fail(message: string): void;\r\n        export function fail(actual: any, expected: any, message?: string, operator?: string): void;\r\n        export function ok(value: any, message?: string): void;\r\n        export function equal(actual: any, expected: any, message?: string): void;\r\n        export function notEqual(actual: any, expected: any, message?: string): void;\r\n        export function deepEqual(actual: any, expected: any, message?: string): void;\r\n        export function notDeepEqual(acutal: any, expected: any, message?: string): void;\r\n        export function strictEqual(actual: any, expected: any, message?: string): void;\r\n        export function notStrictEqual(actual: any, expected: any, message?: string): void;\r\n        export function deepStrictEqual(actual: any, expected: any, message?: string): void;\r\n        export function notDeepStrictEqual(actual: any, expected: any, message?: string): void;\r\n\r\n        export function throws(block: Function, message?: string): void;\r\n        export function throws(block: Function, error: Function, message?: string): void;\r\n        export function throws(block: Function, error: RegExp, message?: string): void;\r\n        export function throws(block: Function, error: (err: any) => boolean, message?: string): void;\r\n\r\n        export function doesNotThrow(block: Function, message?: string): void;\r\n        export function doesNotThrow(block: Function, error: Function, message?: string): void;\r\n        export function doesNotThrow(block: Function, error: RegExp, message?: string): void;\r\n        export function doesNotThrow(block: Function, error: (err: any) => boolean, message?: string): void;\r\n\r\n        export function ifError(value: any): void;\r\n    }\r\n\r\n    export = internal;\r\n}\r\n\r\ndeclare module \"tty\" {\r\n    import * as net from \"net\";\r\n\r\n    export function isatty(fd: number): boolean;\r\n    export interface ReadStream extends net.Socket {\r\n        isRaw: boolean;\r\n        setRawMode(mode: boolean): void;\r\n        isTTY: boolean;\r\n    }\r\n    export interface WriteStream extends net.Socket {\r\n        columns: number;\r\n        rows: number;\r\n        isTTY: boolean;\r\n    }\r\n}\r\n\r\ndeclare module \"domain\" {\r\n    import * as events from \"events\";\r\n\r\n    export class Domain extends events.EventEmitter implements NodeJS.Domain {\r\n        run(fn: Function): void;\r\n        add(emitter: events.EventEmitter): void;\r\n        remove(emitter: events.EventEmitter): void;\r\n        bind(cb: (err: Error, data: any) => any): any;\r\n        intercept(cb: (data: any) => any): any;\r\n        dispose(): void;\r\n        members: any[];\r\n        enter(): void;\r\n        exit(): void;\r\n    }\r\n\r\n    export function create(): Domain;\r\n}\r\n\r\ndeclare module \"constants\" {\r\n    export var E2BIG: number;\r\n    export var EACCES: number;\r\n    export var EADDRINUSE: number;\r\n    export var EADDRNOTAVAIL: number;\r\n    export var EAFNOSUPPORT: number;\r\n    export var EAGAIN: number;\r\n    export var EALREADY: number;\r\n    export var EBADF: number;\r\n    export var EBADMSG: number;\r\n    export var EBUSY: number;\r\n    export var ECANCELED: number;\r\n    export var ECHILD: number;\r\n    export var ECONNABORTED: number;\r\n    export var ECONNREFUSED: number;\r\n    export var ECONNRESET: number;\r\n    export var EDEADLK: number;\r\n    export var EDESTADDRREQ: number;\r\n    export var EDOM: number;\r\n    export var EEXIST: number;\r\n    export var EFAULT: number;\r\n    export var EFBIG: number;\r\n    export var EHOSTUNREACH: number;\r\n    export var EIDRM: number;\r\n    export var EILSEQ: number;\r\n    export var EINPROGRESS: number;\r\n    export var EINTR: number;\r\n    export var EINVAL: number;\r\n    export var EIO: number;\r\n    export var EISCONN: number;\r\n    export var EISDIR: number;\r\n    export var ELOOP: number;\r\n    export var EMFILE: number;\r\n    export var EMLINK: number;\r\n    export var EMSGSIZE: number;\r\n    export var ENAMETOOLONG: number;\r\n    export var ENETDOWN: number;\r\n    export var ENETRESET: number;\r\n    export var ENETUNREACH: number;\r\n    export var ENFILE: number;\r\n    export var ENOBUFS: number;\r\n    export var ENODATA: number;\r\n    export var ENODEV: number;\r\n    export var ENOENT: number;\r\n    export var ENOEXEC: number;\r\n    export var ENOLCK: number;\r\n    export var ENOLINK: number;\r\n    export var ENOMEM: number;\r\n    export var ENOMSG: number;\r\n    export var ENOPROTOOPT: number;\r\n    export var ENOSPC: number;\r\n    export var ENOSR: number;\r\n    export var ENOSTR: number;\r\n    export var ENOSYS: number;\r\n    export var ENOTCONN: number;\r\n    export var ENOTDIR: number;\r\n    export var ENOTEMPTY: number;\r\n    export var ENOTSOCK: number;\r\n    export var ENOTSUP: number;\r\n    export var ENOTTY: number;\r\n    export var ENXIO: number;\r\n    export var EOPNOTSUPP: number;\r\n    export var EOVERFLOW: number;\r\n    export var EPERM: number;\r\n    export var EPIPE: number;\r\n    export var EPROTO: number;\r\n    export var EPROTONOSUPPORT: number;\r\n    export var EPROTOTYPE: number;\r\n    export var ERANGE: number;\r\n    export var EROFS: number;\r\n    export var ESPIPE: number;\r\n    export var ESRCH: number;\r\n    export var ETIME: number;\r\n    export var ETIMEDOUT: number;\r\n    export var ETXTBSY: number;\r\n    export var EWOULDBLOCK: number;\r\n    export var EXDEV: number;\r\n    export var WSAEINTR: number;\r\n    export var WSAEBADF: number;\r\n    export var WSAEACCES: number;\r\n    export var WSAEFAULT: number;\r\n    export var WSAEINVAL: number;\r\n    export var WSAEMFILE: number;\r\n    export var WSAEWOULDBLOCK: number;\r\n    export var WSAEINPROGRESS: number;\r\n    export var WSAEALREADY: number;\r\n    export var WSAENOTSOCK: number;\r\n    export var WSAEDESTADDRREQ: number;\r\n    export var WSAEMSGSIZE: number;\r\n    export var WSAEPROTOTYPE: number;\r\n    export var WSAENOPROTOOPT: number;\r\n    export var WSAEPROTONOSUPPORT: number;\r\n    export var WSAESOCKTNOSUPPORT: number;\r\n    export var WSAEOPNOTSUPP: number;\r\n    export var WSAEPFNOSUPPORT: number;\r\n    export var WSAEAFNOSUPPORT: number;\r\n    export var WSAEADDRINUSE: number;\r\n    export var WSAEADDRNOTAVAIL: number;\r\n    export var WSAENETDOWN: number;\r\n    export var WSAENETUNREACH: number;\r\n    export var WSAENETRESET: number;\r\n    export var WSAECONNABORTED: number;\r\n    export var WSAECONNRESET: number;\r\n    export var WSAENOBUFS: number;\r\n    export var WSAEISCONN: number;\r\n    export var WSAENOTCONN: number;\r\n    export var WSAESHUTDOWN: number;\r\n    export var WSAETOOMANYREFS: number;\r\n    export var WSAETIMEDOUT: number;\r\n    export var WSAECONNREFUSED: number;\r\n    export var WSAELOOP: number;\r\n    export var WSAENAMETOOLONG: number;\r\n    export var WSAEHOSTDOWN: number;\r\n    export var WSAEHOSTUNREACH: number;\r\n    export var WSAENOTEMPTY: number;\r\n    export var WSAEPROCLIM: number;\r\n    export var WSAEUSERS: number;\r\n    export var WSAEDQUOT: number;\r\n    export var WSAESTALE: number;\r\n    export var WSAEREMOTE: number;\r\n    export var WSASYSNOTREADY: number;\r\n    export var WSAVERNOTSUPPORTED: number;\r\n    export var WSANOTINITIALISED: number;\r\n    export var WSAEDISCON: number;\r\n    export var WSAENOMORE: number;\r\n    export var WSAECANCELLED: number;\r\n    export var WSAEINVALIDPROCTABLE: number;\r\n    export var WSAEINVALIDPROVIDER: number;\r\n    export var WSAEPROVIDERFAILEDINIT: number;\r\n    export var WSASYSCALLFAILURE: number;\r\n    export var WSASERVICE_NOT_FOUND: number;\r\n    export var WSATYPE_NOT_FOUND: number;\r\n    export var WSA_E_NO_MORE: number;\r\n    export var WSA_E_CANCELLED: number;\r\n    export var WSAEREFUSED: number;\r\n    export var SIGHUP: number;\r\n    export var SIGINT: number;\r\n    export var SIGILL: number;\r\n    export var SIGABRT: number;\r\n    export var SIGFPE: number;\r\n    export var SIGKILL: number;\r\n    export var SIGSEGV: number;\r\n    export var SIGTERM: number;\r\n    export var SIGBREAK: number;\r\n    export var SIGWINCH: number;\r\n    export var SSL_OP_ALL: number;\r\n    export var SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: number;\r\n    export var SSL_OP_CIPHER_SERVER_PREFERENCE: number;\r\n    export var SSL_OP_CISCO_ANYCONNECT: number;\r\n    export var SSL_OP_COOKIE_EXCHANGE: number;\r\n    export var SSL_OP_CRYPTOPRO_TLSEXT_BUG: number;\r\n    export var SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: number;\r\n    export var SSL_OP_EPHEMERAL_RSA: number;\r\n    export var SSL_OP_LEGACY_SERVER_CONNECT: number;\r\n    export var SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: number;\r\n    export var SSL_OP_MICROSOFT_SESS_ID_BUG: number;\r\n    export var SSL_OP_MSIE_SSLV2_RSA_PADDING: number;\r\n    export var SSL_OP_NETSCAPE_CA_DN_BUG: number;\r\n    export var SSL_OP_NETSCAPE_CHALLENGE_BUG: number;\r\n    export var SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: number;\r\n    export var SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: number;\r\n    export var SSL_OP_NO_COMPRESSION: number;\r\n    export var SSL_OP_NO_QUERY_MTU: number;\r\n    export var SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: number;\r\n    export var SSL_OP_NO_SSLv2: number;\r\n    export var SSL_OP_NO_SSLv3: number;\r\n    export var SSL_OP_NO_TICKET: number;\r\n    export var SSL_OP_NO_TLSv1: number;\r\n    export var SSL_OP_NO_TLSv1_1: number;\r\n    export var SSL_OP_NO_TLSv1_2: number;\r\n    export var SSL_OP_PKCS1_CHECK_1: number;\r\n    export var SSL_OP_PKCS1_CHECK_2: number;\r\n    export var SSL_OP_SINGLE_DH_USE: number;\r\n    export var SSL_OP_SINGLE_ECDH_USE: number;\r\n    export var SSL_OP_SSLEAY_080_CLIENT_DH_BUG: number;\r\n    export var SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: number;\r\n    export var SSL_OP_TLS_BLOCK_PADDING_BUG: number;\r\n    export var SSL_OP_TLS_D5_BUG: number;\r\n    export var SSL_OP_TLS_ROLLBACK_BUG: number;\r\n    export var ENGINE_METHOD_DSA: number;\r\n    export var ENGINE_METHOD_DH: number;\r\n    export var ENGINE_METHOD_RAND: number;\r\n    export var ENGINE_METHOD_ECDH: number;\r\n    export var ENGINE_METHOD_ECDSA: number;\r\n    export var ENGINE_METHOD_CIPHERS: number;\r\n    export var ENGINE_METHOD_DIGESTS: number;\r\n    export var ENGINE_METHOD_STORE: number;\r\n    export var ENGINE_METHOD_PKEY_METHS: number;\r\n    export var ENGINE_METHOD_PKEY_ASN1_METHS: number;\r\n    export var ENGINE_METHOD_ALL: number;\r\n    export var ENGINE_METHOD_NONE: number;\r\n    export var DH_CHECK_P_NOT_SAFE_PRIME: number;\r\n    export var DH_CHECK_P_NOT_PRIME: number;\r\n    export var DH_UNABLE_TO_CHECK_GENERATOR: number;\r\n    export var DH_NOT_SUITABLE_GENERATOR: number;\r\n    export var NPN_ENABLED: number;\r\n    export var RSA_PKCS1_PADDING: number;\r\n    export var RSA_SSLV23_PADDING: number;\r\n    export var RSA_NO_PADDING: number;\r\n    export var RSA_PKCS1_OAEP_PADDING: number;\r\n    export var RSA_X931_PADDING: number;\r\n    export var RSA_PKCS1_PSS_PADDING: number;\r\n    export var POINT_CONVERSION_COMPRESSED: number;\r\n    export var POINT_CONVERSION_UNCOMPRESSED: number;\r\n    export var POINT_CONVERSION_HYBRID: number;\r\n    export var O_RDONLY: number;\r\n    export var O_WRONLY: number;\r\n    export var O_RDWR: number;\r\n    export var S_IFMT: number;\r\n    export var S_IFREG: number;\r\n    export var S_IFDIR: number;\r\n    export var S_IFCHR: number;\r\n    export var S_IFBLK: number;\r\n    export var S_IFIFO: number;\r\n    export var S_IFSOCK: number;\r\n    export var S_IRWXU: number;\r\n    export var S_IRUSR: number;\r\n    export var S_IWUSR: number;\r\n    export var S_IXUSR: number;\r\n    export var S_IRWXG: number;\r\n    export var S_IRGRP: number;\r\n    export var S_IWGRP: number;\r\n    export var S_IXGRP: number;\r\n    export var S_IRWXO: number;\r\n    export var S_IROTH: number;\r\n    export var S_IWOTH: number;\r\n    export var S_IXOTH: number;\r\n    export var S_IFLNK: number;\r\n    export var O_CREAT: number;\r\n    export var O_EXCL: number;\r\n    export var O_NOCTTY: number;\r\n    export var O_DIRECTORY: number;\r\n    export var O_NOATIME: number;\r\n    export var O_NOFOLLOW: number;\r\n    export var O_SYNC: number;\r\n    export var O_DSYNC: number;\r\n    export var O_SYMLINK: number;\r\n    export var O_DIRECT: number;\r\n    export var O_NONBLOCK: number;\r\n    export var O_TRUNC: number;\r\n    export var O_APPEND: number;\r\n    export var F_OK: number;\r\n    export var R_OK: number;\r\n    export var W_OK: number;\r\n    export var X_OK: number;\r\n    export var UV_UDP_REUSEADDR: number;\r\n    export var SIGQUIT: number;\r\n    export var SIGTRAP: number;\r\n    export var SIGIOT: number;\r\n    export var SIGBUS: number;\r\n    export var SIGUSR1: number;\r\n    export var SIGUSR2: number;\r\n    export var SIGPIPE: number;\r\n    export var SIGALRM: number;\r\n    export var SIGCHLD: number;\r\n    export var SIGSTKFLT: number;\r\n    export var SIGCONT: number;\r\n    export var SIGSTOP: number;\r\n    export var SIGTSTP: number;\r\n    export var SIGTTIN: number;\r\n    export var SIGTTOU: number;\r\n    export var SIGURG: number;\r\n    export var SIGXCPU: number;\r\n    export var SIGXFSZ: number;\r\n    export var SIGVTALRM: number;\r\n    export var SIGPROF: number;\r\n    export var SIGIO: number;\r\n    export var SIGPOLL: number;\r\n    export var SIGPWR: number;\r\n    export var SIGSYS: number;\r\n    export var SIGUNUSED: number;\r\n    export var defaultCoreCipherList: string;\r\n    export var defaultCipherList: string;\r\n    export var ENGINE_METHOD_RSA: number;\r\n    export var ALPN_ENABLED: number;\r\n}\r\n\r\ndeclare module \"module\" {\r\n    export = NodeJS.Module;\r\n}\r\n\r\ndeclare module \"process\" {\r\n    export = process;\r\n}\r\n\r\ndeclare module \"v8\" {\r\n    interface HeapSpaceInfo {\r\n        space_name: string;\r\n        space_size: number;\r\n        space_used_size: number;\r\n        space_available_size: number;\r\n        physical_space_size: number;\r\n    }\r\n\r\n    // ** Signifies if the --zap_code_space option is enabled or not.  1 == enabled, 0 == disabled. */\r\n    type DoesZapCodeSpaceFlag = 0 | 1;\r\n\r\n    interface HeapInfo {\r\n        total_heap_size: number;\r\n        total_heap_size_executable: number;\r\n        total_physical_size: number;\r\n        total_available_size: number;\r\n        used_heap_size: number;\r\n        heap_size_limit: number;\r\n        malloced_memory: number;\r\n        peak_malloced_memory: number;\r\n        does_zap_garbage: DoesZapCodeSpaceFlag;\r\n    }\r\n\r\n    export function getHeapStatistics(): HeapInfo;\r\n    export function getHeapSpaceStatistics(): HeapSpaceInfo[];\r\n    export function setFlagsFromString(flags: string): void;\r\n}\r\n\r\ndeclare module \"timers\" {\r\n    export function setTimeout(callback: (...args: any[]) => void, ms: number, ...args: any[]): NodeJS.Timer;\r\n    export namespace setTimeout {\r\n        export function __promisify__(ms: number): Promise<void>;\r\n        export function __promisify__<T>(ms: number, value: T): Promise<T>;\r\n    }\r\n    export function clearTimeout(timeoutId: NodeJS.Timer): void;\r\n    export function setInterval(callback: (...args: any[]) => void, ms: number, ...args: any[]): NodeJS.Timer;\r\n    export function clearInterval(intervalId: NodeJS.Timer): void;\r\n    export function setImmediate(callback: (...args: any[]) => void, ...args: any[]): any;\r\n    export namespace setImmediate {\r\n        export function __promisify__(): Promise<void>;\r\n        export function __promisify__<T>(value: T): Promise<T>;\r\n    }\r\n    export function clearImmediate(immediateId: any): void;\r\n}\r\n\r\ndeclare module \"console\" {\r\n    export = console;\r\n}\r\n\r\n/**\r\n * Async Hooks module: https://nodejs.org/api/async_hooks.html\r\n */\r\ndeclare module \"async_hooks\" {\r\n    /**\r\n     * Returns the asyncId of the current execution context.\r\n     */\r\n    export function executionAsyncId(): number;\r\n    /// @deprecated - replaced by executionAsyncId()\r\n    export function currentId(): number;\r\n\r\n    /**\r\n     * Returns the ID of the resource responsible for calling the callback that is currently being executed.\r\n     */\r\n    export function triggerAsyncId(): number;\r\n    /// @deprecated - replaced by triggerAsyncId()\r\n    export function triggerId(): number;\r\n\r\n    export interface HookCallbacks {\r\n        /**\r\n         * Called when a class is constructed that has the possibility to emit an asynchronous event.\r\n         * @param asyncId a unique ID for the async resource\r\n         * @param type the type of the async resource\r\n         * @param triggerAsyncId the unique ID of the async resource in whose execution context this async resource was created\r\n         * @param resource reference to the resource representing the async operation, needs to be released during destroy\r\n         */\r\n        init?(asyncId: number, type: string, triggerAsyncId: number, resource: Object): void;\r\n\r\n        /**\r\n         * When an asynchronous operation is initiated or completes a callback is called to notify the user.\r\n         * The before callback is called just before said callback is executed.\r\n         * @param asyncId the unique identifier assigned to the resource about to execute the callback.\r\n         */\r\n        before?(asyncId: number): void;\r\n\r\n        /**\r\n         * Called immediately after the callback specified in before is completed.\r\n         * @param asyncId the unique identifier assigned to the resource which has executed the callback.\r\n         */\r\n        after?(asyncId: number): void;\r\n\r\n        /**\r\n         * Called when a promise has resolve() called. This may not be in the same execution id\r\n         * as the promise itself.\r\n         * @param asyncId the unique id for the promise that was resolve()d.\r\n         */\r\n        promiseResolve?(asyncId: number): void;\r\n\r\n        /**\r\n         * Called after the resource corresponding to asyncId is destroyed\r\n         * @param asyncId a unique ID for the async resource\r\n         */\r\n        destroy?(asyncId: number): void;\r\n    }\r\n\r\n    export interface AsyncHook {\r\n        /**\r\n         * Enable the callbacks for a given AsyncHook instance. If no callbacks are provided enabling is a noop.\r\n         */\r\n        enable(): this;\r\n\r\n        /**\r\n         * Disable the callbacks for a given AsyncHook instance from the global pool of AsyncHook callbacks to be executed. Once a hook has been disabled it will not be called again until enabled.\r\n         */\r\n        disable(): this;\r\n    }\r\n\r\n    /**\r\n     * Registers functions to be called for different lifetime events of each async operation.\r\n     * @param options the callbacks to register\r\n     * @return an AsyncHooks instance used for disabling and enabling hooks\r\n     */\r\n    export function createHook(options: HookCallbacks): AsyncHook;\r\n\r\n    /**\r\n     * The class AsyncResource was designed to be extended by the embedder's async resources.\r\n     * Using this users can easily trigger the lifetime events of their own resources.\r\n     */\r\n    export class AsyncResource {\r\n        /**\r\n         * AsyncResource() is meant to be extended. Instantiating a\r\n         * new AsyncResource() also triggers init. If triggerAsyncId is omitted then\r\n         * async_hook.executionAsyncId() is used.\r\n         * @param type the name of this async resource type\r\n         * @param triggerAsyncId the unique ID of the async resource in whose execution context this async resource was created\r\n         */\r\n        constructor(type: string, triggerAsyncId?: number)\r\n\r\n        /**\r\n         * Call AsyncHooks before callbacks.\r\n         */\r\n        emitBefore(): void;\r\n\r\n        /**\r\n         * Call AsyncHooks after callbacks\r\n         */\r\n        emitAfter(): void;\r\n\r\n        /**\r\n         * Call AsyncHooks destroy callbacks.\r\n         */\r\n        emitDestroy(): void;\r\n\r\n        /**\r\n         * @return the unique ID assigned to this AsyncResource instance.\r\n         */\r\n        asyncId(): number;\r\n\r\n        /**\r\n         * @return the trigger ID for this AsyncResource instance.\r\n         */\r\n        triggerAsyncId(): number;\r\n    }\r\n}\r\n\r\ndeclare module \"http2\" {\r\n    import * as events from \"events\";\r\n    import * as fs from \"fs\";\r\n    import * as net from \"net\";\r\n    import * as stream from \"stream\";\r\n    import * as tls from \"tls\";\r\n    import * as url from \"url\";\r\n\r\n    import { IncomingHttpHeaders, OutgoingHttpHeaders } from \"http\";\r\n    export { IncomingHttpHeaders, OutgoingHttpHeaders } from \"http\";\r\n\r\n    // Http2Stream\r\n\r\n    export interface StreamPriorityOptions {\r\n        exclusive?: boolean;\r\n        parent?: number;\r\n        weight?: number;\r\n        silent?: boolean;\r\n    }\r\n\r\n    export interface StreamState {\r\n        localWindowSize?: number;\r\n        state?: number;\r\n        streamLocalClose?: number;\r\n        streamRemoteClose?: number;\r\n        sumDependencyWeight?: number;\r\n        weight?: number;\r\n    }\r\n\r\n    export interface ServerStreamResponseOptions {\r\n        endStream?: boolean;\r\n        getTrailers?: (trailers: OutgoingHttpHeaders) => void;\r\n    }\r\n\r\n    export interface StatOptions {\r\n        offset: number;\r\n        length: number;\r\n    }\r\n\r\n    export interface ServerStreamFileResponseOptions {\r\n        statCheck?: (stats: fs.Stats, headers: OutgoingHttpHeaders, statOptions: StatOptions) => void|boolean;\r\n        getTrailers?: (trailers: OutgoingHttpHeaders) => void;\r\n        offset?: number;\r\n        length?: number;\r\n    }\r\n\r\n    export interface ServerStreamFileResponseOptionsWithError extends ServerStreamFileResponseOptions {\r\n        onError?: (err: NodeJS.ErrnoException) => void;\r\n    }\r\n\r\n    export interface Http2Stream extends stream.Duplex {\r\n        readonly aborted: boolean;\r\n        readonly destroyed: boolean;\r\n        priority(options: StreamPriorityOptions): void;\r\n        readonly rstCode: number;\r\n        rstStream(code: number): void;\r\n        rstWithNoError(): void;\r\n        rstWithProtocolError(): void;\r\n        rstWithCancel(): void;\r\n        rstWithRefuse(): void;\r\n        rstWithInternalError(): void;\r\n        readonly session: Http2Session;\r\n        setTimeout(msecs: number, callback?: () => void): void;\r\n        readonly state: StreamState;\r\n\r\n        addListener(event: string, listener: (...args: any[]) => void): this;\r\n        addListener(event: \"aborted\", listener: () => void): this;\r\n        addListener(event: \"close\", listener: () => void): this;\r\n        addListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\r\n        addListener(event: \"drain\", listener: () => void): this;\r\n        addListener(event: \"end\", listener: () => void): this;\r\n        addListener(event: \"error\", listener: (err: Error) => void): this;\r\n        addListener(event: \"finish\", listener: () => void): this;\r\n        addListener(event: \"frameError\", listener: (frameType: number, errorCode: number) => void): this;\r\n        addListener(event: \"pipe\", listener: (src: stream.Readable) => void): this;\r\n        addListener(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\r\n        addListener(event: \"streamClosed\", listener: (code: number) => void): this;\r\n        addListener(event: \"timeout\", listener: () => void): this;\r\n        addListener(event: \"trailers\", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;\r\n\r\n        emit(event: string | symbol, ...args: any[]): boolean;\r\n        emit(event: \"aborted\"): boolean;\r\n        emit(event: \"close\"): boolean;\r\n        emit(event: \"data\", chunk: Buffer | string): boolean;\r\n        emit(event: \"drain\"): boolean;\r\n        emit(event: \"end\"): boolean;\r\n        emit(event: \"error\", err: Error): boolean;\r\n        emit(event: \"finish\"): boolean;\r\n        emit(event: \"frameError\", frameType: number, errorCode: number): boolean;\r\n        emit(event: \"pipe\", src: stream.Readable): boolean;\r\n        emit(event: \"unpipe\", src: stream.Readable): boolean;\r\n        emit(event: \"streamClosed\", code: number): boolean;\r\n        emit(event: \"timeout\"): boolean;\r\n        emit(event: \"trailers\", trailers: IncomingHttpHeaders, flags: number): boolean;\r\n\r\n        on(event: string, listener: (...args: any[]) => void): this;\r\n        on(event: \"aborted\", listener: () => void): this;\r\n        on(event: \"close\", listener: () => void): this;\r\n        on(event: \"data\", listener: (chunk: Buffer | string) => void): this;\r\n        on(event: \"drain\", listener: () => void): this;\r\n        on(event: \"end\", listener: () => void): this;\r\n        on(event: \"error\", listener: (err: Error) => void): this;\r\n        on(event: \"finish\", listener: () => void): this;\r\n        on(event: \"frameError\", listener: (frameType: number, errorCode: number) => void): this;\r\n        on(event: \"pipe\", listener: (src: stream.Readable) => void): this;\r\n        on(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\r\n        on(event: \"streamClosed\", listener: (code: number) => void): this;\r\n        on(event: \"timeout\", listener: () => void): this;\r\n        on(event: \"trailers\", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;\r\n\r\n        once(event: string, listener: (...args: any[]) => void): this;\r\n        once(event: \"aborted\", listener: () => void): this;\r\n        once(event: \"close\", listener: () => void): this;\r\n        once(event: \"data\", listener: (chunk: Buffer | string) => void): this;\r\n        once(event: \"drain\", listener: () => void): this;\r\n        once(event: \"end\", listener: () => void): this;\r\n        once(event: \"error\", listener: (err: Error) => void): this;\r\n        once(event: \"finish\", listener: () => void): this;\r\n        once(event: \"frameError\", listener: (frameType: number, errorCode: number) => void): this;\r\n        once(event: \"pipe\", listener: (src: stream.Readable) => void): this;\r\n        once(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\r\n        once(event: \"streamClosed\", listener: (code: number) => void): this;\r\n        once(event: \"timeout\", listener: () => void): this;\r\n        once(event: \"trailers\", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;\r\n\r\n        prependListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependListener(event: \"aborted\", listener: () => void): this;\r\n        prependListener(event: \"close\", listener: () => void): this;\r\n        prependListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\r\n        prependListener(event: \"drain\", listener: () => void): this;\r\n        prependListener(event: \"end\", listener: () => void): this;\r\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\r\n        prependListener(event: \"finish\", listener: () => void): this;\r\n        prependListener(event: \"frameError\", listener: (frameType: number, errorCode: number) => void): this;\r\n        prependListener(event: \"pipe\", listener: (src: stream.Readable) => void): this;\r\n        prependListener(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\r\n        prependListener(event: \"streamClosed\", listener: (code: number) => void): this;\r\n        prependListener(event: \"timeout\", listener: () => void): this;\r\n        prependListener(event: \"trailers\", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;\r\n\r\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependOnceListener(event: \"aborted\", listener: () => void): this;\r\n        prependOnceListener(event: \"close\", listener: () => void): this;\r\n        prependOnceListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\r\n        prependOnceListener(event: \"drain\", listener: () => void): this;\r\n        prependOnceListener(event: \"end\", listener: () => void): this;\r\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\r\n        prependOnceListener(event: \"finish\", listener: () => void): this;\r\n        prependOnceListener(event: \"frameError\", listener: (frameType: number, errorCode: number) => void): this;\r\n        prependOnceListener(event: \"pipe\", listener: (src: stream.Readable) => void): this;\r\n        prependOnceListener(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\r\n        prependOnceListener(event: \"streamClosed\", listener: (code: number) => void): this;\r\n        prependOnceListener(event: \"timeout\", listener: () => void): this;\r\n        prependOnceListener(event: \"trailers\", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;\r\n    }\r\n\r\n    export interface ClientHttp2Stream extends Http2Stream {\r\n        addListener(event: string, listener: (...args: any[]) => void): this;\r\n        addListener(event: \"headers\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\r\n        addListener(event: \"push\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\r\n        addListener(event: \"response\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\r\n\r\n        emit(event: string | symbol, ...args: any[]): boolean;\r\n        emit(event: \"headers\", headers: IncomingHttpHeaders, flags: number): boolean;\r\n        emit(event: \"push\", headers: IncomingHttpHeaders, flags: number): boolean;\r\n        emit(event: \"response\", headers: IncomingHttpHeaders, flags: number): boolean;\r\n\r\n        on(event: string, listener: (...args: any[]) => void): this;\r\n        on(event: \"headers\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\r\n        on(event: \"push\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\r\n        on(event: \"response\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\r\n\r\n        once(event: string, listener: (...args: any[]) => void): this;\r\n        once(event: \"headers\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\r\n        once(event: \"push\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\r\n        once(event: \"response\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\r\n\r\n        prependListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependListener(event: \"headers\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\r\n        prependListener(event: \"push\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\r\n        prependListener(event: \"response\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\r\n\r\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependOnceListener(event: \"headers\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\r\n        prependOnceListener(event: \"push\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\r\n        prependOnceListener(event: \"response\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\r\n    }\r\n\r\n    export interface ServerHttp2Stream extends Http2Stream {\r\n        additionalHeaders(headers: OutgoingHttpHeaders): void;\r\n        readonly headersSent: boolean;\r\n        readonly pushAllowed: boolean;\r\n        pushStream(headers: OutgoingHttpHeaders, callback?: (pushStream: ServerHttp2Stream) => void): void;\r\n        pushStream(headers: OutgoingHttpHeaders, options?: StreamPriorityOptions, callback?: (pushStream: ServerHttp2Stream) => void): void;\r\n        respond(headers?: OutgoingHttpHeaders, options?: ServerStreamResponseOptions): void;\r\n        respondWithFD(fd: number, headers?: OutgoingHttpHeaders, options?: ServerStreamFileResponseOptions): void;\r\n        respondWithFile(path: string, headers?: OutgoingHttpHeaders, options?: ServerStreamFileResponseOptionsWithError): void;\r\n    }\r\n\r\n    // Http2Session\r\n\r\n    export interface Settings {\r\n        headerTableSize?: number;\r\n        enablePush?: boolean;\r\n        initialWindowSize?: number;\r\n        maxFrameSize?: number;\r\n        maxConcurrentStreams?: number;\r\n        maxHeaderListSize?: number;\r\n    }\r\n\r\n    export interface ClientSessionRequestOptions {\r\n        endStream?: boolean;\r\n        exclusive?: boolean;\r\n        parent?: number;\r\n        weight?: number;\r\n        getTrailers?: (trailers: OutgoingHttpHeaders, flags: number) => void;\r\n    }\r\n\r\n    export interface SessionShutdownOptions {\r\n        graceful?: boolean;\r\n        errorCode?: number;\r\n        lastStreamID?: number;\r\n        opaqueData?: Buffer | Uint8Array;\r\n    }\r\n\r\n    export interface SessionState {\r\n        effectiveLocalWindowSize?: number;\r\n        effectiveRecvDataLength?: number;\r\n        nextStreamID?: number;\r\n        localWindowSize?: number;\r\n        lastProcStreamID?: number;\r\n        remoteWindowSize?: number;\r\n        outboundQueueSize?: number;\r\n        deflateDynamicTableSize?: number;\r\n        inflateDynamicTableSize?: number;\r\n    }\r\n\r\n    export interface Http2Session extends events.EventEmitter {\r\n        destroy(): void;\r\n        readonly destroyed: boolean;\r\n        readonly localSettings: Settings;\r\n        readonly pendingSettingsAck: boolean;\r\n        readonly remoteSettings: Settings;\r\n        rstStream(stream: Http2Stream, code?: number): void;\r\n        setTimeout(msecs: number, callback?: () => void): void;\r\n        shutdown(callback?: () => void): void;\r\n        shutdown(options: SessionShutdownOptions, callback?: () => void): void;\r\n        readonly socket: net.Socket | tls.TLSSocket;\r\n        readonly state: SessionState;\r\n        priority(stream: Http2Stream, options: StreamPriorityOptions): void;\r\n        settings(settings: Settings): void;\r\n        readonly type: number;\r\n\r\n        addListener(event: string, listener: (...args: any[]) => void): this;\r\n        addListener(event: \"close\", listener: () => void): this;\r\n        addListener(event: \"error\", listener: (err: Error) => void): this;\r\n        addListener(event: \"frameError\", listener: (frameType: number, errorCode: number, streamID: number) => void): this;\r\n        addListener(event: \"goaway\", listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;\r\n        addListener(event: \"localSettings\", listener: (settings: Settings) => void): this;\r\n        addListener(event: \"remoteSettings\", listener: (settings: Settings) => void): this;\r\n        addListener(event: \"socketError\", listener: (err: Error) => void): this;\r\n        addListener(event: \"timeout\", listener: () => void): this;\r\n\r\n        emit(event: string | symbol, ...args: any[]): boolean;\r\n        emit(event: \"close\"): boolean;\r\n        emit(event: \"error\", err: Error): boolean;\r\n        emit(event: \"frameError\", frameType: number, errorCode: number, streamID: number): boolean;\r\n        emit(event: \"goaway\", errorCode: number, lastStreamID: number, opaqueData: Buffer): boolean;\r\n        emit(event: \"localSettings\", settings: Settings): boolean;\r\n        emit(event: \"remoteSettings\", settings: Settings): boolean;\r\n        emit(event: \"socketError\", err: Error): boolean;\r\n        emit(event: \"timeout\"): boolean;\r\n\r\n        on(event: string, listener: (...args: any[]) => void): this;\r\n        on(event: \"close\", listener: () => void): this;\r\n        on(event: \"error\", listener: (err: Error) => void): this;\r\n        on(event: \"frameError\", listener: (frameType: number, errorCode: number, streamID: number) => void): this;\r\n        on(event: \"goaway\", listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;\r\n        on(event: \"localSettings\", listener: (settings: Settings) => void): this;\r\n        on(event: \"remoteSettings\", listener: (settings: Settings) => void): this;\r\n        on(event: \"socketError\", listener: (err: Error) => void): this;\r\n        on(event: \"timeout\", listener: () => void): this;\r\n\r\n        once(event: string, listener: (...args: any[]) => void): this;\r\n        once(event: \"close\", listener: () => void): this;\r\n        once(event: \"error\", listener: (err: Error) => void): this;\r\n        once(event: \"frameError\", listener: (frameType: number, errorCode: number, streamID: number) => void): this;\r\n        once(event: \"goaway\", listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;\r\n        once(event: \"localSettings\", listener: (settings: Settings) => void): this;\r\n        once(event: \"remoteSettings\", listener: (settings: Settings) => void): this;\r\n        once(event: \"socketError\", listener: (err: Error) => void): this;\r\n        once(event: \"timeout\", listener: () => void): this;\r\n\r\n        prependListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependListener(event: \"close\", listener: () => void): this;\r\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\r\n        prependListener(event: \"frameError\", listener: (frameType: number, errorCode: number, streamID: number) => void): this;\r\n        prependListener(event: \"goaway\", listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;\r\n        prependListener(event: \"localSettings\", listener: (settings: Settings) => void): this;\r\n        prependListener(event: \"remoteSettings\", listener: (settings: Settings) => void): this;\r\n        prependListener(event: \"socketError\", listener: (err: Error) => void): this;\r\n        prependListener(event: \"timeout\", listener: () => void): this;\r\n\r\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependOnceListener(event: \"close\", listener: () => void): this;\r\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\r\n        prependOnceListener(event: \"frameError\", listener: (frameType: number, errorCode: number, streamID: number) => void): this;\r\n        prependOnceListener(event: \"goaway\", listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;\r\n        prependOnceListener(event: \"localSettings\", listener: (settings: Settings) => void): this;\r\n        prependOnceListener(event: \"remoteSettings\", listener: (settings: Settings) => void): this;\r\n        prependOnceListener(event: \"socketError\", listener: (err: Error) => void): this;\r\n        prependOnceListener(event: \"timeout\", listener: () => void): this;\r\n    }\r\n\r\n    export interface ClientHttp2Session extends Http2Session {\r\n        request(headers?: OutgoingHttpHeaders, options?: ClientSessionRequestOptions): ClientHttp2Stream;\r\n\r\n        addListener(event: string, listener: (...args: any[]) => void): this;\r\n        addListener(event: \"connect\", listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\r\n        addListener(event: \"stream\", listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\r\n\r\n        emit(event: string | symbol, ...args: any[]): boolean;\r\n        emit(event: \"connect\", session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket): boolean;\r\n        emit(event: \"stream\", stream: ClientHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;\r\n\r\n        on(event: string, listener: (...args: any[]) => void): this;\r\n        on(event: \"connect\", listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\r\n        on(event: \"stream\", listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\r\n\r\n        once(event: string, listener: (...args: any[]) => void): this;\r\n        once(event: \"connect\", listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\r\n        once(event: \"stream\", listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\r\n\r\n        prependListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependListener(event: \"connect\", listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\r\n        prependListener(event: \"stream\", listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\r\n\r\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependOnceListener(event: \"connect\", listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\r\n        prependOnceListener(event: \"stream\", listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\r\n    }\r\n\r\n    export interface ServerHttp2Session extends Http2Session {\r\n        readonly server: Http2Server | Http2SecureServer;\r\n\r\n        addListener(event: string, listener: (...args: any[]) => void): this;\r\n        addListener(event: \"connect\", listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\r\n        addListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\r\n\r\n        emit(event: string | symbol, ...args: any[]): boolean;\r\n        emit(event: \"connect\", session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket): boolean;\r\n        emit(event: \"stream\", stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;\r\n\r\n        on(event: string, listener: (...args: any[]) => void): this;\r\n        on(event: \"connect\", listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\r\n        on(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\r\n\r\n        once(event: string, listener: (...args: any[]) => void): this;\r\n        once(event: \"connect\", listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\r\n        once(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\r\n\r\n        prependListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependListener(event: \"connect\", listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\r\n        prependListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\r\n\r\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependOnceListener(event: \"connect\", listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\r\n        prependOnceListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\r\n    }\r\n\r\n    // Http2Server\r\n\r\n    export interface SessionOptions {\r\n        maxDeflateDynamicTableSize?: number;\r\n        maxReservedRemoteStreams?: number;\r\n        maxSendHeaderBlockLength?: number;\r\n        paddingStrategy?: number;\r\n        peerMaxConcurrentStreams?: number;\r\n        selectPadding?: (frameLen: number, maxFrameLen: number) => number;\r\n        settings?: Settings;\r\n    }\r\n\r\n    export type ClientSessionOptions = SessionOptions;\r\n    export type ServerSessionOptions = SessionOptions;\r\n\r\n    export interface SecureClientSessionOptions extends ClientSessionOptions, tls.ConnectionOptions { }\r\n    export interface SecureServerSessionOptions extends ServerSessionOptions, tls.TlsOptions { }\r\n\r\n    export interface ServerOptions extends ServerSessionOptions {\r\n        allowHTTP1?: boolean;\r\n    }\r\n\r\n    export interface SecureServerOptions extends SecureServerSessionOptions {\r\n        allowHTTP1?: boolean;\r\n    }\r\n\r\n    export interface Http2Server extends net.Server {\r\n        addListener(event: string, listener: (...args: any[]) => void): this;\r\n        addListener(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\r\n        addListener(event: \"sessionError\", listener: (err: Error) => void): this;\r\n        addListener(event: \"socketError\", listener: (err: Error) => void): this;\r\n        addListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\r\n        addListener(event: \"timeout\", listener: () => void): this;\r\n\r\n        emit(event: string | symbol, ...args: any[]): boolean;\r\n        emit(event: \"request\", request: Http2ServerRequest, response: Http2ServerResponse): boolean;\r\n        emit(event: \"sessionError\", err: Error): boolean;\r\n        emit(event: \"socketError\", err: Error): boolean;\r\n        emit(event: \"stream\", stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;\r\n        emit(event: \"timeout\"): boolean;\r\n\r\n        on(event: string, listener: (...args: any[]) => void): this;\r\n        on(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\r\n        on(event: \"sessionError\", listener: (err: Error) => void): this;\r\n        on(event: \"socketError\", listener: (err: Error) => void): this;\r\n        on(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\r\n        on(event: \"timeout\", listener: () => void): this;\r\n\r\n        once(event: string, listener: (...args: any[]) => void): this;\r\n        once(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\r\n        once(event: \"sessionError\", listener: (err: Error) => void): this;\r\n        once(event: \"socketError\", listener: (err: Error) => void): this;\r\n        once(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\r\n        once(event: \"timeout\", listener: () => void): this;\r\n\r\n        prependListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependListener(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\r\n        prependListener(event: \"sessionError\", listener: (err: Error) => void): this;\r\n        prependListener(event: \"socketError\", listener: (err: Error) => void): this;\r\n        prependListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\r\n        prependListener(event: \"timeout\", listener: () => void): this;\r\n\r\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependOnceListener(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\r\n        prependOnceListener(event: \"sessionError\", listener: (err: Error) => void): this;\r\n        prependOnceListener(event: \"socketError\", listener: (err: Error) => void): this;\r\n        prependOnceListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\r\n        prependOnceListener(event: \"timeout\", listener: () => void): this;\r\n    }\r\n\r\n    export interface Http2SecureServer extends tls.Server {\r\n        addListener(event: string, listener: (...args: any[]) => void): this;\r\n        addListener(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\r\n        addListener(event: \"sessionError\", listener: (err: Error) => void): this;\r\n        addListener(event: \"socketError\", listener: (err: Error) => void): this;\r\n        addListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\r\n        addListener(event: \"timeout\", listener: () => void): this;\r\n        addListener(event: \"unknownProtocol\", listener: (socket: tls.TLSSocket) => void): this;\r\n\r\n        emit(event: string | symbol, ...args: any[]): boolean;\r\n        emit(event: \"request\", request: Http2ServerRequest, response: Http2ServerResponse): boolean;\r\n        emit(event: \"sessionError\", err: Error): boolean;\r\n        emit(event: \"socketError\", err: Error): boolean;\r\n        emit(event: \"stream\", stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;\r\n        emit(event: \"timeout\"): boolean;\r\n        emit(event: \"unknownProtocol\", socket: tls.TLSSocket): boolean;\r\n\r\n        on(event: string, listener: (...args: any[]) => void): this;\r\n        on(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\r\n        on(event: \"sessionError\", listener: (err: Error) => void): this;\r\n        on(event: \"socketError\", listener: (err: Error) => void): this;\r\n        on(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\r\n        on(event: \"timeout\", listener: () => void): this;\r\n        on(event: \"unknownProtocol\", listener: (socket: tls.TLSSocket) => void): this;\r\n\r\n        once(event: string, listener: (...args: any[]) => void): this;\r\n        once(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\r\n        once(event: \"sessionError\", listener: (err: Error) => void): this;\r\n        once(event: \"socketError\", listener: (err: Error) => void): this;\r\n        once(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\r\n        once(event: \"timeout\", listener: () => void): this;\r\n        once(event: \"unknownProtocol\", listener: (socket: tls.TLSSocket) => void): this;\r\n\r\n        prependListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependListener(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\r\n        prependListener(event: \"sessionError\", listener: (err: Error) => void): this;\r\n        prependListener(event: \"socketError\", listener: (err: Error) => void): this;\r\n        prependListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\r\n        prependListener(event: \"timeout\", listener: () => void): this;\r\n        prependListener(event: \"unknownProtocol\", listener: (socket: tls.TLSSocket) => void): this;\r\n\r\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependOnceListener(event: \"request\", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\r\n        prependOnceListener(event: \"sessionError\", listener: (err: Error) => void): this;\r\n        prependOnceListener(event: \"socketError\", listener: (err: Error) => void): this;\r\n        prependOnceListener(event: \"stream\", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\r\n        prependOnceListener(event: \"timeout\", listener: () => void): this;\r\n        prependOnceListener(event: \"unknownProtocol\", listener: (socket: tls.TLSSocket) => void): this;\r\n    }\r\n\r\n    export interface Http2ServerRequest extends stream.Readable {\r\n        headers: IncomingHttpHeaders;\r\n        httpVersion: string;\r\n        method: string;\r\n        rawHeaders: string[];\r\n        rawTrailers: string[];\r\n        setTimeout(msecs: number, callback?: () => void): void;\r\n        socket: net.Socket | tls.TLSSocket;\r\n        stream: ServerHttp2Stream;\r\n        trailers: IncomingHttpHeaders;\r\n        url: string;\r\n\r\n        addListener(event: string, listener: (...args: any[]) => void): this;\r\n        addListener(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\r\n\r\n        emit(event: string | symbol, ...args: any[]): boolean;\r\n        emit(event: \"aborted\", hadError: boolean, code: number): boolean;\r\n\r\n        on(event: string, listener: (...args: any[]) => void): this;\r\n        on(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\r\n\r\n        once(event: string, listener: (...args: any[]) => void): this;\r\n        once(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\r\n\r\n        prependListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependListener(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\r\n\r\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependOnceListener(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\r\n    }\r\n\r\n    export interface Http2ServerResponse extends events.EventEmitter {\r\n        addTrailers(trailers: OutgoingHttpHeaders): void;\r\n        connection: net.Socket | tls.TLSSocket;\r\n        end(callback?: () => void): void;\r\n        end(data?: string | Buffer, callback?: () => void): void;\r\n        end(data?: string | Buffer, encoding?: string, callback?: () => void): void;\r\n        readonly finished: boolean;\r\n        getHeader(name: string): string;\r\n        getHeaderNames(): string[];\r\n        getHeaders(): OutgoingHttpHeaders;\r\n        hasHeader(name: string): boolean;\r\n        readonly headersSent: boolean;\r\n        removeHeader(name: string): void;\r\n        sendDate: boolean;\r\n        setHeader(name: string, value: number | string | string[]): void;\r\n        setTimeout(msecs: number, callback?: () => void): void;\r\n        socket: net.Socket | tls.TLSSocket;\r\n        statusCode: number;\r\n        statusMessage: '';\r\n        stream: ServerHttp2Stream;\r\n        write(chunk: string | Buffer, callback?: (err: Error) => void): boolean;\r\n        write(chunk: string | Buffer, encoding?: string, callback?: (err: Error) => void): boolean;\r\n        writeContinue(): void;\r\n        writeHead(statusCode: number, headers?: OutgoingHttpHeaders): void;\r\n        writeHead(statusCode: number, statusMessage?: string, headers?: OutgoingHttpHeaders): void;\r\n        createPushResponse(headers: OutgoingHttpHeaders, callback: (err: Error | null, res: Http2ServerResponse) => void): void;\r\n\r\n        addListener(event: string, listener: (...args: any[]) => void): this;\r\n        addListener(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\r\n        addListener(event: \"close\", listener: () => void): this;\r\n        addListener(event: \"drain\", listener: () => void): this;\r\n        addListener(event: \"error\", listener: (error: Error) => void): this;\r\n        addListener(event: \"finish\", listener: () => void): this;\r\n\r\n        emit(event: string | symbol, ...args: any[]): boolean;\r\n        emit(event: \"aborted\", hadError: boolean, code: number): boolean;\r\n        emit(event: \"close\"): boolean;\r\n        emit(event: \"drain\"): boolean;\r\n        emit(event: \"error\", error: Error): boolean;\r\n        emit(event: \"finish\"): boolean;\r\n\r\n        on(event: string, listener: (...args: any[]) => void): this;\r\n        on(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\r\n        on(event: \"close\", listener: () => void): this;\r\n        on(event: \"drain\", listener: () => void): this;\r\n        on(event: \"error\", listener: (error: Error) => void): this;\r\n        on(event: \"finish\", listener: () => void): this;\r\n\r\n        once(event: string, listener: (...args: any[]) => void): this;\r\n        once(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\r\n        once(event: \"close\", listener: () => void): this;\r\n        once(event: \"drain\", listener: () => void): this;\r\n        once(event: \"error\", listener: (error: Error) => void): this;\r\n        once(event: \"finish\", listener: () => void): this;\r\n\r\n        prependListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependListener(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\r\n        prependListener(event: \"close\", listener: () => void): this;\r\n        prependListener(event: \"drain\", listener: () => void): this;\r\n        prependListener(event: \"error\", listener: (error: Error) => void): this;\r\n        prependListener(event: \"finish\", listener: () => void): this;\r\n\r\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\r\n        prependOnceListener(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\r\n        prependOnceListener(event: \"close\", listener: () => void): this;\r\n        prependOnceListener(event: \"drain\", listener: () => void): this;\r\n        prependOnceListener(event: \"error\", listener: (error: Error) => void): this;\r\n        prependOnceListener(event: \"finish\", listener: () => void): this;\r\n    }\r\n\r\n    // Public API\r\n\r\n    export namespace constants {\r\n        export const NGHTTP2_SESSION_SERVER: number;\r\n        export const NGHTTP2_SESSION_CLIENT: number;\r\n        export const NGHTTP2_STREAM_STATE_IDLE: number;\r\n        export const NGHTTP2_STREAM_STATE_OPEN: number;\r\n        export const NGHTTP2_STREAM_STATE_RESERVED_LOCAL: number;\r\n        export const NGHTTP2_STREAM_STATE_RESERVED_REMOTE: number;\r\n        export const NGHTTP2_STREAM_STATE_HALF_CLOSED_LOCAL: number;\r\n        export const NGHTTP2_STREAM_STATE_HALF_CLOSED_REMOTE: number;\r\n        export const NGHTTP2_STREAM_STATE_CLOSED: number;\r\n        export const NGHTTP2_NO_ERROR: number;\r\n        export const NGHTTP2_PROTOCOL_ERROR: number;\r\n        export const NGHTTP2_INTERNAL_ERROR: number;\r\n        export const NGHTTP2_FLOW_CONTROL_ERROR: number;\r\n        export const NGHTTP2_SETTINGS_TIMEOUT: number;\r\n        export const NGHTTP2_STREAM_CLOSED: number;\r\n        export const NGHTTP2_FRAME_SIZE_ERROR: number;\r\n        export const NGHTTP2_REFUSED_STREAM: number;\r\n        export const NGHTTP2_CANCEL: number;\r\n        export const NGHTTP2_COMPRESSION_ERROR: number;\r\n        export const NGHTTP2_CONNECT_ERROR: number;\r\n        export const NGHTTP2_ENHANCE_YOUR_CALM: number;\r\n        export const NGHTTP2_INADEQUATE_SECURITY: number;\r\n        export const NGHTTP2_HTTP_1_1_REQUIRED: number;\r\n        export const NGHTTP2_ERR_FRAME_SIZE_ERROR: number;\r\n        export const NGHTTP2_FLAG_NONE: number;\r\n        export const NGHTTP2_FLAG_END_STREAM: number;\r\n        export const NGHTTP2_FLAG_END_HEADERS: number;\r\n        export const NGHTTP2_FLAG_ACK: number;\r\n        export const NGHTTP2_FLAG_PADDED: number;\r\n        export const NGHTTP2_FLAG_PRIORITY: number;\r\n        export const DEFAULT_SETTINGS_HEADER_TABLE_SIZE: number;\r\n        export const DEFAULT_SETTINGS_ENABLE_PUSH: number;\r\n        export const DEFAULT_SETTINGS_INITIAL_WINDOW_SIZE: number;\r\n        export const DEFAULT_SETTINGS_MAX_FRAME_SIZE: number;\r\n        export const MAX_MAX_FRAME_SIZE: number;\r\n        export const MIN_MAX_FRAME_SIZE: number;\r\n        export const MAX_INITIAL_WINDOW_SIZE: number;\r\n        export const NGHTTP2_DEFAULT_WEIGHT: number;\r\n        export const NGHTTP2_SETTINGS_HEADER_TABLE_SIZE: number;\r\n        export const NGHTTP2_SETTINGS_ENABLE_PUSH: number;\r\n        export const NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS: number;\r\n        export const NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE: number;\r\n        export const NGHTTP2_SETTINGS_MAX_FRAME_SIZE: number;\r\n        export const NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE: number;\r\n        export const PADDING_STRATEGY_NONE: number;\r\n        export const PADDING_STRATEGY_MAX: number;\r\n        export const PADDING_STRATEGY_CALLBACK: number;\r\n        export const HTTP2_HEADER_STATUS: string;\r\n        export const HTTP2_HEADER_METHOD: string;\r\n        export const HTTP2_HEADER_AUTHORITY: string;\r\n        export const HTTP2_HEADER_SCHEME: string;\r\n        export const HTTP2_HEADER_PATH: string;\r\n        export const HTTP2_HEADER_ACCEPT_CHARSET: string;\r\n        export const HTTP2_HEADER_ACCEPT_ENCODING: string;\r\n        export const HTTP2_HEADER_ACCEPT_LANGUAGE: string;\r\n        export const HTTP2_HEADER_ACCEPT_RANGES: string;\r\n        export const HTTP2_HEADER_ACCEPT: string;\r\n        export const HTTP2_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN: string;\r\n        export const HTTP2_HEADER_AGE: string;\r\n        export const HTTP2_HEADER_ALLOW: string;\r\n        export const HTTP2_HEADER_AUTHORIZATION: string;\r\n        export const HTTP2_HEADER_CACHE_CONTROL: string;\r\n        export const HTTP2_HEADER_CONNECTION: string;\r\n        export const HTTP2_HEADER_CONTENT_DISPOSITION: string;\r\n        export const HTTP2_HEADER_CONTENT_ENCODING: string;\r\n        export const HTTP2_HEADER_CONTENT_LANGUAGE: string;\r\n        export const HTTP2_HEADER_CONTENT_LENGTH: string;\r\n        export const HTTP2_HEADER_CONTENT_LOCATION: string;\r\n        export const HTTP2_HEADER_CONTENT_MD5: string;\r\n        export const HTTP2_HEADER_CONTENT_RANGE: string;\r\n        export const HTTP2_HEADER_CONTENT_TYPE: string;\r\n        export const HTTP2_HEADER_COOKIE: string;\r\n        export const HTTP2_HEADER_DATE: string;\r\n        export const HTTP2_HEADER_ETAG: string;\r\n        export const HTTP2_HEADER_EXPECT: string;\r\n        export const HTTP2_HEADER_EXPIRES: string;\r\n        export const HTTP2_HEADER_FROM: string;\r\n        export const HTTP2_HEADER_HOST: string;\r\n        export const HTTP2_HEADER_IF_MATCH: string;\r\n        export const HTTP2_HEADER_IF_MODIFIED_SINCE: string;\r\n        export const HTTP2_HEADER_IF_NONE_MATCH: string;\r\n        export const HTTP2_HEADER_IF_RANGE: string;\r\n        export const HTTP2_HEADER_IF_UNMODIFIED_SINCE: string;\r\n        export const HTTP2_HEADER_LAST_MODIFIED: string;\r\n        export const HTTP2_HEADER_LINK: string;\r\n        export const HTTP2_HEADER_LOCATION: string;\r\n        export const HTTP2_HEADER_MAX_FORWARDS: string;\r\n        export const HTTP2_HEADER_PREFER: string;\r\n        export const HTTP2_HEADER_PROXY_AUTHENTICATE: string;\r\n        export const HTTP2_HEADER_PROXY_AUTHORIZATION: string;\r\n        export const HTTP2_HEADER_RANGE: string;\r\n        export const HTTP2_HEADER_REFERER: string;\r\n        export const HTTP2_HEADER_REFRESH: string;\r\n        export const HTTP2_HEADER_RETRY_AFTER: string;\r\n        export const HTTP2_HEADER_SERVER: string;\r\n        export const HTTP2_HEADER_SET_COOKIE: string;\r\n        export const HTTP2_HEADER_STRICT_TRANSPORT_SECURITY: string;\r\n        export const HTTP2_HEADER_TRANSFER_ENCODING: string;\r\n        export const HTTP2_HEADER_TE: string;\r\n        export const HTTP2_HEADER_UPGRADE: string;\r\n        export const HTTP2_HEADER_USER_AGENT: string;\r\n        export const HTTP2_HEADER_VARY: string;\r\n        export const HTTP2_HEADER_VIA: string;\r\n        export const HTTP2_HEADER_WWW_AUTHENTICATE: string;\r\n        export const HTTP2_HEADER_HTTP2_SETTINGS: string;\r\n        export const HTTP2_HEADER_KEEP_ALIVE: string;\r\n        export const HTTP2_HEADER_PROXY_CONNECTION: string;\r\n        export const HTTP2_METHOD_ACL: string;\r\n        export const HTTP2_METHOD_BASELINE_CONTROL: string;\r\n        export const HTTP2_METHOD_BIND: string;\r\n        export const HTTP2_METHOD_CHECKIN: string;\r\n        export const HTTP2_METHOD_CHECKOUT: string;\r\n        export const HTTP2_METHOD_CONNECT: string;\r\n        export const HTTP2_METHOD_COPY: string;\r\n        export const HTTP2_METHOD_DELETE: string;\r\n        export const HTTP2_METHOD_GET: string;\r\n        export const HTTP2_METHOD_HEAD: string;\r\n        export const HTTP2_METHOD_LABEL: string;\r\n        export const HTTP2_METHOD_LINK: string;\r\n        export const HTTP2_METHOD_LOCK: string;\r\n        export const HTTP2_METHOD_MERGE: string;\r\n        export const HTTP2_METHOD_MKACTIVITY: string;\r\n        export const HTTP2_METHOD_MKCALENDAR: string;\r\n        export const HTTP2_METHOD_MKCOL: string;\r\n        export const HTTP2_METHOD_MKREDIRECTREF: string;\r\n        export const HTTP2_METHOD_MKWORKSPACE: string;\r\n        export const HTTP2_METHOD_MOVE: string;\r\n        export const HTTP2_METHOD_OPTIONS: string;\r\n        export const HTTP2_METHOD_ORDERPATCH: string;\r\n        export const HTTP2_METHOD_PATCH: string;\r\n        export const HTTP2_METHOD_POST: string;\r\n        export const HTTP2_METHOD_PRI: string;\r\n        export const HTTP2_METHOD_PROPFIND: string;\r\n        export const HTTP2_METHOD_PROPPATCH: string;\r\n        export const HTTP2_METHOD_PUT: string;\r\n        export const HTTP2_METHOD_REBIND: string;\r\n        export const HTTP2_METHOD_REPORT: string;\r\n        export const HTTP2_METHOD_SEARCH: string;\r\n        export const HTTP2_METHOD_TRACE: string;\r\n        export const HTTP2_METHOD_UNBIND: string;\r\n        export const HTTP2_METHOD_UNCHECKOUT: string;\r\n        export const HTTP2_METHOD_UNLINK: string;\r\n        export const HTTP2_METHOD_UNLOCK: string;\r\n        export const HTTP2_METHOD_UPDATE: string;\r\n        export const HTTP2_METHOD_UPDATEREDIRECTREF: string;\r\n        export const HTTP2_METHOD_VERSION_CONTROL: string;\r\n        export const HTTP_STATUS_CONTINUE: number;\r\n        export const HTTP_STATUS_SWITCHING_PROTOCOLS: number;\r\n        export const HTTP_STATUS_PROCESSING: number;\r\n        export const HTTP_STATUS_OK: number;\r\n        export const HTTP_STATUS_CREATED: number;\r\n        export const HTTP_STATUS_ACCEPTED: number;\r\n        export const HTTP_STATUS_NON_AUTHORITATIVE_INFORMATION: number;\r\n        export const HTTP_STATUS_NO_CONTENT: number;\r\n        export const HTTP_STATUS_RESET_CONTENT: number;\r\n        export const HTTP_STATUS_PARTIAL_CONTENT: number;\r\n        export const HTTP_STATUS_MULTI_STATUS: number;\r\n        export const HTTP_STATUS_ALREADY_REPORTED: number;\r\n        export const HTTP_STATUS_IM_USED: number;\r\n        export const HTTP_STATUS_MULTIPLE_CHOICES: number;\r\n        export const HTTP_STATUS_MOVED_PERMANENTLY: number;\r\n        export const HTTP_STATUS_FOUND: number;\r\n        export const HTTP_STATUS_SEE_OTHER: number;\r\n        export const HTTP_STATUS_NOT_MODIFIED: number;\r\n        export const HTTP_STATUS_USE_PROXY: number;\r\n        export const HTTP_STATUS_TEMPORARY_REDIRECT: number;\r\n        export const HTTP_STATUS_PERMANENT_REDIRECT: number;\r\n        export const HTTP_STATUS_BAD_REQUEST: number;\r\n        export const HTTP_STATUS_UNAUTHORIZED: number;\r\n        export const HTTP_STATUS_PAYMENT_REQUIRED: number;\r\n        export const HTTP_STATUS_FORBIDDEN: number;\r\n        export const HTTP_STATUS_NOT_FOUND: number;\r\n        export const HTTP_STATUS_METHOD_NOT_ALLOWED: number;\r\n        export const HTTP_STATUS_NOT_ACCEPTABLE: number;\r\n        export const HTTP_STATUS_PROXY_AUTHENTICATION_REQUIRED: number;\r\n        export const HTTP_STATUS_REQUEST_TIMEOUT: number;\r\n        export const HTTP_STATUS_CONFLICT: number;\r\n        export const HTTP_STATUS_GONE: number;\r\n        export const HTTP_STATUS_LENGTH_REQUIRED: number;\r\n        export const HTTP_STATUS_PRECONDITION_FAILED: number;\r\n        export const HTTP_STATUS_PAYLOAD_TOO_LARGE: number;\r\n        export const HTTP_STATUS_URI_TOO_LONG: number;\r\n        export const HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE: number;\r\n        export const HTTP_STATUS_RANGE_NOT_SATISFIABLE: number;\r\n        export const HTTP_STATUS_EXPECTATION_FAILED: number;\r\n        export const HTTP_STATUS_TEAPOT: number;\r\n        export const HTTP_STATUS_MISDIRECTED_REQUEST: number;\r\n        export const HTTP_STATUS_UNPROCESSABLE_ENTITY: number;\r\n        export const HTTP_STATUS_LOCKED: number;\r\n        export const HTTP_STATUS_FAILED_DEPENDENCY: number;\r\n        export const HTTP_STATUS_UNORDERED_COLLECTION: number;\r\n        export const HTTP_STATUS_UPGRADE_REQUIRED: number;\r\n        export const HTTP_STATUS_PRECONDITION_REQUIRED: number;\r\n        export const HTTP_STATUS_TOO_MANY_REQUESTS: number;\r\n        export const HTTP_STATUS_REQUEST_HEADER_FIELDS_TOO_LARGE: number;\r\n        export const HTTP_STATUS_UNAVAILABLE_FOR_LEGAL_REASONS: number;\r\n        export const HTTP_STATUS_INTERNAL_SERVER_ERROR: number;\r\n        export const HTTP_STATUS_NOT_IMPLEMENTED: number;\r\n        export const HTTP_STATUS_BAD_GATEWAY: number;\r\n        export const HTTP_STATUS_SERVICE_UNAVAILABLE: number;\r\n        export const HTTP_STATUS_GATEWAY_TIMEOUT: number;\r\n        export const HTTP_STATUS_HTTP_VERSION_NOT_SUPPORTED: number;\r\n        export const HTTP_STATUS_VARIANT_ALSO_NEGOTIATES: number;\r\n        export const HTTP_STATUS_INSUFFICIENT_STORAGE: number;\r\n        export const HTTP_STATUS_LOOP_DETECTED: number;\r\n        export const HTTP_STATUS_BANDWIDTH_LIMIT_EXCEEDED: number;\r\n        export const HTTP_STATUS_NOT_EXTENDED: number;\r\n        export const HTTP_STATUS_NETWORK_AUTHENTICATION_REQUIRED: number;\r\n    }\r\n\r\n    export function getDefaultSettings(): Settings;\r\n    export function getPackedSettings(settings: Settings): Settings;\r\n    export function getUnpackedSettings(buf: Buffer | Uint8Array): Settings;\r\n\r\n    export function createServer(onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void): Http2Server;\r\n    export function createServer(options: ServerOptions, onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void): Http2Server;\r\n\r\n    export function createSecureServer(onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void): Http2SecureServer;\r\n    export function createSecureServer(options: SecureServerOptions, onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void): Http2SecureServer;\r\n\r\n    export function connect(authority: string | url.URL, listener?: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): ClientHttp2Session;\r\n    export function connect(authority: string | url.URL, options?: ClientSessionOptions | SecureClientSessionOptions, listener?: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): ClientHttp2Session;\r\n}\r\n\r\ndeclare module \"perf_hooks\" {\r\n\texport interface PerformanceEntry {\r\n\t\t/**\r\n\t\t * The total number of milliseconds elapsed for this entry.\r\n\t\t * This value will not be meaningful for all Performance Entry types.\r\n\t\t */\r\n\t\treadonly duration: number;\r\n\r\n\t\t/**\r\n\t\t * The name of the performance entry.\r\n\t\t */\r\n\t\treadonly name: string;\r\n\r\n\t\t/**\r\n\t\t * The high resolution millisecond timestamp marking the starting time of the Performance Entry.\r\n\t\t */\r\n\t\treadonly startTime: number;\r\n\r\n\t\t/**\r\n\t\t * The type of the performance entry.\r\n\t\t * Currently it may be one of: 'node', 'mark', 'measure', 'gc', or 'function'.\r\n\t\t */\r\n\t\treadonly entryType: string;\r\n\r\n\t\t/**\r\n\t\t * When performanceEntry.entryType is equal to 'gc', the performance.kind property identifies\r\n\t\t * the type of garbage collection operation that occurred.\r\n\t\t * The value may be one of perf_hooks.constants.\r\n\t\t */\r\n\t\treadonly kind?: number;\r\n\t}\r\n\r\n\texport interface PerformanceNodeTiming extends PerformanceEntry {\r\n\t\t/**\r\n\t\t * The high resolution millisecond timestamp at which the Node.js process completed bootstrap.\r\n\t\t */\r\n\t\treadonly bootstrapComplete: number;\r\n\r\n\t\t/**\r\n\t\t * The high resolution millisecond timestamp at which cluster processing ended.\r\n\t\t */\r\n\t\treadonly clusterSetupEnd: number;\r\n\r\n\t\t/**\r\n\t\t * The high resolution millisecond timestamp at which cluster processing started.\r\n\t\t */\r\n\t\treadonly clusterSetupStart: number;\r\n\r\n\t\t/**\r\n\t\t * The high resolution millisecond timestamp at which the Node.js event loop exited.\r\n\t\t */\r\n\t\treadonly loopExit: number;\r\n\r\n\t\t/**\r\n\t\t * The high resolution millisecond timestamp at which the Node.js event loop started.\r\n\t\t */\r\n\t\treadonly loopStart: number;\r\n\r\n\t\t/**\r\n\t\t * The high resolution millisecond timestamp at which main module load ended.\r\n\t\t */\r\n\t\treadonly moduleLoadEnd: number;\r\n\r\n\t\t/**\r\n\t\t * The high resolution millisecond timestamp at which main module load started.\r\n\t\t */\r\n\t\treadonly moduleLoadStart: number;\r\n\r\n\t\t/**\r\n\t\t * The high resolution millisecond timestamp at which the Node.js process was initialized.\r\n\t\t */\r\n\t\treadonly nodeStart: number;\r\n\r\n\t\t/**\r\n\t\t * The high resolution millisecond timestamp at which preload module load ended.\r\n\t\t */\r\n\t\treadonly preloadModuleLoadEnd: number;\r\n\r\n\t\t/**\r\n\t\t * The high resolution millisecond timestamp at which preload module load started.\r\n\t\t */\r\n\t\treadonly preloadModuleLoadStart: number;\r\n\r\n\t\t/**\r\n\t\t * The high resolution millisecond timestamp at which third_party_main processing ended.\r\n\t\t */\r\n\t\treadonly thirdPartyMainEnd: number;\r\n\r\n\t\t/**\r\n\t\t * The high resolution millisecond timestamp at which third_party_main processing started.\r\n\t\t */\r\n\t\treadonly thirdPartyMainStart: number;\r\n\r\n\t\t/**\r\n\t\t * The high resolution millisecond timestamp at which the V8 platform was initialized.\r\n\t\t */\r\n\t\treadonly v8Start: number;\r\n    }\r\n\r\n\texport interface Performance {\r\n\t\t/**\r\n\t\t * If name is not provided, removes all PerformanceFunction objects from the Performance Timeline.\r\n\t\t * If name is provided, removes entries with name.\r\n\t\t * @param name\r\n\t\t */\r\n\t\tclearFunctions(name?: string): void;\r\n\r\n\t\t/**\r\n\t\t * If name is not provided, removes all PerformanceMark objects from the Performance Timeline.\r\n\t\t * If name is provided, removes only the named mark.\r\n\t\t * @param name\r\n\t\t */\r\n\t\tclearMarks(name?: string): void;\r\n\r\n\t\t/**\r\n\t\t * If name is not provided, removes all PerformanceMeasure objects from the Performance Timeline.\r\n\t\t * If name is provided, removes only objects whose performanceEntry.name matches name.\r\n\t\t */\r\n\t\tclearMeasures(name?: string): void;\r\n\r\n\t\t/**\r\n\t\t * Returns a list of all PerformanceEntry objects in chronological order with respect to performanceEntry.startTime.\r\n\t\t * @return list of all PerformanceEntry objects\r\n\t\t */\r\n\t\tgetEntries(): PerformanceEntry[];\r\n\r\n\t\t/**\r\n\t\t * Returns a list of all PerformanceEntry objects in chronological order with respect to performanceEntry.startTime\r\n\t\t * whose performanceEntry.name is equal to name, and optionally, whose performanceEntry.entryType is equal to type.\r\n\t\t * @param name\r\n\t\t * @param type\r\n\t\t * @return list of all PerformanceEntry objects\r\n\t\t */\r\n\t\tgetEntriesByName(name: string, type?: string): PerformanceEntry[];\r\n\r\n\t\t/**\r\n\t\t * Returns a list of all PerformanceEntry objects in chronological order with respect to performanceEntry.startTime\r\n\t\t * whose performanceEntry.entryType is equal to type.\r\n\t\t * @param type\r\n\t\t * @return list of all PerformanceEntry objects\r\n\t\t */\r\n\t\tgetEntriesByType(type: string): PerformanceEntry[];\r\n\r\n\t\t/**\r\n\t\t * Creates a new PerformanceMark entry in the Performance Timeline.\r\n\t\t * A PerformanceMark is a subclass of PerformanceEntry whose performanceEntry.entryType is always 'mark',\r\n\t\t * and whose performanceEntry.duration is always 0.\r\n\t\t * Performance marks are used to mark specific significant moments in the Performance Timeline.\r\n\t\t * @param name\r\n\t\t */\r\n\t\tmark(name?: string): void;\r\n\r\n\t\t/**\r\n\t\t * Creates a new PerformanceMeasure entry in the Performance Timeline.\r\n\t\t * A PerformanceMeasure is a subclass of PerformanceEntry whose performanceEntry.entryType is always 'measure',\r\n\t\t * and whose performanceEntry.duration measures the number of milliseconds elapsed since startMark and endMark.\r\n\t\t *\r\n\t\t * The startMark argument may identify any existing PerformanceMark in the the Performance Timeline, or may identify\r\n\t\t * any of the timestamp properties provided by the PerformanceNodeTiming class. If the named startMark does not exist,\r\n\t\t * then startMark is set to timeOrigin by default.\r\n\t\t *\r\n\t\t * The endMark argument must identify any existing PerformanceMark in the the Performance Timeline or any of the timestamp\r\n\t\t * properties provided by the PerformanceNodeTiming class. If the named endMark does not exist, an error will be thrown.\r\n\t\t * @param name\r\n\t\t * @param startMark\r\n\t\t * @param endMark\r\n\t\t */\r\n\t\tmeasure(name: string, startMark: string, endMark: string): void;\r\n\r\n\t\t/**\r\n\t\t * An instance of the PerformanceNodeTiming class that provides performance metrics for specific Node.js operational milestones.\r\n\t\t */\r\n\t\treadonly nodeTiming: PerformanceNodeTiming;\r\n\r\n\t\t/**\r\n\t\t * @return the current high resolution millisecond timestamp\r\n\t\t */\r\n\t\tnow(): number;\r\n\r\n\t\t/**\r\n\t\t * The timeOrigin specifies the high resolution millisecond timestamp from which all performance metric durations are measured.\r\n\t\t */\r\n\t\treadonly timeOrigin: number;\r\n\r\n\t\t/**\r\n\t\t * Wraps a function within a new function that measures the running time of the wrapped function.\r\n\t\t * A PerformanceObserver must be subscribed to the 'function' event type in order for the timing details to be accessed.\r\n\t\t * @param fn\r\n\t\t */\r\n\t\ttimerify<T extends (...optionalParams: any[]) => any>(fn: T): T;\r\n    }\r\n\r\n    export interface PerformanceObserverEntryList {\r\n        /**\r\n         * @return a list of PerformanceEntry objects in chronological order with respect to performanceEntry.startTime.\r\n         */\r\n        getEntries(): PerformanceEntry[];\r\n\r\n        /**\r\n         * @return a list of PerformanceEntry objects in chronological order with respect to performanceEntry.startTime\r\n         * whose performanceEntry.name is equal to name, and optionally, whose performanceEntry.entryType is equal to type.\r\n         */\r\n        getEntriesByName(name: string, type?: string): PerformanceEntry[];\r\n\r\n        /**\r\n         * @return Returns a list of PerformanceEntry objects in chronological order with respect to performanceEntry.startTime\r\n         * whose performanceEntry.entryType is equal to type.\r\n         */\r\n        getEntriesByType(type: string): PerformanceEntry[];\r\n    }\r\n\r\n    export type PerformanceObserverCallback = (list: PerformanceObserverEntryList, observer: PerformanceObserver) => void;\r\n\r\n    export class PerformanceObserver {\r\n        constructor(callback: PerformanceObserverCallback);\r\n\r\n        /**\r\n         * Disconnects the PerformanceObserver instance from all notifications.\r\n         */\r\n        disconnect(): void;\r\n\r\n        /**\r\n         * Subscribes the PerformanceObserver instance to notifications of new PerformanceEntry instances identified by options.entryTypes.\r\n         * When options.buffered is false, the callback will be invoked once for every PerformanceEntry instance.\r\n         * Property buffered defaults to false.\r\n         * @param options\r\n         */\r\n        observe(options: { entryTypes: string[], buffered?: boolean }): void;\r\n    }\r\n\r\n    export namespace constants {\r\n        export const NODE_PERFORMANCE_GC_MAJOR: number;\r\n        export const NODE_PERFORMANCE_GC_MINOR: number;\r\n        export const NODE_PERFORMANCE_GC_INCREMENTAL: number;\r\n        export const NODE_PERFORMANCE_GC_WEAKCB: number;\r\n    }\r\n\r\n\tconst performance: Performance;\r\n}\r\n"},"https://unpkg.com/typestyle@1.5.1/lib/types.js":{"fullPath":"https://unpkg.com/typestyle@1.5.1/lib/types.js","contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n"},"https://unpkg.com/typestyle@1.5.1/lib/internal/typestyle.js":{"fullPath":"https://unpkg.com/typestyle@1.5.1/lib/internal/typestyle.js","contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar formatting_1 = require(\"./formatting\");\nvar utilities_1 = require(\"./utilities\");\nvar FreeStyle = require(\"free-style\");\n/**\n * Creates an instance of free style with our options\n */\nvar createFreeStyle = function () { return FreeStyle.create(\n/** Use the default hash function */\nundefined, \n/** Preserve $debugName values */\ntrue); };\n/**\n * Maintains a single stylesheet and keeps it in sync with requested styles\n */\nvar TypeStyle = (function () {\n    function TypeStyle(_a) {\n        var autoGenerateTag = _a.autoGenerateTag;\n        var _this = this;\n        /**\n         * Insert `raw` CSS as a string. This is useful for e.g.\n         * - third party CSS that you are customizing with template strings\n         * - generating raw CSS in JavaScript\n         * - reset libraries like normalize.css that you can use without loaders\n         */\n        this.cssRaw = function (mustBeValidCSS) {\n            if (!mustBeValidCSS) {\n                return;\n            }\n            _this._raw += mustBeValidCSS || '';\n            _this._pendingRawChange = true;\n            _this._styleUpdated();\n        };\n        /**\n         * Takes CSSProperties and registers it to a global selector (body, html, etc.)\n         */\n        this.cssRule = function (selector) {\n            var objects = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                objects[_i - 1] = arguments[_i];\n            }\n            var object = formatting_1.ensureStringObj(utilities_1.extend.apply(void 0, objects)).result;\n            _this._freeStyle.registerRule(selector, object);\n            _this._styleUpdated();\n            return;\n        };\n        /**\n         * Renders styles to the singleton tag imediately\n         * NOTE: You should only call it on initial render to prevent any non CSS flash.\n         * After that it is kept sync using `requestAnimationFrame` and we haven't noticed any bad flashes.\n         **/\n        this.forceRenderStyles = function () {\n            var target = _this._getTag();\n            if (!target) {\n                return;\n            }\n            target.textContent = _this.getStyles();\n        };\n        /**\n         * Utility function to register an @font-face\n         */\n        this.fontFace = function () {\n            var fontFace = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                fontFace[_i] = arguments[_i];\n            }\n            var freeStyle = _this._freeStyle;\n            for (var _a = 0, _b = fontFace; _a < _b.length; _a++) {\n                var face = _b[_a];\n                freeStyle.registerRule('@font-face', face);\n            }\n            _this._styleUpdated();\n            return;\n        };\n        /**\n         * Allows use to use the stylesheet in a node.js environment\n         */\n        this.getStyles = function () {\n            return (_this._raw || '') + _this._freeStyle.getStyles();\n        };\n        /**\n         * Takes keyframes and returns a generated animationName\n         */\n        this.keyframes = function (frames) {\n            var _a = formatting_1.explodeKeyframes(frames), keyframes = _a.keyframes, $debugName = _a.$debugName;\n            // TODO: replace $debugName with display name\n            var animationName = _this._freeStyle.registerKeyframes(keyframes, $debugName);\n            _this._styleUpdated();\n            return animationName;\n        };\n        /**\n         * Helps with testing. Reinitializes FreeStyle + raw\n         */\n        this.reinit = function () {\n            /** reinit freestyle */\n            var freeStyle = createFreeStyle();\n            _this._freeStyle = freeStyle;\n            _this._lastFreeStyleChangeId = freeStyle.changeId;\n            /** reinit raw */\n            _this._raw = '';\n            _this._pendingRawChange = false;\n            /** Clear any styles that were flushed */\n            var target = _this._getTag();\n            if (target) {\n                target.textContent = '';\n            }\n        };\n        /** Sets the target tag where we write the css on style updates */\n        this.setStylesTarget = function (tag) {\n            /** Clear any data in any previous tag */\n            if (_this._tag) {\n                _this._tag.textContent = '';\n            }\n            _this._tag = tag;\n            /** This special time buffer immediately */\n            _this.forceRenderStyles();\n        };\n        /**\n         * Takes CSSProperties and return a generated className you can use on your component\n         */\n        this.style = function () {\n            var objects = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                objects[_i] = arguments[_i];\n            }\n            var freeStyle = _this._freeStyle;\n            var _a = formatting_1.ensureStringObj(utilities_1.extend.apply(void 0, objects)), result = _a.result, debugName = _a.debugName;\n            var className = debugName ? freeStyle.registerStyle(result, debugName) : freeStyle.registerStyle(result);\n            _this._styleUpdated();\n            return className;\n        };\n        var freeStyle = createFreeStyle();\n        this._autoGenerateTag = autoGenerateTag;\n        this._freeStyle = freeStyle;\n        this._lastFreeStyleChangeId = freeStyle.changeId;\n        this._pending = 0;\n        this._pendingRawChange = false;\n        this._raw = '';\n        this._tag = undefined;\n    }\n    /**\n     * Only calls cb all sync operations settle\n     */\n    TypeStyle.prototype._afterAllSync = function (cb) {\n        var _this = this;\n        this._pending++;\n        var pending = this._pending;\n        utilities_1.raf(function () {\n            if (pending !== _this._pending) {\n                return;\n            }\n            cb();\n        });\n    };\n    TypeStyle.prototype._getTag = function () {\n        if (this._tag) {\n            return this._tag;\n        }\n        if (this._autoGenerateTag) {\n            var tag = typeof window === 'undefined'\n                ? { textContent: '' }\n                : document.createElement('style');\n            if (typeof document !== 'undefined') {\n                document.head.appendChild(tag);\n            }\n            this._tag = tag;\n            return tag;\n        }\n        return undefined;\n    };\n    /** Checks if the style tag needs updating and if so queues up the change */\n    TypeStyle.prototype._styleUpdated = function () {\n        var _this = this;\n        var changeId = this._freeStyle.changeId;\n        var lastChangeId = this._lastFreeStyleChangeId;\n        if (!this._pendingRawChange && changeId === lastChangeId) {\n            return;\n        }\n        this._lastFreeStyleChangeId = changeId;\n        this._pendingRawChange = false;\n        this._afterAllSync(function () { return _this.forceRenderStyles(); });\n    };\n    return TypeStyle;\n}());\nexports.TypeStyle = TypeStyle;\n"},"https://unpkg.com/typestyle@1.5.1/lib/internal/utilities.js":{"fullPath":"https://unpkg.com/typestyle@1.5.1/lib/internal/utilities.js","contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** Raf for node + browser */\nexports.raf = typeof requestAnimationFrame === 'undefined'\n    ? function (cb) { return setTimeout(cb); }\n    : requestAnimationFrame.bind(window);\n/**\n * Utility to join classes conditionally\n */\nfunction classes() {\n    var classes = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        classes[_i] = arguments[_i];\n    }\n    return classes.filter(function (c) { return !!c; }).join(' ');\n}\nexports.classes = classes;\n/**\n * Merges various styles into a single style object.\n * Note: if two objects have the same property the last one wins\n */\nfunction extend() {\n    var objects = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        objects[_i] = arguments[_i];\n    }\n    /** The final result we will return */\n    var result = {};\n    for (var _a = 0, objects_1 = objects; _a < objects_1.length; _a++) {\n        var object = objects_1[_a];\n        if (object == null || object === false) {\n            continue;\n        }\n        for (var key in object) {\n            /** Falsy values except a explicit 0 is ignored */\n            var val = object[key];\n            if (!val && val !== 0) {\n                continue;\n            }\n            /** if nested media or pseudo selector */\n            if (key === '$nest' && val) {\n                result[key] = result['$nest'] ? extend(result['$nest'], val) : val;\n            }\n            else if ((key.indexOf('&') !== -1 || key.indexOf('@media') === 0)) {\n                result[key] = result[key] ? extend(result[key], val) : val;\n            }\n            else {\n                result[key] = val;\n            }\n        }\n    }\n    return result;\n}\nexports.extend = extend;\n/**\n * Utility to help customize styles with media queries. e.g.\n * ```\n * style(\n *  media({maxWidth:500}, {color:'red'})\n * )\n * ```\n */\nexports.media = function (mediaQuery) {\n    var objects = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        objects[_i - 1] = arguments[_i];\n    }\n    var mediaQuerySections = [];\n    if (mediaQuery.type)\n        mediaQuerySections.push(mediaQuery.type);\n    if (mediaQuery.orientation)\n        mediaQuerySections.push(mediaQuery.orientation);\n    if (mediaQuery.minWidth)\n        mediaQuerySections.push(\"(min-width: \" + mediaLength(mediaQuery.minWidth) + \")\");\n    if (mediaQuery.maxWidth)\n        mediaQuerySections.push(\"(max-width: \" + mediaLength(mediaQuery.maxWidth) + \")\");\n    if (mediaQuery.minHeight)\n        mediaQuerySections.push(\"(min-height: \" + mediaLength(mediaQuery.minHeight) + \")\");\n    if (mediaQuery.maxHeight)\n        mediaQuerySections.push(\"(max-height: \" + mediaLength(mediaQuery.maxHeight) + \")\");\n    var stringMediaQuery = \"@media \" + mediaQuerySections.join(' and ');\n    var object = {\n        $nest: (_a = {},\n            _a[stringMediaQuery] = extend.apply(void 0, objects),\n            _a)\n    };\n    return object;\n    var _a;\n};\nvar mediaLength = function (value) {\n    return typeof value === 'string' ? value : value + \"px\";\n};\n"},"https://unpkg.com/snabbdom@0.7.1/modules/class.js":{"fullPath":"https://unpkg.com/snabbdom@0.7.1/modules/class.js","contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction updateClass(oldVnode, vnode) {\n    var cur, name, elm = vnode.elm, oldClass = oldVnode.data.class, klass = vnode.data.class;\n    if (!oldClass && !klass)\n        return;\n    if (oldClass === klass)\n        return;\n    oldClass = oldClass || {};\n    klass = klass || {};\n    for (name in oldClass) {\n        if (!klass[name]) {\n            elm.classList.remove(name);\n        }\n    }\n    for (name in klass) {\n        cur = klass[name];\n        if (cur !== oldClass[name]) {\n            elm.classList[cur ? 'add' : 'remove'](name);\n        }\n    }\n}\nexports.classModule = { create: updateClass, update: updateClass };\nexports.default = exports.classModule;\n//# sourceMappingURL=class.js.map"},"https://unpkg.com/typestyle@1.5.1/lib/internal/formatting.js":{"fullPath":"https://unpkg.com/typestyle@1.5.1/lib/internal/formatting.js","contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar FreeStyle = require(\"free-style\");\n/**\n * We need to do the following to *our* objects before passing to freestyle:\n * - For any `$nest` directive move up to FreeStyle style nesting\n * - For any `$unique` directive map to FreeStyle Unique\n * - For any `$debugName` directive return the debug name\n */\nfunction ensureStringObj(object) {\n    /** The final result we will return */\n    var result = {};\n    var debugName = '';\n    for (var key in object) {\n        /** Grab the value upfront */\n        var val = object[key];\n        /** TypeStyle configuration options */\n        if (key === '$unique') {\n            result[FreeStyle.IS_UNIQUE] = val;\n        }\n        else if (key === '$nest') {\n            var nested = val;\n            for (var selector in nested) {\n                var subproperties = nested[selector];\n                result[selector] = ensureStringObj(subproperties).result;\n            }\n        }\n        else if (key === '$debugName') {\n            debugName = val;\n        }\n        else {\n            result[key] = val;\n        }\n    }\n    return { result: result, debugName: debugName };\n}\nexports.ensureStringObj = ensureStringObj;\n// todo: better name here\nfunction explodeKeyframes(frames) {\n    var result = { $debugName: undefined, keyframes: {} };\n    for (var offset in frames) {\n        var val = frames[offset];\n        if (offset === '$debugName') {\n            result.$debugName = val;\n        }\n        else {\n            result.keyframes[offset] = val;\n        }\n    }\n    return result;\n}\nexports.explodeKeyframes = explodeKeyframes;\n"},"https://unpkg.com/snabbdom@0.7.1/modules/style.js":{"fullPath":"https://unpkg.com/snabbdom@0.7.1/modules/style.js","contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar raf = (typeof window !== 'undefined' && window.requestAnimationFrame) || setTimeout;\nvar nextFrame = function (fn) { raf(function () { raf(fn); }); };\nfunction setNextFrame(obj, prop, val) {\n    nextFrame(function () { obj[prop] = val; });\n}\nfunction updateStyle(oldVnode, vnode) {\n    var cur, name, elm = vnode.elm, oldStyle = oldVnode.data.style, style = vnode.data.style;\n    if (!oldStyle && !style)\n        return;\n    if (oldStyle === style)\n        return;\n    oldStyle = oldStyle || {};\n    style = style || {};\n    var oldHasDel = 'delayed' in oldStyle;\n    for (name in oldStyle) {\n        if (!style[name]) {\n            if (name[0] === '-' && name[1] === '-') {\n                elm.style.removeProperty(name);\n            }\n            else {\n                elm.style[name] = '';\n            }\n        }\n    }\n    for (name in style) {\n        cur = style[name];\n        if (name === 'delayed' && style.delayed) {\n            for (var name2 in style.delayed) {\n                cur = style.delayed[name2];\n                if (!oldHasDel || cur !== oldStyle.delayed[name2]) {\n                    setNextFrame(elm.style, name2, cur);\n                }\n            }\n        }\n        else if (name !== 'remove' && cur !== oldStyle[name]) {\n            if (name[0] === '-' && name[1] === '-') {\n                elm.style.setProperty(name, cur);\n            }\n            else {\n                elm.style[name] = cur;\n            }\n        }\n    }\n}\nfunction applyDestroyStyle(vnode) {\n    var style, name, elm = vnode.elm, s = vnode.data.style;\n    if (!s || !(style = s.destroy))\n        return;\n    for (name in style) {\n        elm.style[name] = style[name];\n    }\n}\nfunction applyRemoveStyle(vnode, rm) {\n    var s = vnode.data.style;\n    if (!s || !s.remove) {\n        rm();\n        return;\n    }\n    var name, elm = vnode.elm, i = 0, compStyle, style = s.remove, amount = 0, applied = [];\n    for (name in style) {\n        applied.push(name);\n        elm.style[name] = style[name];\n    }\n    compStyle = getComputedStyle(elm);\n    var props = compStyle['transition-property'].split(', ');\n    for (; i < props.length; ++i) {\n        if (applied.indexOf(props[i]) !== -1)\n            amount++;\n    }\n    elm.addEventListener('transitionend', function (ev) {\n        if (ev.target === elm)\n            --amount;\n        if (amount === 0)\n            rm();\n    });\n}\nexports.styleModule = {\n    create: updateStyle,\n    update: updateStyle,\n    destroy: applyDestroyStyle,\n    remove: applyRemoveStyle\n};\nexports.default = exports.styleModule;\n//# sourceMappingURL=style.js.map"},"https://unpkg.com/snabbdom@0.7.1/modules/props.js":{"fullPath":"https://unpkg.com/snabbdom@0.7.1/modules/props.js","contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction updateProps(oldVnode, vnode) {\n    var key, cur, old, elm = vnode.elm, oldProps = oldVnode.data.props, props = vnode.data.props;\n    if (!oldProps && !props)\n        return;\n    if (oldProps === props)\n        return;\n    oldProps = oldProps || {};\n    props = props || {};\n    for (key in oldProps) {\n        if (!props[key]) {\n            delete elm[key];\n        }\n    }\n    for (key in props) {\n        cur = props[key];\n        old = oldProps[key];\n        if (old !== cur && (key !== 'value' || elm[key] !== cur)) {\n            elm[key] = cur;\n        }\n    }\n}\nexports.propsModule = { create: updateProps, update: updateProps };\nexports.default = exports.propsModule;\n//# sourceMappingURL=props.js.map"},"https://unpkg.com/snabbdom@0.7.1/modules/attributes.js":{"fullPath":"https://unpkg.com/snabbdom@0.7.1/modules/attributes.js","contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\nvar xmlNS = 'http://www.w3.org/XML/1998/namespace';\nvar colonChar = 58;\nvar xChar = 120;\nfunction updateAttrs(oldVnode, vnode) {\n    var key, elm = vnode.elm, oldAttrs = oldVnode.data.attrs, attrs = vnode.data.attrs;\n    if (!oldAttrs && !attrs)\n        return;\n    if (oldAttrs === attrs)\n        return;\n    oldAttrs = oldAttrs || {};\n    attrs = attrs || {};\n    // update modified attributes, add new attributes\n    for (key in attrs) {\n        var cur = attrs[key];\n        var old = oldAttrs[key];\n        if (old !== cur) {\n            if (cur === true) {\n                elm.setAttribute(key, \"\");\n            }\n            else if (cur === false) {\n                elm.removeAttribute(key);\n            }\n            else {\n                if (key.charCodeAt(0) !== xChar) {\n                    elm.setAttribute(key, cur);\n                }\n                else if (key.charCodeAt(3) === colonChar) {\n                    // Assume xml namespace\n                    elm.setAttributeNS(xmlNS, key, cur);\n                }\n                else if (key.charCodeAt(5) === colonChar) {\n                    // Assume xlink namespace\n                    elm.setAttributeNS(xlinkNS, key, cur);\n                }\n                else {\n                    elm.setAttribute(key, cur);\n                }\n            }\n        }\n    }\n    // remove removed attributes\n    // use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value)\n    // the other option is to remove all attributes with value == undefined\n    for (key in oldAttrs) {\n        if (!(key in attrs)) {\n            elm.removeAttribute(key);\n        }\n    }\n}\nexports.attributesModule = { create: updateAttrs, update: updateAttrs };\nexports.default = exports.attributesModule;\n//# sourceMappingURL=attributes.js.map"},"https://unpkg.com/snabbdom@0.7.1/snabbdom.js":{"fullPath":"https://unpkg.com/snabbdom@0.7.1/snabbdom.js","contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar vnode_1 = require(\"./vnode\");\nvar is = require(\"./is\");\nvar htmldomapi_1 = require(\"./htmldomapi\");\nfunction isUndef(s) { return s === undefined; }\nfunction isDef(s) { return s !== undefined; }\nvar emptyNode = vnode_1.default('', {}, [], undefined, undefined);\nfunction sameVnode(vnode1, vnode2) {\n    return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;\n}\nfunction isVnode(vnode) {\n    return vnode.sel !== undefined;\n}\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n    var i, map = {}, key, ch;\n    for (i = beginIdx; i <= endIdx; ++i) {\n        ch = children[i];\n        if (ch != null) {\n            key = ch.key;\n            if (key !== undefined)\n                map[key] = i;\n        }\n    }\n    return map;\n}\nvar hooks = ['create', 'update', 'remove', 'destroy', 'pre', 'post'];\nvar h_1 = require(\"./h\");\nexports.h = h_1.h;\nvar thunk_1 = require(\"./thunk\");\nexports.thunk = thunk_1.thunk;\nfunction init(modules, domApi) {\n    var i, j, cbs = {};\n    var api = domApi !== undefined ? domApi : htmldomapi_1.default;\n    for (i = 0; i < hooks.length; ++i) {\n        cbs[hooks[i]] = [];\n        for (j = 0; j < modules.length; ++j) {\n            var hook = modules[j][hooks[i]];\n            if (hook !== undefined) {\n                cbs[hooks[i]].push(hook);\n            }\n        }\n    }\n    function emptyNodeAt(elm) {\n        var id = elm.id ? '#' + elm.id : '';\n        var c = elm.className ? '.' + elm.className.split(' ').join('.') : '';\n        return vnode_1.default(api.tagName(elm).toLowerCase() + id + c, {}, [], undefined, elm);\n    }\n    function createRmCb(childElm, listeners) {\n        return function rmCb() {\n            if (--listeners === 0) {\n                var parent_1 = api.parentNode(childElm);\n                api.removeChild(parent_1, childElm);\n            }\n        };\n    }\n    function createElm(vnode, insertedVnodeQueue) {\n        var i, data = vnode.data;\n        if (data !== undefined) {\n            if (isDef(i = data.hook) && isDef(i = i.init)) {\n                i(vnode);\n                data = vnode.data;\n            }\n        }\n        var children = vnode.children, sel = vnode.sel;\n        if (sel === '!') {\n            if (isUndef(vnode.text)) {\n                vnode.text = '';\n            }\n            vnode.elm = api.createComment(vnode.text);\n        }\n        else if (sel !== undefined) {\n            // Parse selector\n            var hashIdx = sel.indexOf('#');\n            var dotIdx = sel.indexOf('.', hashIdx);\n            var hash = hashIdx > 0 ? hashIdx : sel.length;\n            var dot = dotIdx > 0 ? dotIdx : sel.length;\n            var tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;\n            var elm = vnode.elm = isDef(data) && isDef(i = data.ns) ? api.createElementNS(i, tag)\n                : api.createElement(tag);\n            if (hash < dot)\n                elm.setAttribute('id', sel.slice(hash + 1, dot));\n            if (dotIdx > 0)\n                elm.setAttribute('class', sel.slice(dot + 1).replace(/\\./g, ' '));\n            for (i = 0; i < cbs.create.length; ++i)\n                cbs.create[i](emptyNode, vnode);\n            if (is.array(children)) {\n                for (i = 0; i < children.length; ++i) {\n                    var ch = children[i];\n                    if (ch != null) {\n                        api.appendChild(elm, createElm(ch, insertedVnodeQueue));\n                    }\n                }\n            }\n            else if (is.primitive(vnode.text)) {\n                api.appendChild(elm, api.createTextNode(vnode.text));\n            }\n            i = vnode.data.hook; // Reuse variable\n            if (isDef(i)) {\n                if (i.create)\n                    i.create(emptyNode, vnode);\n                if (i.insert)\n                    insertedVnodeQueue.push(vnode);\n            }\n        }\n        else {\n            vnode.elm = api.createTextNode(vnode.text);\n        }\n        return vnode.elm;\n    }\n    function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n        for (; startIdx <= endIdx; ++startIdx) {\n            var ch = vnodes[startIdx];\n            if (ch != null) {\n                api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);\n            }\n        }\n    }\n    function invokeDestroyHook(vnode) {\n        var i, j, data = vnode.data;\n        if (data !== undefined) {\n            if (isDef(i = data.hook) && isDef(i = i.destroy))\n                i(vnode);\n            for (i = 0; i < cbs.destroy.length; ++i)\n                cbs.destroy[i](vnode);\n            if (vnode.children !== undefined) {\n                for (j = 0; j < vnode.children.length; ++j) {\n                    i = vnode.children[j];\n                    if (i != null && typeof i !== \"string\") {\n                        invokeDestroyHook(i);\n                    }\n                }\n            }\n        }\n    }\n    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n        for (; startIdx <= endIdx; ++startIdx) {\n            var i_1 = void 0, listeners = void 0, rm = void 0, ch = vnodes[startIdx];\n            if (ch != null) {\n                if (isDef(ch.sel)) {\n                    invokeDestroyHook(ch);\n                    listeners = cbs.remove.length + 1;\n                    rm = createRmCb(ch.elm, listeners);\n                    for (i_1 = 0; i_1 < cbs.remove.length; ++i_1)\n                        cbs.remove[i_1](ch, rm);\n                    if (isDef(i_1 = ch.data) && isDef(i_1 = i_1.hook) && isDef(i_1 = i_1.remove)) {\n                        i_1(ch, rm);\n                    }\n                    else {\n                        rm();\n                    }\n                }\n                else {\n                    api.removeChild(parentElm, ch.elm);\n                }\n            }\n        }\n    }\n    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {\n        var oldStartIdx = 0, newStartIdx = 0;\n        var oldEndIdx = oldCh.length - 1;\n        var oldStartVnode = oldCh[0];\n        var oldEndVnode = oldCh[oldEndIdx];\n        var newEndIdx = newCh.length - 1;\n        var newStartVnode = newCh[0];\n        var newEndVnode = newCh[newEndIdx];\n        var oldKeyToIdx;\n        var idxInOld;\n        var elmToMove;\n        var before;\n        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n            if (oldStartVnode == null) {\n                oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left\n            }\n            else if (oldEndVnode == null) {\n                oldEndVnode = oldCh[--oldEndIdx];\n            }\n            else if (newStartVnode == null) {\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else if (newEndVnode == null) {\n                newEndVnode = newCh[--newEndIdx];\n            }\n            else if (sameVnode(oldStartVnode, newStartVnode)) {\n                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n                oldStartVnode = oldCh[++oldStartIdx];\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else if (sameVnode(oldEndVnode, newEndVnode)) {\n                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n                oldEndVnode = oldCh[--oldEndIdx];\n                newEndVnode = newCh[--newEndIdx];\n            }\n            else if (sameVnode(oldStartVnode, newEndVnode)) {\n                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n                api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));\n                oldStartVnode = oldCh[++oldStartIdx];\n                newEndVnode = newCh[--newEndIdx];\n            }\n            else if (sameVnode(oldEndVnode, newStartVnode)) {\n                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n                api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n                oldEndVnode = oldCh[--oldEndIdx];\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else {\n                if (oldKeyToIdx === undefined) {\n                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n                }\n                idxInOld = oldKeyToIdx[newStartVnode.key];\n                if (isUndef(idxInOld)) {\n                    api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);\n                    newStartVnode = newCh[++newStartIdx];\n                }\n                else {\n                    elmToMove = oldCh[idxInOld];\n                    if (elmToMove.sel !== newStartVnode.sel) {\n                        api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);\n                    }\n                    else {\n                        patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n                        oldCh[idxInOld] = undefined;\n                        api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);\n                    }\n                    newStartVnode = newCh[++newStartIdx];\n                }\n            }\n        }\n        if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {\n            if (oldStartIdx > oldEndIdx) {\n                before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;\n                addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n            }\n            else {\n                removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n            }\n        }\n    }\n    function patchVnode(oldVnode, vnode, insertedVnodeQueue) {\n        var i, hook;\n        if (isDef(i = vnode.data) && isDef(hook = i.hook) && isDef(i = hook.prepatch)) {\n            i(oldVnode, vnode);\n        }\n        var elm = vnode.elm = oldVnode.elm;\n        var oldCh = oldVnode.children;\n        var ch = vnode.children;\n        if (oldVnode === vnode)\n            return;\n        if (vnode.data !== undefined) {\n            for (i = 0; i < cbs.update.length; ++i)\n                cbs.update[i](oldVnode, vnode);\n            i = vnode.data.hook;\n            if (isDef(i) && isDef(i = i.update))\n                i(oldVnode, vnode);\n        }\n        if (isUndef(vnode.text)) {\n            if (isDef(oldCh) && isDef(ch)) {\n                if (oldCh !== ch)\n                    updateChildren(elm, oldCh, ch, insertedVnodeQueue);\n            }\n            else if (isDef(ch)) {\n                if (isDef(oldVnode.text))\n                    api.setTextContent(elm, '');\n                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n            }\n            else if (isDef(oldCh)) {\n                removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n            }\n            else if (isDef(oldVnode.text)) {\n                api.setTextContent(elm, '');\n            }\n        }\n        else if (oldVnode.text !== vnode.text) {\n            api.setTextContent(elm, vnode.text);\n        }\n        if (isDef(hook) && isDef(i = hook.postpatch)) {\n            i(oldVnode, vnode);\n        }\n    }\n    return function patch(oldVnode, vnode) {\n        var i, elm, parent;\n        var insertedVnodeQueue = [];\n        for (i = 0; i < cbs.pre.length; ++i)\n            cbs.pre[i]();\n        if (!isVnode(oldVnode)) {\n            oldVnode = emptyNodeAt(oldVnode);\n        }\n        if (sameVnode(oldVnode, vnode)) {\n            patchVnode(oldVnode, vnode, insertedVnodeQueue);\n        }\n        else {\n            elm = oldVnode.elm;\n            parent = api.parentNode(elm);\n            createElm(vnode, insertedVnodeQueue);\n            if (parent !== null) {\n                api.insertBefore(parent, vnode.elm, api.nextSibling(elm));\n                removeVnodes(parent, [oldVnode], 0, 0);\n            }\n        }\n        for (i = 0; i < insertedVnodeQueue.length; ++i) {\n            insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);\n        }\n        for (i = 0; i < cbs.post.length; ++i)\n            cbs.post[i]();\n        return vnode;\n    };\n}\nexports.init = init;\n//# sourceMappingURL=snabbdom.js.map"},"https://unpkg.com/snabbdom@0.7.1/htmldomapi.js":{"fullPath":"https://unpkg.com/snabbdom@0.7.1/htmldomapi.js","contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction createElement(tagName) {\n    return document.createElement(tagName);\n}\nfunction createElementNS(namespaceURI, qualifiedName) {\n    return document.createElementNS(namespaceURI, qualifiedName);\n}\nfunction createTextNode(text) {\n    return document.createTextNode(text);\n}\nfunction createComment(text) {\n    return document.createComment(text);\n}\nfunction insertBefore(parentNode, newNode, referenceNode) {\n    parentNode.insertBefore(newNode, referenceNode);\n}\nfunction removeChild(node, child) {\n    node.removeChild(child);\n}\nfunction appendChild(node, child) {\n    node.appendChild(child);\n}\nfunction parentNode(node) {\n    return node.parentNode;\n}\nfunction nextSibling(node) {\n    return node.nextSibling;\n}\nfunction tagName(elm) {\n    return elm.tagName;\n}\nfunction setTextContent(node, text) {\n    node.textContent = text;\n}\nfunction getTextContent(node) {\n    return node.textContent;\n}\nfunction isElement(node) {\n    return node.nodeType === 1;\n}\nfunction isText(node) {\n    return node.nodeType === 3;\n}\nfunction isComment(node) {\n    return node.nodeType === 8;\n}\nexports.htmlDomApi = {\n    createElement: createElement,\n    createElementNS: createElementNS,\n    createTextNode: createTextNode,\n    createComment: createComment,\n    insertBefore: insertBefore,\n    removeChild: removeChild,\n    appendChild: appendChild,\n    parentNode: parentNode,\n    nextSibling: nextSibling,\n    tagName: tagName,\n    setTextContent: setTextContent,\n    getTextContent: getTextContent,\n    isElement: isElement,\n    isText: isText,\n    isComment: isComment,\n};\nexports.default = exports.htmlDomApi;\n//# sourceMappingURL=htmldomapi.js.map"},"https://unpkg.com/snabbdom@0.7.1/vnode.js":{"fullPath":"https://unpkg.com/snabbdom@0.7.1/vnode.js","contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction vnode(sel, data, children, text, elm) {\n    var key = data === undefined ? undefined : data.key;\n    return { sel: sel, data: data, children: children,\n        text: text, elm: elm, key: key };\n}\nexports.vnode = vnode;\nexports.default = vnode;\n//# sourceMappingURL=vnode.js.map"},"https://unpkg.com/snabbdom@0.7.1/h.js":{"fullPath":"https://unpkg.com/snabbdom@0.7.1/h.js","contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar vnode_1 = require(\"./vnode\");\nvar is = require(\"./is\");\nfunction addNS(data, children, sel) {\n    data.ns = 'http://www.w3.org/2000/svg';\n    if (sel !== 'foreignObject' && children !== undefined) {\n        for (var i = 0; i < children.length; ++i) {\n            var childData = children[i].data;\n            if (childData !== undefined) {\n                addNS(childData, children[i].children, children[i].sel);\n            }\n        }\n    }\n}\nfunction h(sel, b, c) {\n    var data = {}, children, text, i;\n    if (c !== undefined) {\n        data = b;\n        if (is.array(c)) {\n            children = c;\n        }\n        else if (is.primitive(c)) {\n            text = c;\n        }\n        else if (c && c.sel) {\n            children = [c];\n        }\n    }\n    else if (b !== undefined) {\n        if (is.array(b)) {\n            children = b;\n        }\n        else if (is.primitive(b)) {\n            text = b;\n        }\n        else if (b && b.sel) {\n            children = [b];\n        }\n        else {\n            data = b;\n        }\n    }\n    if (is.array(children)) {\n        for (i = 0; i < children.length; ++i) {\n            if (is.primitive(children[i]))\n                children[i] = vnode_1.vnode(undefined, undefined, undefined, children[i], undefined);\n        }\n    }\n    if (sel[0] === 's' && sel[1] === 'v' && sel[2] === 'g' &&\n        (sel.length === 3 || sel[3] === '.' || sel[3] === '#')) {\n        addNS(data, children, sel);\n    }\n    return vnode_1.vnode(sel, data, children, text, undefined);\n}\nexports.h = h;\n;\nexports.default = h;\n//# sourceMappingURL=h.js.map"},"https://unpkg.com/snabbdom@0.7.1/is.js":{"fullPath":"https://unpkg.com/snabbdom@0.7.1/is.js","contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.array = Array.isArray;\nfunction primitive(s) {\n    return typeof s === 'string' || typeof s === 'number';\n}\nexports.primitive = primitive;\n//# sourceMappingURL=is.js.map"},"https://unpkg.com/snabbdom@0.7.1/thunk.js":{"fullPath":"https://unpkg.com/snabbdom@0.7.1/thunk.js","contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar h_1 = require(\"./h\");\nfunction copyToThunk(vnode, thunk) {\n    thunk.elm = vnode.elm;\n    vnode.data.fn = thunk.data.fn;\n    vnode.data.args = thunk.data.args;\n    thunk.data = vnode.data;\n    thunk.children = vnode.children;\n    thunk.text = vnode.text;\n    thunk.elm = vnode.elm;\n}\nfunction init(thunk) {\n    var cur = thunk.data;\n    var vnode = cur.fn.apply(undefined, cur.args);\n    copyToThunk(vnode, thunk);\n}\nfunction prepatch(oldVnode, thunk) {\n    var i, old = oldVnode.data, cur = thunk.data;\n    var oldArgs = old.args, args = cur.args;\n    if (old.fn !== cur.fn || oldArgs.length !== args.length) {\n        copyToThunk(cur.fn.apply(undefined, args), thunk);\n        return;\n    }\n    for (i = 0; i < args.length; ++i) {\n        if (oldArgs[i] !== args[i]) {\n            copyToThunk(cur.fn.apply(undefined, args), thunk);\n            return;\n        }\n    }\n    copyToThunk(oldVnode, thunk);\n}\nexports.thunk = function thunk(sel, key, fn, args) {\n    if (args === undefined) {\n        args = fn;\n        fn = key;\n        key = undefined;\n    }\n    return h_1.h(sel, {\n        key: key,\n        hook: { init: init, prepatch: prepatch },\n        fn: fn,\n        args: args\n    });\n};\nexports.default = exports.thunk;\n//# sourceMappingURL=thunk.js.map"},"https://unpkg.com/free-style@2.5.1/dist/free-style.js":{"fullPath":"https://unpkg.com/free-style@2.5.1/dist/free-style.js","contents":"\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * The unique id is used for unique hashes.\n */\nvar uniqueId = 0;\n/**\n * Tag styles with this string to get unique hashes.\n */\nexports.IS_UNIQUE = '__DO_NOT_DEDUPE_STYLE__';\nvar upperCasePattern = /[A-Z]/g;\nvar msPattern = /^ms-/;\nvar interpolatePattern = /&/g;\nvar escapePattern = /[ !#$%&()*+,./;<=>?@[\\]^`{|}~\"'\\\\]/g;\nvar propLower = function (m) { return \"-\" + m.toLowerCase(); };\n/**\n * CSS properties that are valid unit-less numbers.\n */\nvar cssNumberProperties = [\n    'animation-iteration-count',\n    'box-flex',\n    'box-flex-group',\n    'column-count',\n    'counter-increment',\n    'counter-reset',\n    'flex',\n    'flex-grow',\n    'flex-positive',\n    'flex-shrink',\n    'flex-negative',\n    'font-weight',\n    'line-clamp',\n    'line-height',\n    'opacity',\n    'order',\n    'orphans',\n    'tab-size',\n    'widows',\n    'z-index',\n    'zoom',\n    // SVG properties.\n    'fill-opacity',\n    'stroke-dashoffset',\n    'stroke-opacity',\n    'stroke-width'\n];\n/**\n * Map of css number properties.\n */\nvar CSS_NUMBER = Object.create(null);\n// Add vendor prefixes to all unit-less properties.\nfor (var _i = 0, _a = ['-webkit-', '-ms-', '-moz-', '-o-', '']; _i < _a.length; _i++) {\n    var prefix = _a[_i];\n    for (var _b = 0, cssNumberProperties_1 = cssNumberProperties; _b < cssNumberProperties_1.length; _b++) {\n        var property = cssNumberProperties_1[_b];\n        CSS_NUMBER[prefix + property] = true;\n    }\n}\n/**\n * Escape a CSS class name.\n */\nexports.escape = function (str) { return str.replace(escapePattern, '\\\\$&'); };\n/**\n * Transform a JavaScript property into a CSS property.\n */\nfunction hyphenate(propertyName) {\n    return propertyName\n        .replace(upperCasePattern, propLower)\n        .replace(msPattern, '-ms-'); // Internet Explorer vendor prefix.\n}\nexports.hyphenate = hyphenate;\n/**\n * Generate a hash value from a string.\n */\nfunction stringHash(str) {\n    var value = 5381;\n    var len = str.length;\n    while (len--)\n        value = (value * 33) ^ str.charCodeAt(len);\n    return (value >>> 0).toString(36);\n}\nexports.stringHash = stringHash;\n/**\n * Transform a style string to a CSS string.\n */\nfunction styleToString(key, value) {\n    if (typeof value === 'number' && value !== 0 && !CSS_NUMBER[key]) {\n        return key + \":\" + value + \"px\";\n    }\n    return key + \":\" + value;\n}\n/**\n * Sort an array of tuples by first value.\n */\nfunction sortTuples(value) {\n    return value.sort(function (a, b) { return a[0] > b[0] ? 1 : -1; });\n}\n/**\n * Categorize user styles.\n */\nfunction parseStyles(styles, hasNestedStyles) {\n    var properties = [];\n    var nestedStyles = [];\n    var isUnique = false;\n    // Sort keys before adding to styles.\n    for (var _i = 0, _a = Object.keys(styles); _i < _a.length; _i++) {\n        var key = _a[_i];\n        var value = styles[key];\n        if (value !== null && value !== undefined) {\n            if (key === exports.IS_UNIQUE) {\n                isUnique = true;\n            }\n            else if (typeof value === 'object' && !Array.isArray(value)) {\n                nestedStyles.push([key.trim(), value]);\n            }\n            else {\n                properties.push([hyphenate(key.trim()), value]);\n            }\n        }\n    }\n    return {\n        styleString: stringifyProperties(sortTuples(properties)),\n        nestedStyles: hasNestedStyles ? nestedStyles : sortTuples(nestedStyles),\n        isUnique: isUnique\n    };\n}\n/**\n * Stringify an array of property tuples.\n */\nfunction stringifyProperties(properties) {\n    return properties.map(function (_a) {\n        var name = _a[0], value = _a[1];\n        if (!Array.isArray(value))\n            return styleToString(name, value);\n        return value.map(function (x) { return styleToString(name, x); }).join(';');\n    }).join(';');\n}\n/**\n * Interpolate CSS selectors.\n */\nfunction interpolate(selector, parent) {\n    if (selector.indexOf('&') > -1) {\n        return selector.replace(interpolatePattern, parent);\n    }\n    return parent + \" \" + selector;\n}\n/**\n * Recursive loop building styles with deferred selectors.\n */\nfunction stylize(cache, selector, styles, list, parent) {\n    var _a = parseStyles(styles, !!selector), styleString = _a.styleString, nestedStyles = _a.nestedStyles, isUnique = _a.isUnique;\n    var pid = styleString;\n    if (selector.charCodeAt(0) === 64 /* @ */) {\n        var rule = cache.add(new Rule(selector, parent ? undefined : styleString, cache.hash));\n        // Nested styles support (e.g. `.foo > @media > .bar`).\n        if (styleString && parent) {\n            var style = rule.add(new Style(styleString, rule.hash, isUnique ? \"u\" + (++uniqueId).toString(36) : undefined));\n            list.push([parent, style]);\n        }\n        for (var _i = 0, nestedStyles_1 = nestedStyles; _i < nestedStyles_1.length; _i++) {\n            var _b = nestedStyles_1[_i], name = _b[0], value = _b[1];\n            pid += name + stylize(rule, name, value, list, parent);\n        }\n    }\n    else {\n        var key = parent ? interpolate(selector, parent) : selector;\n        if (styleString) {\n            var style = cache.add(new Style(styleString, cache.hash, isUnique ? \"u\" + (++uniqueId).toString(36) : undefined));\n            list.push([key, style]);\n        }\n        for (var _c = 0, nestedStyles_2 = nestedStyles; _c < nestedStyles_2.length; _c++) {\n            var _d = nestedStyles_2[_c], name = _d[0], value = _d[1];\n            pid += name + stylize(cache, name, value, list, key);\n        }\n    }\n    return pid;\n}\n/**\n * Register all styles, but collect for selector interpolation using the hash.\n */\nfunction composeStyles(container, selector, styles, isStyle, displayName) {\n    var cache = new Cache(container.hash);\n    var list = [];\n    var pid = stylize(cache, selector, styles, list);\n    var hash = \"f\" + cache.hash(pid);\n    var id = displayName ? displayName + \"_\" + hash : hash;\n    for (var _i = 0, list_1 = list; _i < list_1.length; _i++) {\n        var _a = list_1[_i], selector_1 = _a[0], style = _a[1];\n        var key = isStyle ? interpolate(selector_1, \".\" + exports.escape(id)) : selector_1;\n        style.add(new Selector(key, style.hash, undefined, pid));\n    }\n    return { cache: cache, pid: pid, id: id };\n}\n/**\n * Cache to list to styles.\n */\nfunction join(arr) {\n    var res = '';\n    for (var i = 0; i < arr.length; i++)\n        res += arr[i];\n    return res;\n}\n/**\n * Noop changes.\n */\nvar noopChanges = {\n    add: function () { return undefined; },\n    change: function () { return undefined; },\n    remove: function () { return undefined; }\n};\n/**\n * Implement a cache/event emitter.\n */\nvar Cache = /** @class */ (function () {\n    function Cache(hash, changes) {\n        if (hash === void 0) { hash = stringHash; }\n        if (changes === void 0) { changes = noopChanges; }\n        this.hash = hash;\n        this.changes = changes;\n        this.sheet = [];\n        this.changeId = 0;\n        this._keys = [];\n        this._children = Object.create(null);\n        this._counters = Object.create(null);\n    }\n    Cache.prototype.add = function (style) {\n        var count = this._counters[style.id] || 0;\n        var item = this._children[style.id] || style.clone();\n        this._counters[style.id] = count + 1;\n        if (count === 0) {\n            this._children[item.id] = item;\n            this._keys.push(item.id);\n            this.sheet.push(item.getStyles());\n            this.changeId++;\n            this.changes.add(item, this._keys.length - 1);\n        }\n        else {\n            // Check if contents are different.\n            if (item.getIdentifier() !== style.getIdentifier()) {\n                throw new TypeError(\"Hash collision: \" + style.getStyles() + \" === \" + item.getStyles());\n            }\n            var oldIndex = this._keys.indexOf(style.id);\n            var newIndex = this._keys.length - 1;\n            var prevChangeId = this.changeId;\n            if (oldIndex !== newIndex) {\n                this._keys.splice(oldIndex, 1);\n                this._keys.push(style.id);\n                this.changeId++;\n            }\n            if (item instanceof Cache && style instanceof Cache) {\n                var prevChangeId_1 = item.changeId;\n                item.merge(style);\n                if (item.changeId !== prevChangeId_1) {\n                    this.changeId++;\n                }\n            }\n            if (this.changeId !== prevChangeId) {\n                if (oldIndex === newIndex) {\n                    this.sheet.splice(oldIndex, 1, item.getStyles());\n                }\n                else {\n                    this.sheet.splice(oldIndex, 1);\n                    this.sheet.splice(newIndex, 0, item.getStyles());\n                }\n                this.changes.change(item, oldIndex, newIndex);\n            }\n        }\n        return item;\n    };\n    Cache.prototype.remove = function (style) {\n        var count = this._counters[style.id];\n        if (count > 0) {\n            this._counters[style.id] = count - 1;\n            var item = this._children[style.id];\n            var index = this._keys.indexOf(item.id);\n            if (count === 1) {\n                delete this._counters[style.id];\n                delete this._children[style.id];\n                this._keys.splice(index, 1);\n                this.sheet.splice(index, 1);\n                this.changeId++;\n                this.changes.remove(item, index);\n            }\n            else if (item instanceof Cache && style instanceof Cache) {\n                var prevChangeId = item.changeId;\n                item.unmerge(style);\n                if (item.changeId !== prevChangeId) {\n                    this.sheet.splice(index, 1, item.getStyles());\n                    this.changeId++;\n                    this.changes.change(item, index, index);\n                }\n            }\n        }\n    };\n    Cache.prototype.merge = function (cache) {\n        for (var _i = 0, _a = cache._keys; _i < _a.length; _i++) {\n            var id = _a[_i];\n            this.add(cache._children[id]);\n        }\n        return this;\n    };\n    Cache.prototype.unmerge = function (cache) {\n        for (var _i = 0, _a = cache._keys; _i < _a.length; _i++) {\n            var id = _a[_i];\n            this.remove(cache._children[id]);\n        }\n        return this;\n    };\n    Cache.prototype.clone = function () {\n        return new Cache(this.hash).merge(this);\n    };\n    return Cache;\n}());\nexports.Cache = Cache;\n/**\n * Selector is a dumb class made to represent nested CSS selectors.\n */\nvar Selector = /** @class */ (function () {\n    function Selector(selector, hash, id, pid) {\n        if (id === void 0) { id = \"s\" + hash(selector); }\n        if (pid === void 0) { pid = ''; }\n        this.selector = selector;\n        this.hash = hash;\n        this.id = id;\n        this.pid = pid;\n    }\n    Selector.prototype.getStyles = function () {\n        return this.selector;\n    };\n    Selector.prototype.getIdentifier = function () {\n        return this.pid + \".\" + this.selector;\n    };\n    Selector.prototype.clone = function () {\n        return new Selector(this.selector, this.hash, this.id, this.pid);\n    };\n    return Selector;\n}());\nexports.Selector = Selector;\n/**\n * The style container registers a style string with selectors.\n */\nvar Style = /** @class */ (function (_super) {\n    __extends(Style, _super);\n    function Style(style, hash, id) {\n        if (id === void 0) { id = \"c\" + hash(style); }\n        var _this = _super.call(this, hash) || this;\n        _this.style = style;\n        _this.hash = hash;\n        _this.id = id;\n        return _this;\n    }\n    Style.prototype.getStyles = function () {\n        return this.sheet.join(',') + \"{\" + this.style + \"}\";\n    };\n    Style.prototype.getIdentifier = function () {\n        return this.style;\n    };\n    Style.prototype.clone = function () {\n        return new Style(this.style, this.hash, this.id).merge(this);\n    };\n    return Style;\n}(Cache));\nexports.Style = Style;\n/**\n * Implement rule logic for style output.\n */\nvar Rule = /** @class */ (function (_super) {\n    __extends(Rule, _super);\n    function Rule(rule, style, hash, id, pid) {\n        if (style === void 0) { style = ''; }\n        if (id === void 0) { id = \"a\" + hash(rule + \".\" + style); }\n        if (pid === void 0) { pid = ''; }\n        var _this = _super.call(this, hash) || this;\n        _this.rule = rule;\n        _this.style = style;\n        _this.hash = hash;\n        _this.id = id;\n        _this.pid = pid;\n        return _this;\n    }\n    Rule.prototype.getStyles = function () {\n        return this.rule + \"{\" + this.style + join(this.sheet) + \"}\";\n    };\n    Rule.prototype.getIdentifier = function () {\n        return this.pid + \".\" + this.rule + \".\" + this.style;\n    };\n    Rule.prototype.clone = function () {\n        return new Rule(this.rule, this.style, this.hash, this.id, this.pid).merge(this);\n    };\n    return Rule;\n}(Cache));\nexports.Rule = Rule;\n/**\n * The FreeStyle class implements the API for everything else.\n */\nvar FreeStyle = /** @class */ (function (_super) {\n    __extends(FreeStyle, _super);\n    function FreeStyle(hash, debug, id, changes) {\n        if (hash === void 0) { hash = stringHash; }\n        if (debug === void 0) { debug = typeof process !== 'undefined' && process.env['NODE_ENV'] !== 'production'; }\n        if (id === void 0) { id = \"f\" + (++uniqueId).toString(36); }\n        var _this = _super.call(this, hash, changes) || this;\n        _this.hash = hash;\n        _this.debug = debug;\n        _this.id = id;\n        return _this;\n    }\n    FreeStyle.prototype.registerStyle = function (styles, displayName) {\n        var debugName = this.debug ? displayName : undefined;\n        var _a = composeStyles(this, '&', styles, true, debugName), cache = _a.cache, id = _a.id;\n        this.merge(cache);\n        return id;\n    };\n    FreeStyle.prototype.registerKeyframes = function (keyframes, displayName) {\n        return this.registerHashRule('@keyframes', keyframes, displayName);\n    };\n    FreeStyle.prototype.registerHashRule = function (prefix, styles, displayName) {\n        var debugName = this.debug ? displayName : undefined;\n        var _a = composeStyles(this, '', styles, false, debugName), cache = _a.cache, pid = _a.pid, id = _a.id;\n        var rule = new Rule(prefix + \" \" + exports.escape(id), undefined, this.hash, undefined, pid);\n        this.add(rule.merge(cache));\n        return id;\n    };\n    FreeStyle.prototype.registerRule = function (rule, styles) {\n        this.merge(composeStyles(this, rule, styles, false).cache);\n    };\n    FreeStyle.prototype.registerCss = function (styles) {\n        this.merge(composeStyles(this, '', styles, false).cache);\n    };\n    FreeStyle.prototype.getStyles = function () {\n        return join(this.sheet);\n    };\n    FreeStyle.prototype.getIdentifier = function () {\n        return this.id;\n    };\n    FreeStyle.prototype.clone = function () {\n        return new FreeStyle(this.hash, this.debug, this.id, this.changes).merge(this);\n    };\n    return FreeStyle;\n}(Cache));\nexports.FreeStyle = FreeStyle;\n/**\n * Exports a simple function to create a new instance.\n */\nfunction create(hash, debug, changes) {\n    return new FreeStyle(hash, debug, undefined, changes);\n}\nexports.create = create;\n//# sourceMappingURL=free-style.js.map"}}});})(EngineBlock);
